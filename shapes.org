# -*- mode: Org; org-use-property-inheritance: t -*-

#+STARTUP: overview
#+FILETAGS: :emacs:




#+title:Shapes
#+PROPERTY: header-args:emacs-lisp :results none :mkdirp yes


* Core
** Load
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./core/shapes-load.el
:END:

#+begin_src emacs-lisp

(defun shapes-load (type component)
  "Load a shapeshifter COMPONENT of the given TYPE"
  (require (intern (concat "shapes-" type "-" component)) (concat config-directory type "s" "/shapes-" component ".el")))

;; shapeshifter modules
(defun shapes-module (module)
  "Load a shapeshifter MODULE by name"
  (shapes-load "module" module))

;; shapeshifter layers
(defun shapes-layer (layer)
  "Load a shapeshifter LAYER by name"
  (shapes-load "layer" layer))

;; shapeshifter extensions
(defun shapes-extend (extension)
  "Load a shapeshifter EXTENSION by name"
  (shapes-load "extension" extension))

#+end_src

** Modules
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./core/shapes-modules.el
:END:

#+begin_src emacs-lisp

;; package manager
(shapes-module "straight")

;; other modules
(shapes-module "async")

#+end_src

** Tangling
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./core/shapes-tangling.el
:END:

#+begin_src emacs-lisp

(defun custom/shapes-tangle (org-file &optional quiet)
  "Asynchronously tangle an org file."
  (let ((init-tangle-start-time (current-time))
	    (file (buffer-file-name))
	    (async-quiet-switch "-q"))
    (async-start
     `(lambda ()
	      (require 'org)
	      (add-hook 'org-babel-post-tangle-hook
			(lambda ()
				(string-match "\\(^.*/\\)\\(.*\\)\\(s?/shapes-\\)\\(.*\\)\\(.el\\)" (buffer-file-name))
				(let ((component (match-string 4 (buffer-file-name)))
				      (comp-type (match-string 2 (buffer-file-name))))
				     (end-of-buffer)
				     (insert (concat
					      "\n"
					      "(provide 'shapes-" comp-type "-" component ")\n"
					      ";;; shapes-" component ".el ends here"))
				     (save-buffer))))
		   (org-babel-tangle-file ,org-file))
     (unless quiet
       `(lambda (result)
		     (if result
			 (message "SUCCESS: %s successfully tangled (%.2fs)."
				  ,org-file
				  (float-time (time-subtract (current-time)
							     ',init-tangle-start-time)))
		       (message "ERROR: %s tangling failed." ,org-file)))))))

(defun custom/shapes-tangle-auto ()
  "Automatically tangle Org Mode files in the Emacs config directory"
  (let* ((file   (expand-file-name buffer-file-name))
	    (source (string-match (concat config-directory ".*.org$") file))
	    (shapes (string-match (concat config-directory "shapes.org$") buffer-file-name))
	    (org-confirm-babel-evaluate nil))
    (if source
	(if shapes
	    (custom/shapes-tangle file)
	  (org-babel-tangle)))))

(add-hook 'after-save-hook #'custom/shapes-tangle-auto)

#+end_src


* Layers
** UI
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-ui.el
:END:
*** Text
**** Typefaces

#+begin_src emacs-lisp

;; icons
(shapes-module "all-the-icons")

#+end_src

**** Highlights

#+begin_src emacs-lisp

;; highlights
(shapes-module "rainbow-mode")

#+end_src

*** Buffer

#+begin_src emacs-lisp

;; centering
(shapes-module "olivetti")

;; line numbers
(global-set-key (kbd "C-c l") #'display-line-numbers-mode)

#+end_src

*** Frame

#+begin_src emacs-lisp

;; size
(add-to-list 'default-frame-alist '(height . 50))
(add-to-list 'default-frame-alist '(width  . 70))

;; tabs
(tab-bar-mode 1)

;; no visible scroll bar
(scroll-bar-mode -1)
;; no toolbar
(tool-bar-mode -1)
;; no tooltips
(tooltip-mode -1)
;; no menu bar
(menu-bar-mode -1)

;; title
(setq-default frame-title-format '("Emacs [%m] %b"))

#+end_src

*** Window

#+begin_src emacs-lisp

;; fringes
(set-fringe-mode nil)

;; balance
(global-set-key (kbd "C-x -") #'balance-windows)

;; split threshold
(setq split-width-threshold 70)

#+end_src

*** Warnings

#+begin_src emacs-lisp

;; visible bell
(setq visible-bell t)

#+end_src

*** Mode line

#+begin_src emacs-lisp

;; time
(display-time-mode t)

;; column numbers
(column-number-mode)

;; mode display
(shapes-module "delight")

#+end_src

*** Extensions

#+begin_src emacs-lisp

;; extensions
(shapes-extend "ui")

#+end_src

** Input
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-input.el
:END:

#+begin_src emacs-lisp

;; commands
(shapes-module "god-mode")

;; confirmation
(advice-add 'yes-or-no-p :override #'y-or-n-p)

#+end_src

** Themes
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-themes.el
:END:

Shapeshifter themes layer. It requires three variables to be defined: the light and dark themes (~light~ and ~dark~ respectively), and the mode line of choice (~modeline~).

#+begin_src emacs-lisp

(defcustom light 'modus-operandi
  "Light theme")
(defcustom dark  'modus-vivendi
  "Dark theme")

;; themes
(shapes-module "nano-theme")
(shapes-module "doom-themes")
(shapes-module "modus-themes")
(shapes-module "sweet-theme")
(shapes-module "graphite-theme")
(shapes-module "chocolate-theme")

;; extensions
(shapes-extend "themes")

;; scheduling
(shapes-module "circadian")

#+end_src

** Mode line
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-mode-line.el
:END:

#+begin_src emacs-lisp

(defcustom modeline 'doom-modeline-mode
  "Mode line")

;; mode lines
(shapes-module "nano-modeline")
(shapes-module "doom-modeline")
(shapes-module "spaceline")

;; mode line initialization hook
(add-hook 'after-init-hook modeline)

#+end_src


** Editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-editing.el
:END:

#+begin_src emacs-lisp

(shapes-module "vundo")
(shapes-module "multiple-cursors")

;; extensions
(shapes-extend "editing")

#+end_src


** Navigation
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-navigation.el
:END:

#+begin_src emacs-lisp

;; frame
(global-set-key (kbd "C-S-n") #'make-frame-command)

;; window
(shapes-module "winner")
(shapes-module "ace-window")

;; extensions
(shapes-extend "navigation")

#+end_src


** File management
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-file-management.el
:END:

~backup-directory-alist~, which determines where backups are saved, is set by ~no-littering~.

#+begin_src emacs-lisp

;; buffer backups
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 2)
(setq kept-old-versions 2)

;; file manager
(shapes-module "dirvish")

;; extensions
(shapes-extend "file-management")

#+end_src


** IDE
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-ide.el
:END:

#+begin_src emacs-lisp

;; remove duplicates in shell history
(setq comint-input-ignoredups t)

;; folding
(shapes-module "hideshow")
;; completion
(shapes-module "company")
;; syntax checking
(shapes-module "flycheck")

;; lisp
(shapes-module "rainbow-delimiters")
;; python
(shapes-module "elpy")

#+end_src

** Org Mode
*** org
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-org.el
:END:

#+begin_src emacs-lisp

(shapes-module "org")

;; editing
(shapes-module "org-paragraph")

;; templates
(shapes-module "org-tempo")
(shapes-module "org-capture")

;; export
(shapes-module "ox-rst")

;; notes
(shapes-module "org-diary")
(shapes-module "org-roam")

;; agenda
(shapes-module "org-agenda")
(shapes-module "org-contacts")
(shapes-module "org-calendar")

;; programming
(shapes-module "org-babel")

;; extensions
(shapes-extend "org")

#+end_src

*** org-ui
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-org-ui.el
:END:

#+begin_src emacs-lisp

(shapes-module "org-modern")

#+end_src

**** Text
***** Hidden

#+begin_src emacs-lisp

(shapes-module "org-appear")

#+end_src

***** Typefaces
****** Title

#+begin_src emacs-lisp

;; title face

(defun custom/org-typeface-title ()
  (with-eval-after-load 'org-faces
    (set-face-attribute 'org-document-title nil :font typeface-title :height 300 :weight 'regular :foreground 'unspecified)))

(add-hook 'org-mode-hook #'custom/org-typeface-title)

#+end_src

****** Body

#+begin_src emacs-lisp

(defun custom/org-typefaces-body ()
  (with-eval-after-load 'org-faces

    ;; Code
    (set-face-attribute 'org-block                 nil :foreground nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code                  nil                 :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim              nil                 :inherit '(shadow fixed-pitch))

    ;; Tables
    (set-face-attribute 'org-table                 nil                 :inherit '(shadow fixed-pitch))

    ;; Lists
    (set-face-attribute 'org-checkbox              nil                 :inherit 'fixed-pitch)

    ;; Meta
    (set-face-attribute 'org-meta-line             nil                 :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info         nil                 :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info-keyword nil                 :inherit 'fixed-pitch)
    (set-face-attribute 'org-special-keyword       nil                 :inherit 'fixed-pitch)))

(add-hook 'org-mode-hook #'custom/org-typefaces-body)

#+end_src

****** Indent

#+begin_src emacs-lisp

(defun custom/org-typeface-indent ()
  "Indent typeface used in `org-indent-mode' and `visual-line-mode'."
  (with-eval-after-load 'org-indent-mode
    (set-face-attribute 'org-indent                nil                 :inherit '(org-hide fixed-pitch))))

(add-hook 'org-mode-hook #'custom/org-typeface-indent)

#+end_src

****** Headings

#+begin_src emacs-lisp

;; use levels 1 through 8
(setq org-n-level-faces 8)

;; do not cycle header style after 8th level
(setq org-cycle-level-faces nil)

;; hide leading stars
(setq org-hide-leading-starts t)

;; font sizes
(defun custom/org-header-setup () 
  (with-eval-after-load 'org-faces

    ;; heading font sizes
    (dolist (face '((org-level-1 . 1.6)
                    (org-level-2 . 1.4)
                    (org-level-3 . 1.3)
                    (org-level-4 . 1.2)
                    (org-level-5 . 1.15)
                    (org-level-6 . 1.10)
                    (org-level-7 . 1.05)
                    (org-level-8 . 1.00)))
         (set-face-attribute (car face) nil :font typeface-heading :weight 'bold :height (cdr face)))))

(add-hook 'org-mode-hook #'custom/org-header-setup)

#+end_src

***** Indentation

#+begin_src emacs-lisp

;; org-indent-mode
(add-hook 'org-mode-hook #'org-indent-mode)

;; list indentation
(setq-default org-list-indent-offset 1)

#+end_src

***** Line-wrapping

#+begin_src emacs-lisp

(add-hook 'org-mode-hook (lambda () (progn (visual-line-mode 1) (setq line-move-visual t))))

#+end_src

***** Pretty entities

#+begin_src emacs-lisp

;; symbols, super- and subscripts
(setq org-pretty-entities nil)

#+end_src

**** Icons
***** Ellipses

Candidates:
- triangles
  ▼
  ▾
  ▿
- rhomboids
  ⬙
  ⟡
  ⬥
  ♦
  ♢
- non-compliant
  ⧨
  
-----

#+begin_src emacs-lisp

;; Change ellipsis ("...") to remove clutter
(setq org-ellipsis " ♢")

#+end_src

**** Figures

#+begin_src emacs-lisp

;; startup with inline images
(setq org-startup-with-inline-images t)

;; no actual width
(setq org-image-actual-width nil)

;; drag and drop
(shapes-module "org-download")

#+end_src

*** TODO org-latex-preview
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./layers/shapes-org-latex-preview.el
:END:

- org LaTeX equations
   - custom array envs
      - cases
         - \arraycolsep=1.4pt\def\arraystretch{1.5}
      - derivations
         - \arraycolsep=3pt\def\arraystretch{2.25}

#+begin_src emacs-lisp

(shapes-module "org-fragtog")

#+end_src

**** TODO Options

- mail bug in

Importantly, ~modus-vivendi~ will not behave correctly with
the default ~org-format-latex-options~, with LaTeX previews
displaying as white boxes. [[https://debbugs.gnu.org/db/52/52277.html][This has been previously reported]].

~org-format-latex-options~ has ~:foreground~ and ~:background~
attributes. These may be assigned to

- a color,
- ~default~, instructing Org Mode to determine ~:foreground~ or
  ~:background~ from the foreground or background color of the
  default face, or
- ~auto~, doing the same for the text face.

By default, the ~:foreground~ and ~:background~ in ~org-format-latex-options~
are set to ~default~. With default settings, changing the color
of the ~default~ font has the following effects on the LaTeX preview SVGs:

- modus-operandi
   - ~default :foreground~: text color
   - ~default :background~: no effect
- modus-vivendi
   - ~default :foreground~: background color
   - ~default :background~: no effect

By eliminating the ~:background~ attribute from ~org-format-latex-options~
the issue is resolved.

1. ~modus-operandi~ does not suffer from this issue nor do various
   other themes. This makes me believe the issue lies with
   ~modus-vivendi~ itself.
2. However, the ~:background~ attribute in ~org-format-latex-options~
   seems to have no effect, a potential bug in Org Mode

#+begin_src emacs-lisp

(setq org-format-latex-options
        (list :foreground 'default
              :scale      1.2))

#+end_src

**** Header

#+begin_src emacs-lisp

;; Justify equation labels - [fleqn]
;; Preview page width      - 10.5cm
(setq org-format-latex-header
      (string-join '("\\documentclass[fleqn]{article}"
		        "\\usepackage[usenames]{color}"
			
			"\\usepackage{bm}"
			
			"\\pagestyle{empty}"
			"\\setlength{\\textwidth}{10.5cm}"
			"\\addtolength{\\textwidth}{-3cm}"
			"\\setlength{\\oddsidemargin}{1.5cm}"
			"\\addtolength{\\oddsidemargin}{-2.54cm}"
			"\\setlength{\\evensidemargin}{\\oddsidemargin}"
			"\\setlength{\\textheight}{\\paperheight}"
			"\\addtolength{\\textheight}{-\\headheight}"
			"\\addtolength{\\textheight}{-\\headsep}"
			"\\addtolength{\\textheight}{-\\footskip}"
			"\\addtolength{\\textheight}{-3cm}"
			"\\setlength{\\topmargin}{1.5cm}"
			"\\addtolength{\\topmargin}{-2.54cm}")
		   "\n"))

#+end_src

**** Equation preview format

#+begin_src emacs-lisp

;; SVG LaTeX equation preview
(setq org-latex-create-formula-image-program 'dvisvgm)

#+end_src

**** Equation preview directory

#+begin_src emacs-lisp

;; theme-specific LaTeX preview directory
(defun custom/latex-preview-directory ()
  "Set `org-preview-latex-image-directory' to the SVG
LaTeX preview directory of the current theme"
  (setq org-preview-latex-image-directory
   (concat "/tmp/ltximg/" (custom/current-theme) "/")))

#+end_src

**** Equation preview reload hook

#+begin_src emacs-lisp

(defun custom/latex-preview-reload ()
  "Reload all LaTeX previews in buffer,
ensuring the LaTeX preview directory
matches the current theme."
  (if (custom/in-mode "org-mode")
      (progn (org-latex-preview '(64))
	        (custom/latex-preview-directory)
		(org-latex-preview '(16)))))

(add-hook 'org-mode-hook #'custom/latex-preview-reload)

#+end_src


* Modules
** Infrastructure
*** Package manager
**** straight
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-straight.el
:END:

#+begin_src emacs-lisp

;; straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

**** use-package                                                      :arch:
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-use-package.el
:END:

#+begin_src emacs-lisp

;; package
(require 'package)
(setq package-archives '(("melpa" . "https://melpa.org/packages/")
			   ("org"   . "https://orgmode.org/elpa/")
			   ("elpa"  . "https://elpa.gnu.org/packages/")))
(package-initialize)

;; use-package
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)

;; ensure
(setq use-package-always-ensure t)

#+end_src

#+begin_src emacs-lisp :tangle no

;; update package database
(package-refresh-contents)

#+end_src

*** Config management
**** Async
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-async.el
:END:

#+begin_src emacs-lisp

;; async
(straight-use-package 'async)
(require 'async)

#+end_src

**** Littering
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-no-littering.el
:END:

#+begin_src emacs-lisp

;; no-littering
(straight-use-package 'no-littering)
(require 'no-littering)

#+end_src

**** Patching
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-el-patch.el
:END:

#+begin_src emacs-lisp

;; el-patch
(straight-use-package 'el-patch)
(require 'el-patch)

#+end_src


** UI
*** Buffer
**** olivetti
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-olivetti.el
:END:

#+begin_src emacs-lisp

;; centering
(straight-use-package 'olivetti)

(add-hook 'olivetti-mode-on-hook (lambda () (olivetti-set-width 0.9)))

;; normal modes
(dolist (mode '(org-mode-hook
		    magit-mode-hook
		    shell-mode-hook
		    markdown-mode-hook))
  (add-hook mode 'olivetti-mode))

;; Programming modes
(add-hook 'prog-mode-hook 'olivetti-mode)

#+end_src

*** Mode line
**** delight
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-delight.el
:END:

#+begin_src emacs-lisp

;; Customize names displayed in mode line
(straight-use-package 'delight)
(require 'delight)

;; Remove default modes from mode line
(delight '((global-command-log-mode nil "")
	      (olivetti-mode           nil "")
	      (which-key-mode          nil "")
	      (visual-line-mode        nil "simple")
	      (buffer-face-mode        nil "simple")
	      (org-indent-mode         nil "org")
	      (eldoc-mode              nil "eldoc")
	      ;; Major modes
	      (emacs-lisp-mode "EL" :major)))

#+end_src

*** Typefaces
**** all-the-icons
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-all-the-icons.el
:END:

#+begin_src emacs-lisp

;; Symbol library
(straight-use-package 'all-the-icons)

#+end_src

Now that ~all-the-icons~ is installed, all the icon typefaces must be actually present in
the local machine:

#+begin_src emacs-lisp :tangle no

(all-the-icons-install-fonts)

#+end_src

*** Highlights
**** svg-tag-mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-svg-tag-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'svg-tag-mode)

(defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
(defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
(defconst day-re "[A-Za-z]\\{3\\}")
(defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

(defun svg-progress-percent (value)
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ (string-to-number value) 100.0)
                                nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag (concat value "%")
                           nil :stroke 0 :margin 0)) :ascent 'center))

(defun svg-progress-count (value)
  (let* ((seq (mapcar #'string-to-number (split-string value "/")))
         (count (float (car seq)))
         (total (float (cadr seq))))
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ count total) nil
                                    :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag value nil
                           :stroke 0 :margin 0)) :ascent 'center)))

(setq svg-tag-tags
      `(
        ;; Org tags
        (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
        (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
        
        ;; Task priority
        ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))

        ;; Progress
        ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag)
                                            (svg-progress-percent (substring tag 1 -2)))))
        ("\\(\\[[0-9]+/[0-9]+\\]\\)" . ((lambda (tag)
                                          (svg-progress-count (substring tag 1 -1)))))
        
        ;; TODO / DONE
        ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo :inverse t :margin 0))))
        ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))


        ;; Citation of the form [cite:@Knuth:1984]
        ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                          (svg-tag-make tag
                                                        :inverse t
                                                        :beg 7 :end -1
                                                        :crop-right t))))
        ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                                (svg-tag-make tag
                                                              :end -1
                                                              :crop-left t))))
        
        ;; Active date (with or without day name, with or without time)
        (,(format "\\(<%s>\\)" date-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :end -1 :margin 0))))
        (,(format "\\(<%s \\)%s>" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
        (,(format "<%s \\(%s>\\)" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

        ;; Inactive date  (with or without day name, with or without time)
         (,(format "\\(\\[%s\\]\\)" date-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
         (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-date))))
         (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-date))))))

#+end_src

**** rainbow-mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-rainbow-mode.el
:END:

#+begin_src emacs-lisp

;; highlight HTML color strings in their own color
(straight-use-package 'rainbow-mode)

#+end_src

** Input
*** Editing
**** evil
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-evil.el
:END:

#+begin_src emacs-lisp

;; evil
(straight-use-package 'evil)
(require 'evil)

(evil-mode 1)

#+end_src

***** states
****** evil-god

#+begin_src emacs-lisp

;; evil god state
(straight-use-package 'evil-god-state)
(require 'evil-god-state)

(evil-define-key 'normal global-map (kbd ",") 'evil-execute-in-god-state)

(evil-define-key 'god    global-map (kbd "<escape>") 'evil-god-state-bail)

;; mode indicators
(setq evil-normal-state-tag   (propertize " COMMAND " 'face '((:background "dark khaki"     :foreground "black")))
      evil-emacs-state-tag    (propertize "  EMACS  " 'face '((:background "turquoise"      :foreground "black")))
      evil-insert-state-tag   (propertize " ------- " 'face '((:background "dark sea green" :foreground "black")))
      evil-replace-state-tag  (propertize " REPLACE " 'face '((:background "dark orange"    :foreground "black")))
      evil-motion-state-tag   (propertize "  MOTION " 'face '((:background "khaki"          :foreground "black")))
      evil-visual-state-tag   (propertize "  VISUAL " 'face '((:background "light salmon"   :foreground "black")))
      evil-operator-state-tag (propertize " OPERATE " 'face '((:background "sandy brown"    :foreground "black"))))

(setq evil-default-cursor (quote (t "#750000"))
      evil-visual-state-cursor '("green" hollow)
      evil-normal-state-cursor '("green" box)
      evil-insert-state-cursor '("pink" (bar . 2))

#+end_src

****** evil-org

- https://github.com/Somelauw/evil-org-mode 

**** meow
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-meow.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'meow)
(require 'meow)

#+end_src

***** setup

#+begin_src emacs-lisp

(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)))

#+end_src

***** load

#+begin_src emacs-lisp

(meow-setup)
(meow-global-mode 1)

#+end_src

*** Commands
**** god-mode
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-god-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'god-mode)
(require 'god-mode)

;; god
(global-set-key (kbd "<escape>") #'god-mode-all)

;; local
(define-key god-local-mode-map (kbd "i") #'god-local-mode)

;; bindings
(define-key god-local-mode-map (kbd ".") #'repeat)
(define-key god-local-mode-map (kbd "]") #'forward-paragraph)
(define-key god-local-mode-map (kbd "[") #'backward-paragraph)

#+end_src

** Themes
*** Themes
**** Nano
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-nano-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'nano-theme)
(require 'nano-theme)

#+end_src

**** Doom
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-doom-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'doom-themes)
(require 'doom-themes)

#+end_src

**** Modus
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-modus-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'modus-themes)
(modus-themes-load-themes)

#+end_src

Commit 64c8009 of July the 8th 2022 dresses Org Mode titles with a ghastly cyan
in ~modus-operandi~, and a strident turquoise in ~modus-vivendi~. This can be undone
by passing the ~monochrome~ attribute to 0th level heading in ~modus-themes-headings~.

#+begin_src emacs-lisp

(setq modus-themes-headings
      '((0 . (monochrome))))

#+end_src

**** Standalone
***** Sweet
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-sweet-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'sweet-theme)
(require 'sweet-theme)

#+end_src

***** Graphite
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-graphite-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(graphite-theme :type git :host github :repo "codemicmaves/graphite-theme"))
(require 'graphite-light-theme)
(require 'graphite-dark-theme)

#+end_src

***** Chocolate
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-chocolate-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'chocolate-theme)
(require 'chocolate-theme)

#+end_src

*** Scheduling
**** circadian
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-circadian.el
:END:

#+begin_src emacs-lisp

(setq calendar-latitude      52.00667)
(setq calendar-longitude     4.355561)
(setq calendar-loadtion-name "Delft")
(setq calendar-standard-time-zone-name "CEST")
(setq calendar-daylight-time-zone-name "CET")

(straight-use-package 'circadian)
(setq circadian-themes `((:sunrise . ,light)  
			      (:sunset  . ,dark)))
(circadian-setup)

#+end_src

** Mode line
*** Nano
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-nano-modeline.el
:END:

#+begin_src emacs-lisp

;; nano-modeline
(straight-use-package 'nano-modeline)

#+end_src

*** Doom
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-doom-modeline.el
:END:

#+begin_src emacs-lisp

;; doom-modeline
(straight-use-package 'doom-modeline)

;; bar
(setq-default doom-modeline-bar-width 0.01)

#+end_src

*** Spaceline
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-spaceline.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'spaceline)
(require 'spaceline-config)

#+end_src


** Editing
*** Undo
**** TODO vundo
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-vundo.el
:END:

- undo-fu
- Back
   - Record character number in current line relative to the end of the line
   - If impossible to go to previous position, to recorded character number of previous line
   - Org Mode
      - restore visibility before undone command
      - if previous command created heading
         - undo heading creation and restore visibility

#+begin_src emacs-lisp

;; vundo
(straight-use-package 'vundo)

(global-set-key (kbd "C-v") #'vundo)

#+end_src

**** undo-tree                                                        :arch:
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-undo-tree.el
:END:

#+begin_src emacs-lisp

;; undo-tree
(use-package undo-tree
  :bind (("M-/" . undo-tree-visualize)
         :map undo-tree-visualizer-mode-map
         ("RET" . undo-tree-visualizer-quit)
         ("ESC" . undo-tree-visualizer-quit))
  :config
  (global-undo-tree-mode))

#+end_src

***** Visualize in side buffer

#+begin_src emacs-lisp

;; visualize in side buffer
(defun custom/undo-tree-split-side-by-side (orig-fun &rest args)
  "Split undo-tree side-by-side"
  (let ((split-height-threshold nil)
        (split-width-threshold 0))
    (apply orig-fun args)))

(advice-add 'undo-tree-visualize :around #'custom/undo-tree-split-side-by-side)

#+end_src

*** Multiline
**** multiple-cursors
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-multiple-cursors.el
:END:

#+begin_src emacs-lisp

;; Multiple cursors
(straight-use-package 'multiple-cursors)
(require 'multiple-cursors)

;; mc-lists
(setq mc/list-file (concat config-directory "persistent/mc-lists.el"))

;; Create cursors
(global-set-key (kbd "C-.")         #'mc/mark-next-like-this)
(global-set-key (kbd "C-;")         #'mc/mark-previous-like-this)
(global-set-key (kbd "C-<mouse-1>") #'mc/add-cursor-on-click)
(global-unset-key [C-down-mouse-1]) ; necessary

;; Return as usual
(define-key mc/keymap (kbd "<return>")       #'electric-newline-and-maybe-indent)

;; Exit multiple-cursors-mode
(define-key mc/keymap (kbd "<escape>")       #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<mouse-1>")      #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<down-mouse-1>")   nil) ; necessary

#+end_src
** Search
*** swiper
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-swiper.el
:END:

#+begin_src emacs-lisp

;; Swiper
(straight-use-package 'swiper)
(require 'swiper)

#+end_src

**** isearch

#+begin_src emacs-lisp

(defun custom/swiper-isearch (orig-fun &rest args)
  "`swiper-isearch' the selected region. If none are, `swiper-isearch'."
  (if (region-active-p)
      (let ((beg (region-beginning))
	    (end (region-end)))
	(deactivate-mark)
	(apply orig-fun (list (buffer-substring-no-properties beg end))))
    (apply orig-fun args)))

(advice-add 'swiper-isearch :around #'custom/swiper-isearch)

(define-key global-map (kbd "C-s") #'swiper-isearch)

#+end_src

**** TODO Narrow search

- C-r in swiper -> quit, widen

#+begin_src emacs-lisp

(defun custom/narrow-and-search (beg end)
  "Narrow to region and trigger swiper search."
  (narrow-to-region beg end)
  (deactivate-mark)
  (swiper-isearch))

(defun custom/search-in-region (beg end)
  "Narrow and search active region. If the current
buffer is already narrowed, widen buffer."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (if (not (buffer-narrowed-p))
      (if (and beg end)
	  (progn (custom/narrow-and-search beg end)))
    (progn (widen)
	   (if (bound-and-true-p multiple-cursors-mode)
	       (mc/disable-multiple-cursors-mode)))))

(defun custom/swiper-exit-narrow-search ()
  (interactive)
  (minibuffer-keyboard-quit)
  (if (buffer-narrowed-p)
      (widen)))

;; Narrow search
(define-key global-map (kbd "C-r") #'custom/search-in-region)

;; Exit narrow search from swiper
(define-key swiper-map (kbd "C-e") #'custom/swiper-exit-narrow-search)

#+end_src

**** Multiple cursors

#+begin_src emacs-lisp

(defun custom/swiper-multiple-cursors ()
  (interactive)
  (swiper-mc)
  (minibuffer-keyboard-quit))

;; M-RET: multiple-cursors-mode
(define-key swiper-map (kbd "M-<return>") #'custom/swiper-multiple-cursors)

#+end_src

*** ripgrep
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-rg.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'rg)
(require 'rg)

#+end_src
** Templates
*** yasnippet
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-yasnippet.el
:END:

#+begin_src emacs-lisp

;; yasnippet
(straight-use-package 'yasnippet)

(yas-global-mode 1)

#+end_src

**** <

#+begin_src emacs-lisp

(defun custom/<-snippet (orig-fun &rest args)
  "Require < before snippets."
  (interactive)
  (setq line (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
	(if (not (string-equal line ""))
	    (if (string-equal (substring line 0 1) "<")
		(progn (save-excursion (move-beginning-of-line nil)
				       (right-char 1)
				       (delete-region (line-beginning-position) (point)))
		       (apply orig-fun args)))))

(advice-add 'yas-expand :around #'custom/<-snippet)

#+end_src

**** Snippets

#+begin_src emacs-lisp

;; yasnippet-snippets
(straight-use-package 'yasnippet-snippets)

#+end_src

** Completion
*** ivy
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-ivy.el
:END:

#+begin_src emacs-lisp

;; ivy
(straight-use-package 'ivy)
(require 'ivy)

(ivy-mode 1)

;; minibuffer bindings
(let ((map ivy-minibuffer-map))
  (cl-loop for binding in '(("<tab>"       . ivy-alt-done)
			        ("<up>"        . ivy-previous-line-or-history)
			        ("C-l"         . ivy-alt-done)
			        ("C-j"         . ivy-next-line)
			        ("C-k"         . ivy-previous-line)
			        ("<backspace>" . ivy-backward-delete-char))
            collect (define-key map (kbd (car binding)) (cdr binding))))

;; switch-buffer bindings
(let ((map ivy-switch-buffer-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
 			        ("C-l"   . ivy-done)
			        ("C-d"   . ivy-switch-buffer-kill))
            collect (define-key map (kbd (car binding)) (cdr binding))))

;; reverse-i-search bindings
(let ((map ivy-reverse-i-search-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
			        ("C-d"   . ivy-reverse-i-search-kill))
            collect (define-key map (kbd (car binding)) (cdr binding))))

#+end_src

*** ivy-rich                                                          :arch:
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-ivy-rich.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'ivy-rich)
(require 'ivy-rich)

(ivy-rich-mode 1)

#+end_src


** Workflow
*** Session
**** desktop
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-desktop.el
:END:

#+begin_src emacs-lisp

(desktop-save-mode 1)

#+end_src

**** TODO workgroups
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-workgroups.el
:END:

- workgroups
  - relative paths wrt project root (for files in same projectile project ?)

#+begin_src emacs-lisp

(straight-use-package 'workgroups)
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))

;; save commands
(define-key wg-map (kbd "s")   #'wg-save)
(define-key wg-map (kbd "C-s") #'wg-update-all-workgroups-and-save)

;; suppress animation
(setq wg-morph-on nil)

(workgroups-mode 1)

#+end_src

*** Project interaction
**** TODO projectile
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-projectile.el
:END:

- project dashboard
   - flow
      1. tabulated-list-mode
          - display known projects
      2. Either
          - Choose project
             1. workgroups.el
                 1. If no .workspace, create .workspace
                 2. Load .workspace
          - Create new project
             1. Template
             2. workgroups.el
                 1. New .workspace file
                 2. Load .workspace
   - references
      - Issue
         - https://github.com/bbatsov/projectile/issues/967
      - SpaceMacs
         - https://github.com/syl20bnr/spacemacs/blob/master/core/core-spacemacs-buffer.el#L550

#+begin_src emacs-lisp

;; projectile
(straight-use-package 'projectile)
(require 'projectile)

(projectile-mode)

;; command map prefix
(define-key projectile-mode-map (kbd "M-p") 'projectile-command-map)

#+end_src

**** treemacs
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-treemacs.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'treemacs)
(require 'treemacs)

#+end_src

***** Filter

#+begin_src emacs-lisp

(defvar custom/treemacs-ignored '(".*__pycache__.*")
  "Files and directories ignored by treemacs")

(defun custom/treemacs-ignore-filter (file _)
  (cl-loop for ignored in custom/treemacs-ignored
	   if (string-match ignored file)
	      return t
	   finally return nil))
(push #'custom/treemacs-ignore-filter treemacs-ignored-file-predicates)

#+end_src

***** Bindings

#+begin_src emacs-lisp

(cl-loop for binding in '(("M-0"       . treemacs-select-window)
			      ("C-x t 1"   . treemacs-delete-other-windows)
			      ("C-x t t"   . treemacs)
			      ("C-x t d"   . treemacs-select-directory)
			      ("C-x t B"   . treemacs-bookmark)
			      ("C-x t C-t" . treemacs-find-file)
			      ("C-x t M-t" . treemacs-find-tag))
	 collect (global-set-key (kbd (car binding)) (cdr binding)))

#+end_src

***** Settings

#+begin_src emacs-lisp

(setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
      treemacs-deferred-git-apply-delay        0.5
      treemacs-directory-name-transformer      #'identity
      treemacs-display-in-side-window          t
      treemacs-eldoc-display                   'simple
      treemacs-file-event-delay                5000
      treemacs-file-extension-regex            treemacs-last-period-regex-value
      treemacs-file-follow-delay               0.2
      treemacs-file-name-transformer           #'identity
      treemacs-follow-after-init               t
      treemacs-expand-after-init               t
      treemacs-find-workspace-method           'find-for-file-or-pick-first
      treemacs-git-command-pipe                ""
      treemacs-goto-tag-strategy               'refetch-index
      treemacs-indentation                     2
      treemacs-indentation-string              " "
      treemacs-is-never-other-window           nil
      treemacs-max-git-entries                 5000
      treemacs-missing-project-action          'ask
      treemacs-move-forward-on-expand          nil
      treemacs-no-png-images                   nil
      treemacs-no-delete-other-windows         t
      treemacs-project-follow-cleanup          nil
      treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
      treemacs-position                        'left
      treemacs-read-string-input               'from-child-frame
      treemacs-recenter-distance               0.1
      treemacs-recenter-after-file-follow      nil
      treemacs-recenter-after-tag-follow       nil
      treemacs-recenter-after-project-jump     'always
      treemacs-recenter-after-project-expand   'on-distance
      treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
      treemacs-show-cursor                     nil
      treemacs-show-hidden-files               t
      treemacs-silent-filewatch                nil
      treemacs-silent-refresh                  nil
      treemacs-sorting                         'alphabetic-asc
      treemacs-select-when-already-in-treemacs 'move-back
      treemacs-space-between-root-nodes        t
      treemacs-tag-follow-cleanup              t
      treemacs-tag-follow-delay                1.5
      treemacs-text-scale                      nil
      treemacs-user-mode-line-format           nil
      treemacs-user-header-line-format         nil
      treemacs-wide-toggle-width               70
      treemacs-width                           35
      treemacs-width-increment                 1
      treemacs-width-is-initially-locked       t
      treemacs-workspace-switch-cleanup        nil)

;; The default width and height of the icons is 22 pixels. If you are
;; using a Hi-DPI display, uncomment this to double the icon size.
;; (treemacs-resize-icons 44)

(treemacs-follow-mode t)
(treemacs-filewatch-mode t)
(treemacs-fringe-indicator-mode 'always)

(pcase (cons (not (null (executable-find "git")))
             (not (null treemacs-python-executable)))
  (`(t . t)
   (treemacs-git-mode 'deferred))
  (`(t . _)
   (treemacs-git-mode 'simple)))

(treemacs-hide-gitignored-files-mode nil)

#+end_src

***** Extensions

#+begin_src emacs-lisp

(straight-use-package 'treemacs-icons-dired)

(straight-use-package 'treemacs-projectile)

(straight-use-package 'treemacs-tab-bar)

(straight-use-package 'treemacs-magit)

#+end_src

** Guidance
*** counsel
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-counsel.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'counsel)
(require 'counsel)

(global-set-key (kbd "<menu>") #'counsel-M-x)

#+end_src

*** helpful
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-helpful.el
:END:

#+begin_src emacs-lisp

;; replace description key bindings by their helpful equivalents
(straight-use-package 'helpful)

(setq counsel-describe-function-function  #'helpful-callable)
(setq counsel-describe-variable-function  #'helpful-variable)

(global-set-key [remap describe-function] #'helpful-function)
(global-set-key [remap describe-command]  #'helpful-command)
(global-set-key [remap describe-variable] #'helpful-variable)
(global-set-key [remap describe-key]      #'helpful-key)

#+end_src

*** which-key
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-which-key.el
:END:

#+begin_src emacs-lisp

;; command suggestions
(straight-use-package 'which-key)
(require 'which-key)

(setq which-key-idle-delay 1.0)

(which-key-mode)

#+end_src

*** command-log-mode                                                  :arch:
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-command-log-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'command-log-mode)
(require 'command-log-mode)

(global-command-log-mode)

#+end_src

** Navigation
*** winner
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-winner.el
:END:

#+begin_src emacs-lisp

(winner-mode)

#+end_src

*** ace-window
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-ace-window.el
:END:

#+begin_src emacs-lisp

;; ace-window
(straight-use-package 'ace-window)
(require 'ace-window)

(global-set-key (kbd "C-x o") 'ace-window)

#+end_src

*** TODO pixel-scroll-precision
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-pixel-scroll-precision.el
:END:

- pixel-scroll-precision-mode
   - sudden jumps

- scrolling without moving mark

- sources
   - https://www.reddit.com/r/emacs/comments/6osik2/random_scroll_jumps_in_emacs/
   - https://www.emacswiki.org/emacs/SmoothScrolling

#+begin_src emacs-lisp

(setq scroll-step 1)
(setq scroll-conservatively 101)
(setq scroll-preserve-screen-position 1)

#+end_src


** Version control
*** magit
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-magit.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'magit)
(require 'magit)

(global-set-key (kbd "C-x g") #'magit-status)

#+end_src

** File management
*** dirvish
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-dirvish.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'dirvish)
(require 'dirvish)

;; override dired
(dirvish-override-dired-mode)

#+end_src


** IDE
*** General
**** hideshow
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-hideshow.el
:END:

#+begin_src emacs-lisp

(require 'hideshow)

(add-hook 'prog-mode-hook #'hs-minor-mode)

#+end_src

***** TODO Cycle

- fold back in 1 when no children

#+begin_src emacs-lisp

(defun custom/hs-cycle (&optional level)
  (interactive "p")
  (save-excursion
    (let (message-log-max (inhibit-message t))
      (if (= level 1)
	  (pcase last-command
	    ('hs-cycle
	     (hs-hide-level 1)
	   (setq this-command 'hs-cycle-children))
	    ('hs-cycle-children
	     ;; TODO: Fix this case. `hs-show-block' needs to be
	     ;; called twice to open all folds of the parent
	     ;; block.
	     (save-excursion (hs-show-block))
	     (hs-show-block)
	     (setq this-command 'hs-cycle-subtree))
	    ('hs-cycle-subtree
	     (hs-hide-block))
	    (_
	     (if (not (hs-already-hidden-p))
		 (hs-hide-block)
	       (hs-hide-level 1)
	       (setq this-command 'hs-cycle-children))))
	(hs-hide-level level)
	(setq this-command 'hs-hide-level)))))

(defun custom/hs-global-cycle ()
  (interactive)
  (pcase last-command
    ('hs-global-cycle
     (save-excursion (hs-show-all))
     (setq this-command 'hs-global-show))
    (_ (hs-hide-all))))

(define-key hs-minor-mode-map (kbd "C-\\") #'custom/hs-cycle)

#+end_src

**** company
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-company.el
:END:

#+begin_src emacs-lisp

;; company
(straight-use-package 'company)
(require 'company)

#+end_src

**** flycheck
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-flycheck.el
:END:

#+begin_src emacs-lisp

;; flycheck
(straight-use-package 'flycheck)
(require 'flycheck)

(add-hook 'prog-mode-hook #'flycheck-mode)

#+end_src

*** Specific
**** Lisp
***** Syntax highlighting
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-rainbow-delimiters.el
:END:

#+begin_src emacs-lisp

;; rainbow-delimieters
(straight-use-package 'rainbow-delimiters)
(require 'rainbow-delimiters)

;; enable rainbow delimiters on all programming modes
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

#+end_src

**** Python
***** elpy
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-elpy.el
:END:

#+begin_src bash :tangle no

sudo apt-get install python3-venv

#+end_src

#+begin_src emacs-lisp

;; elpy
(straight-use-package 'elpy)
(elpy-enable)

#+end_src

****** RPC

#+begin_src emacs-lisp

(setq elpy-rpc-timeout 5)

(setq elpy-rpc-backend "jedi")

(setq elpy-rpc-python-command "python3")

#+end_src

****** Navigation

#+begin_src emacs-lisp

(define-key elpy-mode-map (kbd "C-M-n") 'elpy-nav-forward-block)
(define-key elpy-mode-map (kbd "C-M-p") 'elpy-nav-backward-block)

#+end_src

** Org Mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org.el
:END:

#+begin_src emacs-lisp

;; Org Mode
(straight-use-package 'org)
(require 'org)

#+end_src

*** Patches
**** org-self-insert-command

#+begin_src emacs-lisp

(el-patch-feature org)
(el-patch-defun org-self-insert-command (N)
  "Like `self-insert-command', use overwrite-mode for whitespace in tables.
If the cursor is in a table looking at whitespace, the whitespace is
overwritten, and the table is not marked as requiring realignment."
  (interactive "p")
  (el-patch-remove (org-fold-check-before-invisible-edit 'insert))
  (cond
   ((and org-use-speed-commands
	 (let ((kv (this-command-keys-vector)))
	   (setq org-speed-command
		 (run-hook-with-args-until-success
		  'org-speed-command-hook
		  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp org-speed-command)
      (setq this-command org-speed-command)
      (call-interactively org-speed-command))
     ((functionp org-speed-command)
      (funcall org-speed-command))
     ((consp org-speed-command)
      (eval org-speed-command t))
     (t (let (org-use-speed-commands)
	  (call-interactively 'org-self-insert-command)))))
   ((and
     (= N 1)
     (not (org-region-active-p))
     (org-at-table-p)
     (progn
       ;; Check if we blank the field, and if that triggers align.
       (and (featurep 'org-table)
	    org-table-auto-blank-field
	    (memq last-command
		  '(org-cycle org-return org-shifttab org-ctrl-c-ctrl-c))
	    (if (or (eq (char-after) ?\s) (looking-at "[^|\n]*  |"))
		;; Got extra space, this field does not determine
		;; column width.
		(let (org-table-may-need-update) (org-table-blank-field))
	      ;; No extra space, this field may determine column
	      ;; width.
	      (org-table-blank-field)))
       t)
     (looking-at "[^|\n]*  |"))
    ;; There is room for insertion without re-aligning the table.
    (self-insert-command N)
    (org-table-with-shrunk-field
     (save-excursion
       (skip-chars-forward "^|")
       ;; Do not delete last space, which is
       ;; `org-table-separator-space', but the regular space before
       ;; it.
       (delete-region (- (point) 2) (1- (point))))))
   (t
    (setq org-table-may-need-update t)
    (self-insert-command N)
    (org-fix-tags-on-the-fly)
    (when org-self-insert-cluster-for-undo
      (if (not (eq last-command 'org-self-insert-command))
	  (setq org-self-insert-command-undo-counter 1)
	(if (>= org-self-insert-command-undo-counter 20)
	    (setq org-self-insert-command-undo-counter 1)
	  (and (> org-self-insert-command-undo-counter 0)
	       buffer-undo-list (listp buffer-undo-list)
	       (not (cadr buffer-undo-list)) ; remove nil entry
	       (setcdr buffer-undo-list (cddr buffer-undo-list)))
	  (setq org-self-insert-command-undo-counter
		(1+ org-self-insert-command-undo-counter))))))))

#+end_src

**** TODO org-indent--compute-prefixes

- el-patch

#+begin_src emacs-lisp

(defun custom/org-indent--compute-prefixes ()
  "Recompute line prefixes for regular text to
match the indentation of the parent heading."
  (dotimes (n org-indent--deepest-level)
      (let ((indentation (if (= n 0) 0 1)))
        (aset org-indent--text-line-prefixes
	        n
	        (org-add-props
	           (concat (make-string (+ n indentation) ?\s))
		    nil 'face 'org-indent)))))

(advice-add 'org-indent--compute-prefixes :after #'custom/org-indent--compute-prefixes)

                  #+end_src

*** UI
**** org-modern
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-modern.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-modern)

(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

#+end_src

***** Lists
****** Markers

#+begin_src emacs-lisp

(setq org-modern-list '((?+ . "-")
 		  	     (?- . "•")
 			     (?* . "▶")))

#+end_src

****** Checkboxes

#+begin_src emacs-lisp

(setq org-modern-checkbox nil)

#+end_src

***** Tables

#+begin_src emacs-lisp

;; Vertical table line width
(setq org-modern-table-vertical 1)

;; Horizontal table line width
(setq org-modern-table-horizontal 1)

#+end_src

***** Highlights

#+begin_src emacs-lisp

;; Tags
(setq org-modern-tag nil)

;; Priorities
(setq org-modern-priority nil)

#+end_src

**** org-appear
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-appear.el
:END:

#+begin_src emacs-lisp

(setq org-hide-emphasis-markers t)

(setq org-hidden-keywords '(title))

;; org-appear
(straight-use-package '(org-appear :type git :host github :repo "awth13/org-appear"))
(add-hook 'org-mode-hook #'org-appear-mode)

;; links
(setq org-appear-autolinks t)

;; keywords
(setq org-appear-autokeywords t)

;; symbols
(setq org-appear-autoentities t)

;; subscripts and superscripts
(setq org-appear-autosubmarkers t)
(setq org-appear-inside-latex t)

#+end_src

**** org-fragtog
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-fragtog.el
:END:

#+begin_src emacs-lisp

;; org-fragtog
(straight-use-package 'org-fragtog)
(require 'org-fragtog)

(add-hook 'org-mode-hook #'org-fragtog-mode)

#+end_src

*** Editing
**** org-paragraph
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-paragraph.el
:END:

#+begin_src emacs-lisp

(require 'org-paragraph (concat config-directory "packages/org-paragraph.el"))

#+end_src

***** org-meta-arrows-h

#+begin_src emacs-lisp

(defun custom/org-meta-arrows-h (orig-fun &rest args)
  "Paragraph indentation with `org-meta<arrows>'.
Furthermore, if a region is active and its
beginning lies on an Org Mode heading,
`custom/org-command-expand-region' to execute ORIG-FUN."
  (interactive)
  (cond ((custom/org-relative-line-paragraph) (custom/org-paragraph orig-fun args))
	    ((region-active-p)                    (custom/org-indent-region orig-fun args))
	    (t                                    (apply orig-fun args))))

(advice-add 'org-metaleft  :around #'custom/org-meta-arrows-h)
(advice-add 'org-metaright :around #'custom/org-meta-arrows-h)

#+end_src

***** TODO org-meta-arrows-v

- paragraphs
- visibility change when heading visibility is CHILDREN
   - save previous visibility
      - custom/org-subtree-state
         - overlay = overlays-in subtree-beg subtree-end
         - overlay-properties?
   - org-meta-v
   - if post visibility is not equal to previous
      - cycle back to previous visibility
   - rough
      - visibility change -> assume prev was CHILDREN -> 2 x org-cycle-internal-local

#+begin_src emacs-lisp

(defun custom/org-meta-arrows-v (orig-fun &rest args)
  (interactive)
  (if (custom/org-at-ellipsis)
      (progn (beginning-of-visual-line) (end-of-line)))
  (apply orig-fun args)
  (if (custom/org-relative-line-heading-folded)
      (outline-hide-subtree)))

(advice-add 'org-metaup   :around #'custom/org-meta-arrows-v)
(advice-add 'org-metadown :around #'custom/org-meta-arrows-v)

#+end_src

**** org-download
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-download.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-download)

(dolist (mode '(org-mode-hook
		     dired-mode-hook))
  (add-hook mode 'org-download-enable))

;; download directory
(setq-default org-download-image-dir "./figures")

;; customize #+DOWNLOADED attribute
(defun custom/org-download-annotate (link)
  "Create a captioned and labeled figure."
  (concat "#+CAPTION:\n"
          "#+NAME: fig:\n"))
(setq org-download-annotate-function #'custom/org-download-annotate)

#+end_src

*** Notes
**** org-diary
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-diary.el
:END:

#+begin_src emacs-lisp

(require 'org-diary (concat config-directory "packages/org-diary.el"))

#+end_src

**** org-roam
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-roam.el
:END:

Importantly, [[https://org-roam.discourse.group/t/no-emacsql-sqlite-binary-available-aborting-error-when-installing-org-roam-v2-on-mac/2178/6][a C compiler (eg: gcc or clang) must be installed for ~emacsql-sqlite~ to install correctly]].

#+begin_src emacs-lisp

;; org-roam
(straight-use-package 'org-roam)

#+end_src

***** UI

#+begin_src emacs-lisp

;; Org Roam UI
(straight-use-package 'org-roam-ui)

#+end_src

******* Follow

#+begin_src emacs-lisp

(setq org-roam-ui-follow t)

#+end_src

******* Theme

#+begin_src emacs-lisp

;; Sync theme and UI
(setq org-roam-ui-sync-theme nil)

#+end_src

******* Startup

#+begin_src emacs-lisp

(setq org-roam-ui-open-on-start nil)

#+end_src

******* Update

#+begin_src emacs-lisp

(setq org-roam-ui-update-on-save t)

#+end_src

***** Hooks

#+begin_src emacs-lisp

;; Node visit hook
(defvar custom/org-roam-node-visit-hook nil
   "Hook ran after `org-roam-node-visit'.")

(defun custom/run-org-roam-node-visit-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'custom/org-roam-node-visit-hook))

;; enable-theme
(advice-add 'org-roam-node-visit :after #'custom/run-org-roam-node-visit-hook)

#+end_src

***** Startup
****** db-autosync-mode

#+begin_src emacs-lisp

(if (and (boundp 'org-roam-directory) (file-directory-p org-roam-directory))
    (org-roam-db-autosync-mode))

#+end_src

****** variable-pitch-mode

#+begin_src emacs-lisp

(add-hook 'org-roam-find-file-hook #'variable-pitch-mode)

#+end_src

***** Bindings

#+begin_src emacs-lisp

;; Find node
(global-set-key (kbd "C-c n") 'org-roam-node-find)

;; Insert reference
(global-set-key (kbd "C-c i") 'org-roam-node-insert)

#+end_src

***** Templates
****** Default

#+begin_src emacs-lisp

(setq org-roam-capture-templates
      '(("d" "default" plain "%?"
	    :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
			       "#+STARTUP: subtree\n\n\n\n#+title:${title}\n\n\n")
	    :unnarrowed t)))

#+end_src

***** Timestamps

#+begin_src emacs-lisp

;; org-roam-timestamps
(straight-use-package 'org-roam-timestamps)
(require 'org-roam-timestamps)

;; remember
(setq org-roam-timestamps-remember-timestamps nil)
(setq org-roam-timestamps-minimum-gap 3600)

;; visit hook
(add-hook 'custom/org-roam-node-visit-hook #'org-roam-timestamps-mode)

;; capture hook
(defvar custom/org-roam-timestamps-mode-active-before-capture nil)

(defun custom/org-roam-timestamps-mode-off ()
  "Disable `org-roam-timestamps-mode' in Org Roam capture buffers."
  (setq custom/org-roam-timestamps-mode-active-before-capture org-roam-timestamps-mode)
  (org-roam-timestamps-mode -1))
(add-hook 'org-roam-capture-new-node-hook #'custom/org-roam-timestamps-mode-off)

(defun custom/org-roam-timestamps-mode-back ()
  "Re-enable `org-roam-timestamps-mode' after finalizing capture,
if it was previously enabled."
  (if custom/org-roam-timestamps-mode-active-before-capture
      (org-roam-timestamps-mode)))
(add-hook 'org-capture-after-finalize-hook #'custom/org-roam-timestamps-mode-back)

#+end_src

*** Export
**** ox-rst
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-ox-rst.el
:END:

#+begin_src emacs-lisp

;; ox-rst
(straight-use-package 'ox-rst)
(require 'ox-rst)

#+end_src

*** Agenda
**** org-agenda
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-agenda.el
:END:

#+begin_src emacs-lisp

;; org-agenda
(global-set-key (kbd "C-c a") 'org-agenda)

#+end_src

***** TODO Files

- recursive search
   - (directory-files-recursively "/home/" "\\.org$")
   - https://stackoverflow.com/questions/11384516/how-to-make-all-org-files-under-a-folder-added-in-agenda-list-automatically

#+begin_src emacs-lisp

;; org-agenda-files
(setq org-agenda-files (append org-agenda-files
			       `(,config-directory)))

#+end_src

***** Display
****** Tag alignment

#+begin_src emacs-lisp

;; Tag indentation
(setq org-tags-column 70)

#+end_src

***** Agenda
****** Editing

#+begin_src emacs-lisp

;; Mark items as done
(defun custom/org-agenda-todo-done ()
  (interactive)
  (org-agenda-todo 'done))

(define-key org-agenda-mode-map (kbd "d") 'custom/org-agenda-todo-done)

#+end_src

****** Display
******* Views

#+begin_src emacs-lisp

;; Configure custom agenda views
(setq org-agenda-custom-commands
      '(("d" "Dashboard"
	      ((agenda "" ((org-deadline-warning-days 7)))
	       (todo "NEXT" ((org-agenda-overriding-header "Next Tasks")))
	       (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

	     ("n" "Next Tasks"
	      ((todo "NEXT" ((org-agenda-overriding-header "Next Tasks")))))

	     ("w" "Work Tasks" tags-todo "work")

	     ("e" "Emacs Tasks" tags-todo "emacs")

	     ("z" "Low Effort" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
	      ((org-agenda-overriding-header "Low Effort Tasks")
	       (org-agenda-max-todos 20)
	       (org-agenda-files org-agenda-files)))

	     ("s" "Workflow Status"
	      ((todo "WAIT"
		     ((org-agenda-overriding-header "Waiting on External")
		      (org-agenda-files org-agenda-files)))
	       (todo "REVIEW"
		     ((org-agenda-overriding-header "In Review")
		      (org-agenda-files org-agenda-files)))
	       (todo "PLAN"
		     ((org-agenda-overriding-header "In Planning")
		      (org-agenda-todo-list-sublevels nil)
		      (org-agenda-files org-agenda-files)))
	       (todo "BACKLOG"
		     ((org-agenda-overriding-header "Project Backlog")
		      (org-agenda-todo-list-sublevels nil)
		      (org-agenda-files org-agenda-files)))
	       (todo "READY"
		     ((org-agenda-overriding-header "Ready for Work")
		      (org-agenda-files org-agenda-files)))
	       (todo "ACTIVE"
		     ((org-agenda-overriding-header "Active Projects")
		      (org-agenda-files org-agenda-files)))
	       (todo "COMPLETED"
		     ((org-agenda-overriding-header "Completed Projects")
		      (org-agenda-files org-agenda-files)))
	       (todo "CANC"
		     ((org-agenda-overriding-header "Cancelled Projects")
		      (org-agenda-files org-agenda-files)))))))

#+end_src

******* log-mode
:LOGBOOK:
- State "DONE"       from "BACKLOG"    [2022-05-12 Thu 22:00]
- State "DONE"       from "NEXT"       [2022-05-12 Thu 21:59]
- State "DONE"       from "BACKLOG"    [2022-05-12 Thu 21:59]
- State "DONE"       from "NEXT"       [2022-05-12 Thu 21:59]
- State "HOLD"       from "WAIT"       [2022-05-12 Thu 21:59]
- State "DONE"       from "NEXT"       [2022-05-12 Thu 21:59]
:END:

#+begin_src emacs-lisp

;; Org Agenda log mode
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)

#+end_src

****** Navigation
******* TODO Visit

- org-recenter -> unfold -> move away -> fold back
   - arrows -> fold previous item
   - recenter -> unfold item
- currently- 
   - org-recenter -> all todo items unfolded

#+begin_src emacs-lisp :tangle no

(defun custom/org-agenda-recenter (arg)
  (interactive "P")
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (eq last-command this-command)
        (progn (custom/org-restore-outline-state)
	       (org-agenda-recenter arg))
      (progn (custom/org-save-outline-state)
	     (org-agenda-recenter arg))))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-agenda-mode-map (kbd "<tab>") 'org-agenda-recenter)

#+end_src

***** Classification
****** Tags

#+begin_src emacs-lisp

(setq org-tag-alist
      '((:startgroup)
	;; Put mutually exclusive tags here
	(:endgroup)
	("errand"   . ?e)
	("home"     . ?h)
	("work"     . ?w)
	("agenda"   . ?a)
	("planning" . ?p)
	("publish"  . ?P)
	("batch"    . ?b)
	("note"     . ?n)
	("idea"     . ?i)))

#+end_src

****** Keywords

#+begin_src emacs-lisp

;; Define TODO keyword sequences
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "WAIT(w@/!)" "|" "DONE(d!)")
	    (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(r)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

#+end_src

**** org-contacts
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-contacts.el
:END:

#+begin_src emacs-lisp

;; org-contacts
(straight-use-package
 '(org-contacts :type git :host nil :repo "https://repo.or.cz/org-contacts.git"))
(require 'org-contacts)

(global-set-key (kbd "C-x c") 'org-capture)

#+end_src

***** Template

#+begin_src emacs-lisp

(defvar custom/org-capture-contacts "* %(org-contacts-template-name)
:PROPERTIES:
:ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
:BIRTHDAY: %^{yyyy-mm-dd}
:EMAIL: %(org-contacts-template-email)
:NOTE: %^{NOTE}
:END:" "org-contacts template")

(setq org-capture-templates
   `(("c" "contact" entry
      (file ,(nth 0 org-contacts-files))
      ,custom/org-capture-contacts)))

#+end_src

**** org-calendar
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-calendar.el
:END:
***** calfw

#+begin_src emacs-lisp

(straight-use-package 'calfw)
(straight-use-package 'calfw-org)
(straight-use-package 'calfw-ical)

;; org-agenda configuration is lost otherwise
(with-eval-after-load 'org-agenda
  (require 'calfw-org)
  (require 'calfw-ical))

#+end_src

***** org-calendar

#+begin_src emacs-lisp

(defun custom/org-calendar ()
  "Open `calfw' Org Agenda calendar."
  (interactive)
  (require 'org-agenda)
  (let ((inhibit-message t))
       (cfw:open-org-calendar)))

(global-set-key (kbd "C-c c") 'custom/org-calendar)

#+end_src

*** Templates
**** org-tempo
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-tempo.el
:END:

#+begin_src emacs-lisp

;; required as of Org 9.2
(require 'org-tempo)

;; navigation
(global-set-key (kbd "C-<tab>")         'tempo-forward-mark)
(global-set-key (kbd "C-<iso-lefttab>") 'tempo-backward-mark)

#+end_src

***** LaTeX

#+begin_src emacs-lisp

;; equations
(tempo-define-template "latex-equation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    p n
			    "\\end{equation}" >)
			  "<eq"
			  "LaTeX equation template")

(tempo-define-template "latex-derivation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    "\\arraycolsep=3pt\\def\\arraystretch{2.25}" n
			    "\\begin{array}{lll}" n
			    p n
			    "\\end{array}" n
			    "\\end{equation}" >)
			  "<de"
			  "LaTeX derivation template")

#+end_src

***** Figures

#+begin_src emacs-lisp

;; figures
(tempo-define-template "figure"
		          '("#+NAME: fig:" p n
			    "#+CAPTION: " p n
			    "#+ATTR_ORG: :width 450" n
			    "[[./" p "]]" >)
			  "<f"
			  "Org Mode figure template")

#+end_src

***** Code blocks

#+begin_src emacs-lisp

(defun custom/tempo-code-block (key language)
  (tempo-define-template language
		         `("#+begin_src " ,language n
			   n
			   p n
			   n
			   "#+end_src" >)
			 key
			 language))

(dolist (pair '(("<sh"   "shell")
		   ("<el"   "emacs-lisp")
		   ("<py"   "python")
		   ("<bash" "bash")))
  (apply 'custom/tempo-code-block pair))

#+end_src

**** org-capture
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-capture.el
:END:

#+begin_src emacs-lisp

(require 'org-capture)

#+end_src

***** TODO Templates

- lecture
   - specify directory
   - template

*** Programming
**** org-babel
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./modules/shapes-org-babel.el
:END:
***** Languages

#+begin_src emacs-lisp

;; Language packages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python     . t)
   (shell      . t)))

#+end_src

****** Bash

#+begin_src emacs-lisp

(defun org-babel-bash-initiate-session (&optional session _params)
  "Initiate a bash/sh session named SESSION according to PARAMS."
  (org-babel-sh-initiate-session session _params))

#+end_src

****** Python

#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

***** Code block bleeding

#+begin_src emacs-lisp

(defun custom/org-fix-bleed-end-line-block (from to flag spec)
  "Toggle fontification of last char of block end lines when cycling.

This avoids the bleeding of `org-block-end-line' when block is
folded."
  (when (and (eq spec 'org-hide-block)
             (/= (point-max) to))
    (save-excursion
      (if flag
          (font-lock-unfontify-region to (1+ to))
        (font-lock-flush to (1+ to))))))

(advice-add 'org-flag-region :after #'custom/org-fix-bleed-end-line-block)

(defun custom/org-fix-bleed-end-line-cycle (state)
  "Toggle fontification of last char of block lines when cycling.

This avoids the bleeding of `org-block-end-line' when outline is
folded."
  (save-excursion
    (when org-fontify-whole-block-delimiter-line
      (let ((case-fold-search t)
            beg end)
        (cond ((memq state '(overview contents all))
               (setq beg (point-min)
                     end (point-max)))
              ((memq state '(children folded subtree))
               (setq beg (point)
                     end (org-end-of-subtree t t))))
        (when beg           ; should always be true, but haven't tested enough
          (goto-char beg)
          (while (search-forward "#+end" end t)
            (end-of-line)
            (unless (= (point) (point-max))
              (if (org-invisible-p (1- (point)))
                  (font-lock-unfontify-region (point) (1+ (point)))
                (font-lock-flush (point) (1+ (point)))))))))))

(add-hook 'org-cycle-hook #'custom/org-fix-bleed-end-line-cycle)

#+end_src
***** Code block execution

#+begin_src emacs-lisp

(global-set-key (kbd "C-x C-x") 'org-babel-execute-src-block)

#+end_src
***** Code block indentation

#+begin_src emacs-lisp

;; Set indentation of code blocks to 0
(setq org-edit-src-content-indentation 0)

;; Indent code blocks appropriately when inside headers
(setq org-src-preserve-indentation     nil)

;; Make code indentation reasonable
(setq org-src-tab-acts-natively        t)

#+end_src

***** Code block execution confirmation

#+begin_src emacs-lisp

;; Suppress security confirmation when evaluating code
(defun my-org-confirm-babel-evaluate (lang body)
  (not (member lang '("emacs-lisp" "python" "shell" "bash"))))

(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)

#+end_src


* Extensions
** General purpose
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-general.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Queries
**** regex-match-count

#+begin_src emacs-lisp

(defun custom/regex-match-count (regexp str)
  (loop with start = 0
        for count from 0
        while (string-match regexp str start)
        do (setq start (match-end 0))
        finally return count))

#+end_src

**** at
***** eolp

#+begin_src emacs-lisp

(defun custom/eolp (orig-fun &rest args)
  (interactive)
  (or (apply orig-fun args) (looking-at-p "[[:blank:]]*$")))

(advice-add 'eolp :around #'custom/eolp)

#+end_src

***** at-point

#+begin_src emacs-lisp

(defun custom/at-point (go-to-point &optional point)
  (let ((point (or point (point))))
    (save-excursion
      (funcall go-to-point)
      (= point (point)))))

#+end_src

***** at-indent

#+begin_src emacs-lisp

(defun custom/at-indent (&optional point)
  (and (custom/relative-line-indented) (custom/at-point 'back-to-indentation point)))

#+end_src

**** line
***** relative-line

#+begin_src emacs-lisp

(defun custom/relative-line (query &optional number &rest args)
  "Return the result of a boolean query at the beginning
of the current visual line, or another specified by its
relative position to the current line.
Optionally, `args' may be given as input to be passed
to the query at execution."
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-visual-line)
      (beginning-of-line-text (+ number 1))
      (apply query args))))

#+end_src

***** relative-line-regex

#+begin_src emacs-lisp

(defun custom/relative-line-regex (pattern &optional number)
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-line-text (+ number 1))
      (setq line (buffer-substring-no-properties (custom/get-point 'beginning-of-line) (custom/get-point 'end-of-line))))
    (string-match-p pattern line)))

#+end_src

***** relative-line-list

#+begin_src emacs-lisp

(defun custom/relative-line-list (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*\\([0-9]+[.\\)]\\{1\\}\\|[-+*]\\{1\\}\\)[[:blank:]]+.*$" number))

#+end_src

***** relative-line-empty

#+begin_src emacs-lisp

(defun custom/relative-line-empty (&optional number)
  (custom/relative-line-regex "^[[:space:]]*$" number))

#+end_src

***** TODO relative-line-wrapped

- &optional number

#+begin_src emacs-lisp

(defun custom/relative-line-wrapped ()
  (> (custom/get-point 'beginning-of-visual-line) (custom/get-point 'beginning-of-line-text)))

#+end_src

***** relative-line-indented

#+begin_src emacs-lisp

(defun custom/relative-line-indented (&optional number)
  (custom/relative-line-regex "^[[:blank:]]+.*$" number))

  #+end_src

***** relative-line-list-ordered

#+begin_src emacs-lisp

(defun custom/relative-line-list-ordered (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

***** relative-line-list-unordered

#+begin_src emacs-lisp

(defun custom/relative-line-list-unordered (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

**** region
***** region-blank

#+begin_src emacs-lisp

(defun custom/region-blank (&optional beg end)
  (let ((beg (or beg (region-beginning)))
	      (end (or end (region-end))))
    (setq region (buffer-substring-no-properties beg end))
    (string-match "\\`[[:space:]]*\\'$" region)))

#+end_src

***** region-multiline-visual

#+begin_src emacs-lisp

(defun custom/region-multiline-visual ()
  "Return t if a region is active and spans more than one visual line."
  (and (region-active-p) (> (custom/region-count-visual-lines) 1)))

#+end_src

***** region-count-visual-lines

#+begin_src emacs-lisp

(defun custom/region-count-visual-lines ()
  "Count visual lines in an active region."
  (interactive)
  (save-excursion 
    (beginning-of-visual-line)
    (count-screen-lines (region-beginning) (region-end))))

#+end_src

**** in-mode

#+begin_src emacs-lisp

(defun custom/in-mode (mode)
  "Return t if mode is currently active."
  (string-equal major-mode mode))

#+end_src

**** current-theme

#+begin_src emacs-lisp

;; Retrieve current theme
(defun custom/current-theme ()
  (substring (format "%s" (nth 0 custom-enabled-themes))))

#+end_src

**** current-window-number

#+begin_src emacs-lisp

(defun custom/current-window-number ()
  "Retrieve the current window's number."
  (setq window (prin1-to-string (get-buffer-window (current-buffer))))
  (string-match "^[^0-9]*\\([0-9]+\\).*$" window)
  (match-string 1 window))

#+end_src

**** find-buffer-by-file-name

#+begin_src emacs-lisp

(defun custom/find-buffer-by-file-name (file)
  (cl-loop for buffer in (buffer-list)
	        if (string-equal (buffer-name buffer) (file-name-nondirectory file))
	           return buffer
		finally return nil))

#+end_src

*** Retrieval
**** get-point

#+begin_src emacs-lisp

(defun custom/get-point (command &rest args)
  (interactive)
  (save-excursion
    (apply command args)
    (point)))

#+end_src

**** last-change

#+begin_src emacs-lisp

(defun custom/last-change ()
  "Retrieve last change in current buffer."
  (setq last-change (nth 1 buffer-undo-list))
  (let ((beg (car last-change))
        (end (cdr last-change)))
    (buffer-substring-no-properties beg end)))

#+end_src

**** visible-buffers

#+begin_src emacs-lisp

(defun custom/visible-buffers ()
  (cl-delete-duplicates (mapcar #'window-buffer (window-list))))

#+end_src

**** get-keyword-key-value

#+begin_src emacs-lisp

(defun custom/get-keyword-key-value (kwd)
   (let ((data (cadr kwd)))
     (list (plist-get data :key)
           (plist-get data :value))))

#+end_src

*** Execution
**** @buffers

#+begin_src emacs-lisp

(defmacro custom/@buffers (command &optional buffers)
  (let ((buffers (or buffers (buffer-list))))
    `(cl-loop for buffer in ',buffers
              collect (save-window-excursion (switch-to-buffer buffer)
                                             ,command))))

#+end_src

*** Operators
**** <>

#+begin_src emacs-lisp

(defun <> (a b c)
  (and (> b a) (> c b)))

#+end_src


** UI
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-ui.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Text
**** Theme accents

#+begin_src emacs-lisp

;; accent typefaces
(defvar custom/accents '(custom/italic))

(defun custom/theme-accents (orig-fun &rest args)
  "Many themes will override certain face *attributes*, such as `italic'. To prevent
this, this function loops over all accent typefaces in `custom/accents', which contains
faces (defined with `defface') named ~custom/<attribute>~, and makes the ~<attribute>~
inherit from ~custom/<attribute>~.

As such, when this function is run, the `italic' face attribute will be made to
inherit from `custom/italic' as in the expression below.

   (set-face-attribute 'italic nil :inherit 'custom/italic)

Thus, our preferred accent typefaces will stand whatever harassment they may be put
through as a theme loads."
  ;; load theme
  (apply orig-fun args)
  ;; restore accents
  (cl-loop for accent in custom/accents
	   collect (let ((face (intern (car (last (split-string (symbol-name accent) "/"))))))
		     (set-face-attribute face nil :inherit accent))))

(advice-add 'load-theme :around #'custom/theme-accents)

#+end_src

*** Window
**** Resize
***** window-resize

#+begin_src emacs-lisp

(defun custom/window-resize (width)
  (window-resize nil (- width (window-width)) t))

#+end_src

***** window-resize-fraction

#+begin_src emacs-lisp

(defun custom/window-resize-fraction (fr &optional min)
  "Resize window to a fraction of the frame width."
  (interactive)
  (let ((width (max (if min min 0) (truncate (* fr (frame-width))))))
    (window-resize nil (- width (window-width)) t)))

#+end_src

*** Warnings
**** C-g is undefined

#+begin_src emacs-lisp

;; Record last sent message
(defvar last-message nil)
(defadvice message (after my-message pre act) (setq last-message ad-return-value))

(defun custom/undefined-override (orig-fun &rest args)
  "Override `undefined' function to suppress
undefined key binding messages when interrupting
key binding input with C-g."
  (let ((inhibit-message t)
	    (message-log-max nil))
    (progn (apply orig-fun args)
	       (setq _message last-message)))
  (if (string-match-p (regexp-quote "C-g is undefined") _message)
      (keyboard-quit)
    (message _message)))

;; Override the undefined key binding notice with a keyboard-quit
(advice-add 'undefined :around #'custom/undefined-override)

#+end_src

*** Mode line
**** TODO Hide

- Hidden mode line mode
   - https://github.com/hlissner/emacs-hide-mode-line
   - https://webonastick.com/emacs-lisp/hide-mode-line.el
   - https://github.com/manateelazycat/awesome-tray

#+begin_src emacs-lisp

(defcustom custom/mode-line nil
  "Variable containing the format of the hidden mode line")

(defcustom custom/header-line nil
  "Variable containing the format of the hidden header line")

(defun custom/hide-mode-line ()
  "Hide `modeline' in current buffer"
  (interactive)
  (let ((m mode-line-format)
        (h header-line-format))
       (custom/@buffers (if (or m h)
                            (progn (setq custom/mode-line   m)
                                   (setq custom/header-line h)
                                   (setq mode-line-format   nil)
                                   (setq header-line-format nil))
                          (progn (setq mode-line-format custom/mode-line)
                                 (setq header-line-format custom/header-line))))))

(global-set-key (kbd "M-m") #'custom/hide-mode-line)

#+end_src

**** Invert

#+begin_src emacs-lisp

(defun custom/variable-replace (a b)
  "Set the value of `b' to that of `a', and
that of `a' to nil in all buffers"
  (let ((line (symbol-value a)))
    (custom/@buffers (progn (set b line)
                            (set a nil)))))

(defun custom/mode-line-invert ()
  (interactive)
  (let ((m 'mode-line-format)
        (h 'header-line-format))
    (if mode-line-format
        (custom/variable-replace m h)
      (custom/variable-replace h m))))

(global-set-key (kbd "M-t") #'custom/mode-line-invert)

#+end_src

** Themes
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-themes.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Switch
**** Hook

#+begin_src emacs-lisp

(defvar custom/load-theme-hook nil
   "`load-theme' hook.")

(defun custom/load-theme-hook (&rest _args)
   "Run `load-theme-hook'."
   (run-hooks 'custom/load-theme-hook))

(advice-add 'load-theme :after #'custom/load-theme-hook)

#+end_src

***** Org Mode

#+begin_src emacs-lisp

;; reload Org Mode
(defun custom/org-theme-reload ()
  (if (custom/in-mode "org-mode")
      (org-mode)
    (progn
      (setq window (get-buffer-window (current-buffer)))
      (cl-loop for buffer in (custom/visible-buffers)
	             collect (select-window (get-buffer-window buffer))
	 	     if (custom/in-mode "org-mode")
		        collect (org-mode))
      (select-window window))))

(add-hook 'custom/load-theme-hook #'custom/org-theme-reload)

#+end_src

**** Toggle

#+begin_src emacs-lisp

(defun custom/theme-toggle ()
  "Toggle between `dark' and `light' themes
using `enable-theme'"
  (interactive)
  (let ((theme (nth 0 custom-enabled-themes)))
    (cond ((string-equal theme light) (progn (disable-theme light)
					        (load-theme    dark)))
	     (t                          (progn (disable-theme theme)
						(load-theme    light))))))

(global-set-key (kbd "C-t") 'custom/theme-toggle)

#+end_src

*** Customization
**** Mode line

#+begin_src emacs-lisp

;; color
(defun custom/modeline-color (bg bg-in face face-in)
  "Set the color of the mode and header lines and blend the 
`doom-modeline-bar' with the background."
  (set-face-attribute 'mode-line          nil :foreground face    :background bg    :box nil)
  (set-face-attribute 'mode-line-inactive nil :foreground face-in :background bg-in :box nil)
  ;; header line
  (set-face-attribute 'header-line        nil :foreground face    :background bg    :box nil))

(defun custom/dark-modeline ()
  "Mode line for light themes."
  (custom/modeline-color "#3d3d3d" "#000000" "#cfcfcf" "#cfcfcf"))

(defun custom/light-modeline ()
  "Mode line for dark themes."
  (custom/modeline-color "#fff0ff" "#ededed" "#616161" "#878787"))

#+end_src

**** Line numbers

#+begin_src emacs-lisp

(defun custom/dark-line-numbers ()
  "Line numbers for light themes."
  (set-face-attribute 'line-number nil :foreground "#cfcfcf" :background "#262626"))

(defun custom/light-line-numbers ()
  "Line numbers for dark themes."
  (set-face-attribute 'line-number nil :foreground "#878787" :background "#ededed"))

#+end_src

**** Theme-specific advice
***** Light

#+begin_src emacs-lisp

(defun custom/light-advice ()
  (custom/light-modeline)
  (custom/light-line-numbers))

#+end_src

***** Dark

#+begin_src emacs-lisp

(defun custom/dark-advice ()
  (custom/dark-modeline)
  (custom/dark-line-numbers))

#+end_src

***** Add

#+begin_src emacs-lisp

(defun custom/theme-specific-advice (orig-fun &rest args)
  "Apply theme-specific advice when enabling themes, and
preserve modeline status through theme changes."
  (setq modeline-status mode-line-format)
  (apply orig-fun args)
  (let ((theme (nth 0 args)))
    (if (string-match-p "modus\\|nano" (symbol-name theme))
	   (cond ((string-equal theme light) (custom/light-advice))
 		 ((string-equal theme dark)  (custom/dark-advice)))))
  (setq mode-line-format modeline-status))

;; enable-theme
(advice-add 'load-theme :around #'custom/theme-specific-advice)

#+end_src


** Editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-editing.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Tabs

#+begin_src emacs-lisp

;; no tabs
(setq-default indent-tabs-mode nil)

#+end_src

*** Delete
**** Line

#+begin_src emacs-lisp

(defun custom/delete-line ()
  (delete-region (custom/get-point 'beginning-of-line) (custom/get-point 'end-of-line)))

#+end_src

**** Hungry

#+begin_src emacs-lisp

(defun custom/@delete-hungry (query)
  "Conditional region deletion.

Default: `delete-region'

If region starts at the beginning of an
indented line, delete region and indent.

If `query', delete the region and its indent 
plus one character."
  (setq beg (region-beginning) end (region-end))
  (if (custom/at-indent beg)
	    (save-excursion (beginning-of-visual-line)
                      (if (and query (not (bobp)) (not (custom/relative-line-empty -1)))
                          (left-char))
                      (delete-region (point) end))
    (delete-region beg end)))

(defun custom/delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the current mode is derived from 
`prog-mode',  delete the region and its indent plus 
one character."
  (interactive)
  (custom/@delete-hungry (derived-mode-p 'prog-mode)))

#+end_src

**** TODO Forward

- region deletion

#+begin_src emacs-lisp

(defun custom/nimble-delete-forward ()
  "Conditional forward deletion.

Default: `delete-forward-char' 1

If next line is empty, forward delete indent of 
next line plus one character."
  (interactive)
  (cond ((and (eolp) (custom/relative-line-indented 1)) (progn (setq beg (point)) (next-line) (back-to-indentation) (delete-region beg (point))))
	    ((custom/relative-line-empty)                   (delete-region (point) (custom/get-point 'next-line)))
	    (t                                              (delete-forward-char 1))))

(global-set-key (kbd "<deletechar>") 'custom/nimble-delete-forward)

#+end_src

**** Backward

#+begin_src emacs-lisp

(defun custom/nimble-delete-backward ()
  "Conditional forward deletion.

Default: `delete-backward-char' 1

If `multiple-cursors-mode' is active, `delete-backward-char' 1.

If region is active, delete region.

If cursor lies either `custom/at-indent' or is preceded only by
whitespace, delete region from `point' to `beginning-of-visual-line'."
  (interactive)
  (if (not (bound-and-true-p multiple-cursors-mode))
      (cond ((and (region-active-p) (not (custom/region-blank))) (custom/delete-hungry))
	        ((custom/at-indent)                                  (delete-region (point) (custom/get-point 'beginning-of-visual-line)))
		(t                                                   (delete-backward-char 1)))
    (delete-backward-char 1)))

(global-set-key (kbd "<backspace>") 'custom/nimble-delete-backward)

#+end_src

*** Kill ring
**** Size

#+begin_src emacs-lisp

;; Increase kill ring size
(setq kill-ring-max 200)

#+end_src

**** Mouse

#+begin_src emacs-lisp

(defun custom/kill-ring-mouse ()
  "If a region is active, save the region to the
kill ring. Otherwise, yank the last entry in the
kill ring."
  (interactive)
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (yank)))

(global-set-key (kbd "<mouse-3>")        'custom/kill-ring-mouse)
(global-set-key (kbd "<down-mouse-3>")    nil)

#+end_src

*** TODO Regions

- insert-char in region
   - delete, insert char
- arrow exit
   - <right> -> right of region
   - <left>  -> left of region

*** Selection
**** Defaults

#+begin_src emacs-lisp

;; Unset secondary overlay key bindings
(global-unset-key [M-mouse-1])
(global-unset-key [M-drag-mouse-1])
(global-unset-key [M-mouse-3])
(global-unset-key [M-mouse-2])

#+end_src

**** Whole buffer

#+begin_src emacs-lisp

(global-set-key (kbd "C-a") 'mark-whole-buffer)

#+end_src

*** TODO Comments

- if region is active and cursor is in empty line, region is not commented
- if last arrow command was up or left, move up, if last arrow command was right or down, move down

#+begin_src emacs-lisp

(defun custom/smart-comment ()
  "If a region is active, comment out all lines in the
region. Otherwise, comment out current line if it is
not empty. In any case, advance to next line."
  (interactive)
  (let (beg end)
    ;; If a region is active
    (if (region-active-p)
	      ;; If the beginning and end of the region are in
	      ;; the same line, select entire line
	      (if (= (count-lines (region-beginning) (region-end)) 1)
		  (setq beg (line-beginning-position) end (line-end-position))
		;; Else, select region from the start of its first
		;; line to the end of its last.
		(setq beg (save-excursion (goto-char (region-beginning)) (line-beginning-position))
		      end (save-excursion (goto-char (region-end)) (line-end-position))))
      ;; Else, select line
      (setq beg (line-beginning-position) end (line-end-position)))

    ;; Comment or uncomment region
    ;; If Org Mode is active
    (if (not (custom/relative-line-empty))
	      (comment-or-uncomment-region beg end))
    ;; Move to the beginning of the next line
    (beginning-of-line-text 2)))

(global-set-key (kbd "C-x ;") #'custom/smart-comment)

#+end_src

*** Rectangular regions

#+begin_src emacs-lisp

;; Ensure rectangular-region-mode is loaded
(require 'rectangular-region-mode)

#+end_src

**** Mouse rectangle

#+begin_src emacs-lisp

;; Multiple cursor rectangle definition mouse event
(defun custom/mouse-rectangle (start-event)
  (interactive "e")
  (deactivate-mark)
  (mouse-set-point start-event)
  (set-rectangular-region-anchor)
  (rectangle-mark-mode +1)
  (let ((drag-event))
    (track-mouse
      (while (progn
               (setq drag-event (read-event))
               (mouse-movement-p drag-event))
        (mouse-set-point drag-event)))))

(global-set-key (kbd "M-<down-mouse-1>") #'custom/mouse-rectangle)

#+end_src

**** TODO Multiple cursors

- arrow exit
   - <right>
      - right
   - <left>
      - left

#+begin_src emacs-lisp

;; Enter multiple-cursors-mode
(defun custom/rectangular-region-multiple-cursors ()
  (interactive)
  (rectangular-region-mode 0)
  (multiple-cursors-mode 1)
  (deactivate-mark)
  (mc/for-each-fake-cursor
   (if (invisible-p (marker-position (overlay-get cursor 'point)))
       (mc/remove-fake-cursor cursor))))

(define-key rectangular-region-mode-map (kbd "<return>") #'custom/rectangular-region-multiple-cursors)

#+end_src

**** Quit

#+begin_src emacs-lisp

;; Exit rectangular-region-mode
(define-key rectangular-region-mode-map (kbd "<escape>") #'rrm/keyboard-quit)
(define-key rectangular-region-mode-map (kbd "<mouse-1>") #'rrm/keyboard-quit)

#+end_src


** Navigation
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-navigation.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Text
**** TODO end

- in wrapped line
   - end of visual line -> end of line
- else
   - end of line -> end of visual line

#+begin_src emacs-lisp

;; Double end to go to the beginning of line
(defvar custom/double-end-timeout 0.4)

(defun custom/double-end ()
  "Move to end of visual line. If the command is repeated 
within `custom/double-end-timeout' seconds, move to end
of line."
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
             (<= (time-to-seconds (time-since last-called)) custom/double-end-timeout))
        (progn (beginning-of-visual-line) (end-of-line))
      (end-of-visual-line)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<end>") #'custom/double-end)

#+end_src

**** home

#+begin_src emacs-lisp

(defun custom/home ()
  "Conditional homing. 

Default: `beginning-of-line-text'

If the current line is empty, home to `beginning-of-line'.

If the current line holds a list item, home back to `beginning-of-line-text'.

If the current line is indented, home `back-to-indentation'.

If the current mode is derived from `prog-mode', home `back-to-indentation'.

If the current line is a wrapped visual line, home to
`beginning-of-visual-line'."
  (interactive)
  (cond ((custom/relative-line-empty)    (beginning-of-line))
	    ((custom/relative-line-list)     (beginning-of-line-text))
	    ((custom/relative-line-indented) (back-to-indentation))
	    ((custom/relative-line-wrapped)  (beginning-of-visual-line))
	    ((derived-mode-p 'prog-mode)     (back-to-indentation))
	    ((custom/relative-line-wrapped)  (beginning-of-visual-line))
        (t                               (beginning-of-line-text))))

(defvar custom/double-home-timeout 0.4)

(defun custom/double-home ()
  "Dynamic homing command with a timeout of `custom/double-home-timeout' seconds.
- Single press: `custom/home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
	           (<= (time-to-seconds (time-since last-called)) custom/double-home-timeout))
	      (progn (beginning-of-visual-line)
		     (beginning-of-line-text))
      (custom/home)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<home>") #'custom/double-home)

#+end_src

**** previous-line

#+begin_src emacs-lisp

(defun custom/previous-line (cond)
  "If a region is active and the current mode is derived 
from `prog-mode', arrow-up to `end-of-visual-line' of
`previous-line'."
  (interactive)
  (if (and (region-active-p) cond)
      (progn (previous-line)
	           (point-to-register 'region-up-register)
	           (end-of-visual-line))
    (previous-line)))

(global-set-key (kbd "<up>") (lambda () (interactive) (custom/previous-line (derived-mode-p 'prog-mode))))

(defun custom/region-up-register ()
  "Move cursor to `region-up-register', defined in
`custom/previous-line'."
  (interactive)
  (let ((end (region-end)))
    (ignore-errors (jump-to-register 'region-up-register))
    (set-register 'region-up-register nil)
    (push-mark end)))

(global-set-key (kbd "S-<home>") #'custom/region-up-register)

#+end_src

**** beginning-of-line-text

#+begin_src emacs-lisp

(defun custom/beginning-of-line-text (orig-fun &rest args)
  "Correctly go to `beginning-of-line-text' in numbered lists."
  (interactive)
  (let ((ordered-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}"))
    (if (save-excursion (beginning-of-line)
			    (looking-at-p ordered-line-regex))
	    (progn (beginning-of-line)
		   (re-search-forward ordered-line-regex))
      (apply orig-fun args))))

(advice-add 'beginning-of-line-text :around #'custom/beginning-of-line-text)

#+end_src

*** Window
**** Split and follow

#+begin_src emacs-lisp

;; split and follow
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (other-window 1))
(global-set-key (kbd "C-x 2") #'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (other-window 1))
(global-set-key (kbd "C-x 3") #'split-and-follow-vertically)

#+end_src

**** Previous window
***** Record

#+begin_src emacs-lisp

(defvar custom/window-previous nil
  "Selected window before the last window change.")

(defvar custom/window-pre-command nil
  "Auxiliary variable containing the `selected-window'
before the execution of any command.")

(defun custom/record-window-pre-command ()
  (setq custom/window-pre-command (selected-window)))
(add-hook 'pre-command-hook #'custom/record-window-pre-command)

(defun custom/record-window-previous ()
  (let ((window-post (selected-window)))
    (if (not (eq window-post custom/window-pre-command))
	      (setq custom/window-previous custom/window-pre-command))))
(add-hook 'post-command-hook #'custom/record-window-previous)

#+end_src

***** TODO Command

- if single window, do nothing

#+begin_src emacs-lisp

(defun custom/goto-window-previous ()
  (interactive)
  (let ((target  custom/window-previous)
	      (current (selected-window)))
    (if target
	      (progn (select-window target)
		     (setq custom/window-previous current)))))

(global-set-key (kbd "C-c p") #'custom/goto-window-previous)

#+end_src


** File management
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-file-management.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** DOS to UNIX

#+begin_src emacs-lisp

;; Transform all files in directory from DOS to Unix line breaks
(defun custom/dos2unix (&optional dir)
  (let ((default-directory (or dir (file-name-directory buffer-file-name))))
    (shell-command "find . -maxdepth 1 -type f -exec dos2unix \\{\\} \\;")))

#+end_src

*** Reload from disk

#+begin_src emacs-lisp

(defun custom/reload-from-disk (&optional buffer)
  "Revert BUFFER contents to the contents of its
file saved on disk, ignoring the auto-save file.
If the buffer has unsaved modifications, prompt
the user for confirmation."
  (interactive)
  (let ((buffer (or buffer (current-buffer))))
    (save-window-excursion
      (switch-to-buffer buffer)
      (if (not (buffer-modified-p))
	     (revert-buffer t t)
	   (revert-buffer t nil)))))

(global-set-key (kbd "C-c r") #'custom/reload-from-disk)

#+end_src


** Org Mode
:PROPERTIES:
:header-args:emacs-lisp: :tangle ./extensions/shapes-org.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** General purpose
**** Queries
***** in
****** org-in-src-block-p

#+begin_src emacs-lisp

;; `org-in-src-block-p' gives false positives as of Org Mode 9.5.3. For
;; this reason, determine if cursor in src block with the more reliable
;; `org-babel-where-is-src-block-head'
(advice-add 'org-in-src-block-p :override 'org-babel-where-is-src-block-head)

#+end_src

***** at
****** org-at-ellipsis

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis (&optional position)
  (or (custom/org-at-ellipsis-h position) (custom/org-at-ellipsis-l position)))

#+end_src

****** org-at-ellipsis-l

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis-l (&optional position)
  (and (custom/org-relative-line-list-folded) (custom/at-point 'end-of-visual-line)))

#+end_src 

****** org-at-ellipsis-h

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis-h (&optional position) 
  (and (custom/org-relative-line-heading-folded) (custom/at-point 'end-of-visual-line)))

#+END_src 

****** org-at-keyword

#+begin_src emacs-lisp

(defun custom/org-at-keyword (&optional number)
  (custom/relative-line-regex "^#+.*$" number))

#+END_src 
****** org-at-heading

#+begin_src emacs-lisp

(defun custom/org-at-heading (&optional point)
  (let ((point (or point (point))))
    (save-excursion (goto-char point) (custom/org-relative-line-heading))))

#+end_src

****** TODO org-at-bol-list

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-bol-list () 
  (and (custom/org-relative-line-list) (custom/at-point 'beginning-of-line-text)))

#+END_src 

****** TODO org-at-bol-heading

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-bol-heading () 
  (and (custom/org-relative-line-heading) (custom/at-point 'custom/org-goto-heading-bol)))

#+END_src 

****** TODO org-at-eol-heading

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-eol-heading ()
  (and (custom/org-relative-line-heading) (eolp) (not (custom/org-at-ellipsis-h)) (not (custom/org-relative-line-heading-empty))))

#+end_src

***** after
****** org-after-list-or-indent

#+begin_src emacs-lisp

(defun custom/org-after-list-or-indent ()
  (or (custom/org-relative-line-list -1) (custom/relative-line-indented -1)))

#+end_src

***** line
****** org-relative-line-list

#+begin_src emacs-lisp

(defun custom/org-relative-line-list (&optional number)
  (custom/relative-line (lambda () (progn (beginning-of-line-text) (org-at-item-p)))  number))

#+end_src

****** org-relative-line-heading

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading (&optional number)
  (custom/relative-line 'org-at-heading-p number))

#+end_src

****** org-relative-line-paragraph

#+begin_src emacs-lisp

(defun custom/org-relative-line-paragraph (&optional number)
  "Determine whether the current line -or the NUMBER'th line relative to it
is an indented paragraph."
  (let ((number (or number 0)))
    (and (not (custom/org-relative-line-heading number))
	       (not (custom/org-relative-line-list    number))
	       (not (org-in-src-block-p))
	       (custom/relative-line-indented number)
	       (or  (custom/org-relative-line-list      (- number 1))
		    (custom/org-relative-line-paragraph (- number 1))))))

#+end_src

****** org-relative-line-list-empty

#+begin_src emacs-lisp

(defun custom/org-relative-line-list-empty (&optional number)
  (and (custom/org-relative-line-list)
       (or (custom/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+$" number)
	         (custom/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+$" number))))

#+end_src

****** org-relative-line-list-folded

#+begin_src emacs-lisp

(defun custom/org-relative-line-list-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded list item."
  (custom/relative-line (lambda () (and (org-at-item-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-empty

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-empty (&optional number)
  (custom/relative-line (lambda () (beginning-of-line-text) (org-point-at-end-of-empty-headline)) number))

#+end_src

****** org-relative-line-heading-folded

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded heading."
  (custom/relative-line (lambda () (and (org-at-heading-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-or-list

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-or-list (&optional number)
  (custom/relative-line 'org-at-heading-or-item-p number))

#+end_src
***** subtree
****** org-subtree-blank

#+begin_src emacs-lisp

(defun custom/org-subtree-blank ()
  "Return t if the current subtree consists of
a `custom/region-blank'."
  (interactive)
  (apply #'custom/region-blank (custom/org-subtree-region)))

#+end_src

****** org-subtree-empty

#+begin_src emacs-lisp

(defun custom/org-subtree-empty ()
  (interactive)
  (string-equal "" (custom/org-subtree-content)))

#+end_src

****** org-headings-follow

#+begin_src emacs-lisp

(defun custom/org-headings-follow ()
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
    (save-excursion (custom/org-goto-heading-next)
		           (and (not (= pos (point))) (custom/org-relative-line-heading)))))

#+end_src

****** org-headings-precede

#+begin_src emacs-lisp

(defun custom/org-headings-precede ()
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
    (save-excursion (custom/org-goto-heading-previous)
		          (and (not (= pos (point))) (custom/org-relative-line-heading)))))

#+end_src

****** org-subtree-blank-up-to-point

#+begin_src emacs-lisp

(defun custom/org-subtree-blank-up-to-point ()
  (interactive)
  (let ((heading-eol (save-excursion (custom/org-goto-heading-current) (end-of-line) (point))))
    (custom/region-blank heading-eol (point))))

#+end_src

***** heading
****** org-heading-first-child

#+begin_src emacs-lisp

(defun custom/org-heading-first-child ()
  (save-excursion
    (custom/org-goto-heading-current)
    (let ((pos (custom/get-point 'beginning-of-visual-line)))
      (org-backward-heading-same-level 1)
      (= pos (custom/get-point 'beginning-of-visual-line)))))

#+end_src

****** org-heading-has-children

#+begin_src emacs-lisp

(defun custom/org-heading-has-children ()
  (interactive)
  (save-excursion (org-goto-first-child)))

#+end_src

**** Retrieval
***** org-subtree-region

#+begin_src emacs-lisp

(defun custom/org-subtree-region (&optional element)
  "Retrieve the beginning and end of the current subtree."
  (if (org-element--cache-active-p)
      (let* ((heading (org-element-lineage
                       (or element (org-element-at-point))
                       '(headline) t))
	     (head (org-element-property :begin heading))
	     (next (org-element-property :end   heading)))
	  (if (and heading next)
	      (progn (save-excursion (goto-char head)
				     (beginning-of-line 2)
				     (setq beg (point)))
		     (save-excursion (goto-char next)
				     (beginning-of-line)
				     (setq end (max beg (point))))
		     (list beg end))))))

#+end_src

***** org-subtree-content

#+begin_src emacs-lisp

(defun custom/org-subtree-content ()
  "Retrieve the content of the current subtree."
  (setq content (apply #'buffer-substring-no-properties (custom/org-subtree-region))))

#+end_src

***** org-get-title-file

#+begin_src emacs-lisp

(defun custom/org-get-title-file (file)
  (with-current-buffer (find-file-noselect file)
       (custom/org-get-title-buffer)))

#+end_src

***** org-get-title-buffer

#+begin_src emacs-lisp

(defun custom/org-get-title-buffer (&optional buffer)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (nth 1
	   (assoc "TITLE"
		  (org-element-map (org-element-parse-buffer 'greater-element)
		      '(keyword)
		    #'custom/get-keyword-key-value))))))

#+end_src

**** TODO Outline

- deprecated cl warning
   - find dependency

***** Set
****** set-outline-overlay-data

#+begin_src emacs-lisp

(defvar-local custom/org-outline-state nil
  "Place for saving org outline state before reverting the buffer.")

(put 'custom/org-outline-state 'permanent-local t)

(defun custom/org-set-outline-overlay-data (data)
  "Create visibility overlays for all positions in DATA.
DATA should have been made by `org-outline-overlay-data'."
  (org-with-wide-buffer
   (org-show-all)
   (dolist (c data) (org-flag-region (car c) (cdr c) t 'outline))))

#+end_src

****** restore-outline-state

#+begin_src emacs-lisp

(defun custom/org-restore-outline-state ()
  "Save org outline state in `custom/org-outline-state'.
It can be recovered afterwards with `custom/org-recover-outline-state'."
  (when custom/org-outline-state
    (custom/org-set-outline-overlay-data custom/org-outline-state)
    (setq custom/org-outline-state nil)))

#+end_src

***** Get
****** outline-overlay-data

#+begin_src emacs-lisp

(defun custom/org-outline-overlay-data (&optional use-markers)
  "Return a list of the locations of all outline overlays.
These are overlays with the `invisible' property value `outline'.
The return value is a list of cons cells, with start and stop
positions for each overlay.
If USE-MARKERS is set, return the positions as markers."
  (let (beg end)
    (org-with-wide-buffer
     (delq nil
       (mapcar (lambda (o)
             (when (eq (overlay-get o 'invisible) 'outline)
               (setq beg (overlay-start o)
                     end (overlay-end o))
               (and beg end (> end beg)
                (if use-markers
                (cons (copy-marker beg)
                      (copy-marker end t))
                  (cons beg end)))))
           (overlays-in (point-min) (point-max)))))))

#+end_src

****** save-outline-state

#+begin_src emacs-lisp

(defun custom/org-save-outline-state ()
  "Save org outline state in `custom/org-outline-state'.
It can be recovered afterwards with `custom/org-recover-outline-state'."
  (setq custom/org-outline-state (custom/org-outline-overlay-data t)))

(defun custom/org-install-save-outline-state ()
  "Configure org to preserve the outline state at revert-buffer."
  (add-hook 'before-revert-hook #'custom/org-save-outline-state nil t)
  (add-hook 'after-revert-hook #'custom/org-restore-outline-state nil t))

(add-hook 'org-mode-hook #'custom/org-install-save-outline-state)

#+end_src

***** Hide
****** org-hide-previous-subtree

#+begin_src emacs-lisp

(defun custom/org-hide-previous-subtree ()
  "Cycle previous Org Mode heading."
  (save-excursion (custom/org-goto-heading-previous)
		        (outline-hide-subtree)))

#+end_src

***** Show
****** org-show

#+begin_src emacs-lisp

(defun custom/org-show (orig-fun &rest args)
  (if (custom/org-at-ellipsis)
      (progn (custom/org-goto-heading-bol) (apply orig-fun args))
    (apply orig-fun args)))

#+end_src

****** org-show-subtree

#+begin_src emacs-lisp

(advice-add 'org-show-subtree :around #'custom/org-show)

#+end_src

****** org-show-children

#+begin_src emacs-lisp

(advice-add 'org-show-children :around #'custom/org-show)

#+end_src

****** org-show-minimum

#+begin_src emacs-lisp

(defun custom/org-show-minimum ()
  (if (or (custom/org-relative-line-list-folded)
	        (custom/org-relative-line-heading-folded))
      (progn (if (custom/org-at-ellipsis)
		       (progn (beginning-of-visual-line) (end-of-line)))
	           (org-show-entry)
	           (if (custom/org-heading-has-children) (org-show-children)))))

#+end_src

*** Editing
**** Text
***** Undo

#+begin_src emacs-lisp

(defun custom/org-undo ()
  (interactive)
  (if (org-babel-where-is-src-block-head)
      (progn (setq beg (point))
	           (cond ((eq last-command 'custom/org-return)    (undo 2))
                   ((eq last-command 'custom/smart-comment) (undo 1))
	                 (t                                       (undo 1)))
	           (save-excursion (goto-char (org-babel-where-is-src-block-head))
				   (next-line)
				   (setq hang (point)))
		   (if (= hang (point))
		       (progn (goto-char beg)
			      (beginning-of-line-text))))
    (undo 1)))

(define-key org-mode-map (kbd "C-/") 'custom/org-undo)

#+end_src

***** Insert
****** Items
******* org-insert-item-respect-content

#+begin_src emacs-lisp

(defun custom/org-insert-item-respect-content ()
  (interactive)
  (let ((struct (org-list-struct))
	    (unfold (if (custom/org-relative-line-list-folded) nil (point-marker))))
    (org-list-set-item-visibility (point-at-bol) struct 'folded)
    (save-excursion
      (beginning-of-visual-line)
      (kill-ring-save (point) (custom/get-point 'beginning-of-line-text)))
    (end-of-visual-line)
    (org-return)
    (yank)
    (if unfold (save-excursion (goto-char unfold) (org-list-set-item-visibility (point-at-bol) struct 'subtree)))))

#+end_src

****** Headings
******* Margins
******** org-heading-margin-post

#+begin_src emacs-lisp

(defun custom/org-heading-margin-post ()
  "Return margin between current heading and next."
  (if (org-current-level)
      (let ((pos            (custom/get-point 'custom/org-goto-heading-bol))
	           (end-of-subtree (custom/get-point 'custom/org-goto-subtree-end))
		   (next-heading   (custom/get-point 'custom/org-goto-heading-next)))
	          (if (not (and (= pos end-of-subtree) (custom/org-relative-line-heading)))
		      (buffer-substring-no-properties end-of-subtree next-heading)
		    ""))
    (if (custom/org-headings-follow)
	       (buffer-substring-no-properties (point) (custom/get-point 'custom/org-goto-heading-next))
      "")))

#+end_src

******** org-heading-margin-delete-post

#+begin_src emacs-lisp

(defun custom/org-heading-margin-delete-post ()
  "Delete newline after new headings created by
`respect-content' heading commands."
  (if (custom/org-subtree-blank)
      (apply 'delete-region (custom/org-subtree-region))))

#+end_src

******** org-heading-margin-insert-previous

#+begin_src emacs-lisp

(defun custom/org-heading-margin-insert-previous ()
  "If the previous subtree is not empty,
insert a margin of 1 empty line."
  (let ((insert-margin (save-excursion (if (custom/org-heading-first-child)
					          (custom/org-goto-heading-previous)
					        (org-backward-heading-same-level 1))
				              (not (custom/org-subtree-blank)))))
    (if insert-margin
      (progn (beginning-of-visual-line)
	            (org-return)
		    (beginning-of-line-text)))))

#+end_src

******* org-insert-heading

#+begin_src emacs-lisp

(defun custom/org-insert-heading (command &optional margin)
  "Primitive for custom heading functions.

If cursor if at an Org Mode heading's
ellipsis, go to the `end-of-line' of the
heading's visual line.

If cursor lies on an Org Mode heading,
`custom/org-show-minimum'.

If cursor is outside top level heading,
insert heading at point, without removing
any of the previous space.

If the previous subtree is not empty,
insert a margin of 1 empty line.
This is because Org Mode heading insertion
commands will automatically remove all [[:space:]]
until first preceding non-empty line.

If MARGIN is t:
- insert margin between content under parent heading and new one"
  (interactive)
  (if (custom/org-at-ellipsis-h)         (progn (beginning-of-visual-line) (end-of-line)))
  (if (custom/org-relative-line-heading) (custom/org-show-minimum))
  ;; Insert heading
  (cond ((not (org-current-level)) (insert "* "))
	      (t                         (funcall command)))
  ;; Insert margin
  (if margin (custom/org-heading-margin-insert-previous))
  ;; Hide previous subtree
  (if (save-excursion (custom/org-goto-heading-previous)
		            (custom/org-relative-line-heading-folded))
      (custom/org-hide-previous-subtree)))

#+end_src

******* org-insert-subheading

#+begin_src emacs-lisp

(defun custom/org-insert-subheading (orig-fun &optional arg)
  "Make `org-insert-subheading' ARG optional."
  (interactive)
  (let ((arg (or arg 0)))
    (funcall orig-fun arg)))

(advice-add 'org-insert-subheading :around #'custom/org-insert-subheading)

#+end_src

******* org-insert-heading-at-point

#+begin_src emacs-lisp

(defun custom/org-insert-heading-at-point ()
  (interactive)
  (custom/org-insert-heading 'org-insert-heading (not (custom/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-subheading-at-point

#+begin_src emacs-lisp

(defun custom/org-insert-subheading-at-point ()
  (interactive)
  (custom/org-insert-heading 'org-insert-subheading (not (custom/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-heading-after-subtree

#+begin_src emacs-lisp

(defun custom/org-insert-heading-after-subtree ()
  "Insert heading after current subtree. As
`org-insert-heading-respect-content' does not
behave well with folded Org Mode headings, if
the previous heading is folded:
1. Unfold the heading
2. Create the new heading after its subtree
3. Fold it back"
  (let ((margin-post        (custom/regex-match-count "\n" (custom/org-heading-margin-post)))
	      (prev-same-level    (custom/get-point 'beginning-of-visual-line))
	      (prev-lower-level   (custom/get-point 'custom/org-goto-child-last))
	      (folded-same-level  (custom/org-relative-line-heading-folded))
	      (folded-lower-level (save-excursion (custom/org-goto-child-last) (custom/org-relative-line-heading-folded))))

    ;; Go to current heading
    (custom/org-goto-heading-current)

    ;; Unfold if necessary
    (if folded-same-level  (save-excursion (org-show-subtree)))
    (if folded-lower-level (save-excursion (custom/org-goto-subtree-end) (org-show-subtree)))
    
    ;; Insert heading
    (cond ((not (org-current-level)) (insert "* "))
	        (t                         (progn (custom/org-goto-heading-current) (org-insert-heading-respect-content))))
    (custom/org-heading-margin-delete-post)

    ;; Insert margin with previous heading
    (custom/org-heading-margin-insert-previous)
    
    ;; Fold back if necessary
    (if folded-same-level  (save-excursion (goto-char prev-same-level)  (outline-hide-subtree)))
    (if folded-lower-level (save-excursion (goto-char prev-lower-level) (outline-hide-subtree)))

    ;; Recover margin with following heading
    (if (> margin-post 1) (save-excursion (insert "\n")))))
  
#+end_src

******* org-insert-subheading-after-subtree

#+begin_src emacs-lisp

(defun custom/org-insert-subheading-after-subtree ()
  "`org-insert-subheading' respecting content."
  (interactive)
  (custom/org-show-minimum)
  (if (custom/org-heading-has-children)
      (progn (custom/org-goto-child-last)
	           (custom/org-insert-heading-after-subtree))
    (progn (custom/org-insert-heading-after-subtree)
	         (org-do-demote))))

#+end_src

****** Edition at ellipses

#+begin_src emacs-lisp

(defvar custom/org-functions-at-ellipsis '(org-self-insert-command
					        custom/kill-ring-mouse)
  "Functions whose behavior at Org Mode ellipses
will be advised by `custom/org-edit-at-ellipsis'")

(defun custom/org-edit-at-ellipsis (orig-fun &rest args)
  "Execute commands invoked at an Org Mode heading's
ellipsis in the first line under the heading."
  (if (custom/org-at-ellipsis-h)
      (progn (beginning-of-visual-line)
	          (custom/org-show-minimum)
		  (end-of-line)
		  (org-return)
		  (apply orig-fun args))
    (apply orig-fun args)))

(dolist (function custom/org-functions-at-ellipsis)
  (advice-add function :around #'custom/org-edit-at-ellipsis))

#+end_src

***** Return
****** return

- reference
   - https://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/

#+begin_src emacs-lisp

;; org-return
(defun custom/org-return ()
  "Conditional `org-return'."
  (interactive)
  (cond ((custom/org-relative-line-list-empty)          (progn (custom/delete-line) (org-return)))
	     ((custom/org-at-bol-list)                       (progn (beginning-of-visual-line) (org-return) (beginning-of-line-text)))
	     ((custom/org-at-ellipsis-l)                     (custom/org-insert-item-respect-content))
	     ((custom/org-relative-line-paragraph)           (org-insert-item))
	     ((custom/org-relative-line-list)                (org-meta-return))
	     ((and (custom/org-after-list-or-indent) (bolp)) (org-return))
	     ((custom/org-at-bol-heading)                    (save-excursion (beginning-of-visual-line) (org-return t)))
	     ((custom/org-at-eol-heading)                    (progn (newline 2) (if (custom/org-subtree-blank) (progn (newline) (previous-line)))))
	     ((custom/org-at-ellipsis-h)                     (org-return))
	     (t                                              (org-return t))))

(define-key org-mode-map (kbd "<return>") 'custom/org-return)

#+end_src

****** TODO C-return

- at ellipsis -> doesn't work

- on non-empty line
   - insert heading at line

- list paragraphs
   - custom/org-toggle-paragraph
      - keep cursor in place

- bugs
   - if at empty heading or heading separated by more than 1 empty line from next
      - star is inserted in line of next heading
         - "* " is inserted in line of next heading
   - cycle previous heading to remove spurious separation line

- if list not empty -> move contents to new item
- if after list
   - create list item from current line
- if before list
   - create list item at top of list

- if at indented paragraph in list
   - turn paragraph into list item
- if at non-empty line, turn entire non-empty line into either header or list item
   - if at middle of word inside list
      - new indented list item, break word and place second part in new item

#+begin_src emacs-lisp

;; org-meta-return
(defun custom/org-control-return ()
  (interactive)
  (cond ((custom/org-relative-line-list-empty) (progn (org-meta-return) (next-line) (end-of-line)))
	    ((custom/org-relative-line-heading)    (custom/org-insert-heading-after-subtree))
	    ((custom/org-relative-line-list)       (progn (end-of-line) (org-meta-return)))
	    ((custom/org-relative-line-paragraph)  (custom/org-paragraph-toggle))
	    (t                                     (custom/org-insert-heading-after-subtree))))

(define-key org-mode-map (kbd "C-<return>") #'custom/org-control-return)

#+end_src

****** M-return

#+begin_src emacs-lisp

(defun custom/org-meta-return ()
  (interactive)
  (custom/org-insert-subheading-after-subtree))

(define-key org-mode-map (kbd "M-<return>") 'custom/org-meta-return)

#+end_src

****** TODO S-return

- heading with keywords
   - skip keywords

#+begin_src emacs-lisp

(defun custom/org-super-return ()
  (interactive)
  (cond ((or (custom/org-relative-line-list)
	         (custom/org-relative-line-paragraph)) (org-return t))
	    (t                                         (custom/org-insert-subheading-at-point))))

(define-key org-mode-map (kbd "S-<return>") 'custom/org-super-return)

#+end_src

****** MS-return

#+begin_src emacs-lisp
 
(define-key org-mode-map (kbd "M-S-<return>") 'custom/org-insert-heading-at-point)

#+end_src

****** CS-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-S-<return>") 'org-insert-todo-heading)

#+end_src

****** CM-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-M-<return>") 'org-insert-todo-subheading)

#+end_src

***** Delete
****** Hungry

#+begin_src emacs-lisp

(defun custom/org-delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the cursor lies on an Org Mode
src block, delete the region and its indent plus 
one character."
  (interactive)
  (custom/@delete-hungry (org-in-src-block-p)))

#+end_src

****** TODO Forward

- next line = empty list item -> delete next line

#+begin_src emacs-lisp

(defun custom/org-nimble-delete-forward ()
  "Org Mode complement to `custom/nimble-delete-forward'."
  (interactive)
  (cond ((and (custom/org-at-ellipsis-h)
	           (custom/org-relative-line-heading 1))  (progn (beginning-of-visual-line 2)
								 (beginning-of-line-text)
								 (delete-forward-char 1)))
	      (t (custom/nimble-delete-forward))))

(define-key org-mode-map (kbd "<deletechar>") 'custom/org-nimble-delete-forward)

#+end_src

****** TODO Backward

- bullets with extra space between marker and text
   -    no action

- if at beginning of empty heading and a heading lies below
   - bring next heading to level of current one
      - delete newline + stars of the next heading
- delete empty heading
   - go to previous line
   - delete newline
      - maybe cycle previous

#+begin_src emacs-lisp

(defun custom/org-nimble-delete-backward ()
  "Org Mode complement to `custom/nimble-delete-backward'."
  (interactive)
  (cond ((and (region-active-p)
	           (not (custom/region-blank)))                 (custom/org-delete-hungry))
	     ((or  (custom/org-at-ellipsis-h)
		   (custom/org-at-ellipsis-l))                  (progn (beginning-of-visual-line) (end-of-line) (delete-backward-char 1)))
	     ((and (or (custom/org-relative-line-heading-empty)
		       (custom/org-relative-line-list-empty))
		   (org-current-level))                         (delete-region (point) (custom/get-point 'end-of-line 0)))
	     ((or  (custom/org-relative-line-heading-empty)
		   (custom/org-relative-line-list-empty))       (delete-region (point) (custom/get-point 'beginning-of-visual-line)))
	     ((custom/org-at-bol-list)                          (custom/org-toggle-item))
        (t                                                 (custom/nimble-delete-backward))))

(define-key org-mode-map (kbd "<backspace>") 'custom/org-nimble-delete-backward)

#+end_src

***** Toggle
****** org-toggle-item

#+begin_src emacs-lisp

(defun custom/org-toggle-item ()
  (interactive)
  (let ((toggle-off (custom/org-relative-line-list))
	     (indent     (+ 1 org-list-indent-offset))
	     (marker     (point)))
    (beginning-of-line-text)
    (delete-backward-char indent)
    (if toggle-off
	     (insert (make-string indent ?\s))
      (org-toggle-item 0))
    (goto-char marker)))

#+end_src

**** Structure
***** TODO indent-region

- use markers
   - https://www.gnu.org/software/emacs/manual/html_node/elisp/Overview-of-Markers.html
  
- regions spanning headings
   - nested headings
      - indent of 1 for every heading from top level in region
- bad interaction with wrapped lines

#+begin_src emacs-lisp

(defun custom/org-indent-region (command &rest args)
  "Indent Org Mode region.

If the region spans Org Mode headings or items:
1. Extend region by pushing `region-beginning' to its
`beginning-of-visual-line'
2. Execute COMMAND
3. Restore the region to its previous limits, shifting
its limits to match shifts in the position of the
text it spans, such as when indenting with `org-metaright'
or outdenting with `org-metaleft'."
  (if (or (custom/org-relative-line-heading) (custom/org-relative-line-list))
      (let ((beg (region-beginning))
	         (end (region-end))
		 (pos (point)))
	
	        ;; Determine mark
	        (setq mark (if (= pos beg) end beg))
		;; Count lines in region
		(setq lines (count-screen-lines beg end))

		;; Get initial cursor position wrt bol
		(setq relative-pos-0 (- pos (custom/get-point 'beginning-of-line)))
		;; Execute command
		(save-excursion (goto-char beg)
				(push-mark (custom/get-point 'beginning-of-line))
		 		(goto-char end)
				(end-of-visual-line)
				(apply command args))
		;; Get aftermath cursor position
		(setq pos-1 (point))
		;; Calculate cursor displacement
		(setq disp (- pos-1 pos))
		
           ;; Get aftermath cursor position wrt bol
		(setq relative-pos-1 (- pos-1 (custom/get-point 'beginning-of-line)))
		;; Calculate cursor displacement wrt bol
		(setq relative-disp (- relative-pos-1 relative-pos-0))

		;; Calculate mark shift
		(cond
		 ((custom/org-at-heading beg)  (setq shift disp))
		 ((= mark beg)                 (setq shift relative-disp))
		 ((= mark end)                 (setq shift (* relative-disp lines))))

		;; Push mark
		(push-mark (+ mark shift)))
    (apply command args)))

#+end_src

**** Preferences
***** Keep text selection after executing commands

#+begin_src emacs-lisp

(defun custom/with-mark-active (&rest args)
  "Keep mark active after command. To be used as advice AFTER any
function that sets `deactivate-mark' to t."
  (setq deactivate-mark nil))

(advice-add 'org-metaright      :after #'custom/with-mark-active)
(advice-add 'org-metaleft       :after #'custom/with-mark-active)
(advice-add 'org-metaup         :after #'custom/with-mark-active)
(advice-add 'org-metadown       :after #'custom/with-mark-active)

(advice-add 'org-shiftmetaright :after #'custom/with-mark-active)
(advice-add 'org-shiftmetaleft  :after #'custom/with-mark-active)
(advice-add 'org-shiftmetaup    :after #'custom/with-mark-active)
(advice-add 'org-shift-metadown :after #'custom/with-mark-active)

#+end_src

***** Do not insert newline before Org Mode headigs

#+begin_src emacs-lisp

;; Do not insert newline before Org Mode headings
(setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))

#+end_src

*** Display
**** Outline
***** TODO Cycle

- bug
   - https://lists.gnu.org/archive/html/emacs-orgmode/2022-05/msg00150.html
   - https://www.reddit.com/r/emacs/comments/ulpdhu/org_mode_command_doesnt_update_a_buffer_if_i_use/

#+begin_src emacs-lisp

(defun custom/org-cycle (orig-fun &rest args)
  "Conditional `org-cycle'.

Default: `org-cycle'

If cursor lies at `end-of-visual-line' of folded heading or list,
move cursor to `end-of-line' of the current visual line and then
call `org-cycle'.

If cursor lies at a paragraph directly under a list item and not
indented at the level of the previous list item, indent the paragraph."
  (interactive)
  (if (or (custom/org-relative-line-list-folded) (custom/org-relative-line-heading-folded))
      (if (= (point) (custom/get-point 'end-of-visual-line))
	  (progn (beginning-of-visual-line)
		 (end-of-line)
		 (apply orig-fun args))
	(apply orig-fun args))
    (if (and (org-in-src-block-p) (not (custom/org-at-keyword)))
	      (org-indent-line)
      (apply orig-fun args))))

(advice-add 'org-cycle :around #'custom/org-cycle)

#+end_src

***** TODO Advice

- not working

#+begin_src emacs-lisp

(defun custom/org-mode (orig-fun &rest args)
  (if (custom/in-mode "org-mode")
      (progn (custom/org-save-outline-state)
	         (apply orig-fun args)
		 (custom/org-restore-outline-state))
    (apply orig-fun args)))

(advice-add 'org-mode :around #'custom/org-mode)

#+end_src

**** Variable pitch

#+begin_src emacs-lisp

(defface custom/variable-pitch-marker
  '((nil :inherit 'fixed-pitch))
  "List marker typeface.")

(defface custom/variable-pitch-indent
  '((nil :inherit 'fixed-pitch :invisible t))
  "Indent typeface.")

(defvar custom/variable-pitch-keywords '(("^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}" 0 'custom/variable-pitch-marker)
					     ("^[[:blank:]]*[-+]\\{1\\}[[:blank:]]\\{1\\}"         0 'custom/variable-pitch-marker)
					     ("^[[:blank:]]+"                                      0 'custom/variable-pitch-indent))
  "Variable pitch font-lock keywords.")

(font-lock-add-keywords 'org-mode custom/variable-pitch-keywords 'append)

#+end_src

**** Continuous numbering of equations

#+begin_src emacs-lisp

;; continuous numbering of Org Mode equations
(defun org-renumber-environment (orig-fun &rest args)
  (let ((results '()) 
        (counter -1)
        (numberp))

    (setq results (cl-loop for (begin .  env) in 
                        (org-element-map (org-element-parse-buffer) 'latex-environment
                          (lambda (env)
                            (cons
                             (org-element-property :begin env)
                             (org-element-property :value env))))
                        collect
                        (cond
                         ((and (string-match "\\\\begin{equation}" env)
                               (not (string-match "\\\\tag{" env)))
                          (cl-incf counter)
                          (cons begin counter))
                         ((string-match "\\\\begin{align}" env)
                          (prog2
                              (cl-incf counter)
                              (cons begin counter)                          
                            (with-temp-buffer
                              (insert env)
                              (goto-char (point-min))
                              ;; \\ is used for a new line. Each one leads to a number
                              (cl-incf counter (count-matches "\\\\$"))
                              ;; unless there are nonumbers.
                              (goto-char (point-min))
                              (cl-decf counter (count-matches "\\nonumber")))))
                         (t
                          (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))
  
  (apply orig-fun args))

(advice-add 'org-create-formula-image :around #'org-renumber-environment)

#+end_src

*** Navigation
**** Line
***** org-end

#+begin_src emacs-lisp

(defun custom/org-end ()
  "Conditional end in Org Mode.

Default: `custom/end'

If `org-at-table-p', go to `org-table-end-of-field'."
  (cond ((and (region-active-p) (custom/org-relative-line-heading-folded)) (end-of-line))
        ((org-at-table-p)                                                  (org-table-end-of-field 1))
	   (t                                                                 (end-of-visual-line))))

(defvar custom/org-double-end-timeout 0.4)

(defun custom/org-double-end ()
  "Dynamic homing command with a timeout of `custom/org-double-end-timeout' seconds.
- Single press: `custom/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) custom/org-double-end-timeout)
	         (not (org-at-table-p)))
        (progn (beginning-of-visual-line) (end-of-line))
      (custom/org-end)))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-mode-map (kbd "<end>") 'custom/org-double-end)

#+end_src

***** TODO org-home

- home in invisible tags -> to beginning of tag text

#+begin_src emacs-lisp

(defun custom/org-home ()
     "Conditional homing in Org Mode.

Default: `custom/home'

If a multi-visual-line region is active and the cursor lies on a heading or
list item, home to `beginning-of-visual-line'.

If a region is active the cursor lies `custom/org-at-ellipsis-h', home to
`beginning-of-visual-line'.

If the cursor lies `custom/org-at-ellipsis-h' (no active region), home to
the `beginning-of-line-text' of the heading's visual line.

If the cursor lies on at heading or list, home to `beginning-of-line-text'.

If the cursor lies in a source code block, and the current line is a wrapped
visual line, home to `beginning-of-visual-line'.

If the cursor lies in a source code block, home `back-to-indentation'.

If `org-at-table-p', home to `org-table-beginning-of-field'."
   (interactive)
   (cond ((and (custom/region-multiline-visual) (custom/org-relative-line-heading-or-list))  (beginning-of-visual-line))
         ((and (region-active-p) (custom/org-at-ellipsis-h))                                 (beginning-of-visual-line))
         ((custom/org-at-ellipsis-h)                                                         (custom/org-goto-heading-bol))
	     ((custom/org-at-ellipsis-l)                                                         (custom/org-goto-heading-bol))
	     ((custom/relative-line-wrapped)                                                     (beginning-of-visual-line))
         ((custom/org-relative-line-heading-or-list)                                         (beginning-of-line-text))
         ((org-in-src-block-p)                                                               (back-to-indentation))
	     ((org-at-table-p)                                                                   (org-table-beginning-of-field 1))
         (t                                                                                  (custom/home))))

(defvar custom/org-double-home-timeout 0.4)

(defun custom/org-double-home ()
  "Dynamic homing command with a timeout of `custom/org-double-home-timeout' seconds.
- Single press: `custom/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) custom/org-double-home-timeout)
	         (not (org-at-table-p)))
	    (beginning-of-line)
      (custom/org-home)))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-mode-map (kbd "<home>") 'custom/org-double-home)

#+end_src 

***** org-previous-line

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "<up>") (lambda () (interactive) (custom/previous-line (org-in-src-block-p))))

#+end_src

**** Subtree
***** org-goto-child-last

#+begin_src emacs-lisp

(defun custom/org-goto-child-last ()
  (if (org-current-level)
      (progn (custom/org-goto-subtree-end)
	         (custom/org-goto-heading-current))))

#+end_src

***** org-goto-subtree-end

#+begin_src emacs-lisp

(defun custom/org-goto-subtree-end ()
  (custom/org-goto-heading-current)
  (org-end-of-subtree)
  (if (custom/org-relative-line-heading-folded) (end-of-visual-line)))

#+end_src

**** Heading
***** org-goto-heading-bol

#+begin_src emacs-lisp

(defun custom/org-goto-heading-bol ()
  (beginning-of-visual-line)
  (beginning-of-line-text))

#+end_src

***** org-goto-heading-next

#+begin_src emacs-lisp

(defun custom/org-goto-heading-next ()
  (custom/org-goto-heading-current)
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
       (org-forward-heading-same-level 1)
       (if (= pos (point))
	   (progn (custom/org-goto-heading-parent)
		  (org-forward-heading-same-level 1)))))

#+end_src

***** org-goto-heading-parent

#+begin_src emacs-lisp

(defun custom/org-goto-heading-parent ()
  (let ((current (custom/get-point 'beginning-of-visual-line)))
    (if (and (org-current-level)
	        (not (= 1 (org-current-level)))
		(= current (custom/get-point 'beginning-of-visual-line)))
	   (outline-up-heading 1))))

#+end_src

***** org-goto-heading-current

#+begin_src emacs-lisp

(defun custom/org-goto-heading-current ()
  (if (org-current-level) (outline-back-to-heading)))

#+end_src

***** org-goto-heading-previous

#+begin_src emacs-lisp

(defun custom/org-goto-heading-previous ()
  (custom/org-goto-heading-current)
  (let ((current (custom/get-point 'beginning-of-visual-line)))
    ;; go to previous same-level heading
    (org-backward-heading-same-level 1)
    ;; if there was no previous same-level heading, go to parent if not at top
    (if (= (point) current)
	    (custom/org-goto-heading-parent)
      ;; else, attempt going to last subheading of previous same-level heading
      (custom/org-goto-child-last))))

#+end_src
