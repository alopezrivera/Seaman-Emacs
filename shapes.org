# -*- mode: Org; org-use-property-inheritance: t -*-

#+STARTUP: overview
#+FILETAGS: :emacs:



#+title:Shapes
#+PROPERTY: header-args:emacs-lisp :results none :mkdirp yes



* Core
** Load
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/shapes-load.el
:END:

#+begin_src emacs-lisp

(defcustom shapes-debug-on-error t
  "Whether to enter the debugger if a shapes module, layer or
extension fails to load.")

(defun shapes-load (type component)
  "Load a shapes COMPONENT of the given TYPE"
  (condition-case err
      (require (intern (concat "shapes-" type "-" component)) (concat config-directory type "s" "/shapes-" component ".el"))
    (error (progn (message "ERROR: shapes-%s %s load failed" component type)
		     (if shapes-debug-on-error
		         (debug err))))))

;; shapes modules
(defun shapes-module (module)
  "Load a shapes MODULE by name"
  (shapes-load "module" module))

;; shapes layers
(defun shapes-layer (layer)
  "Load a shapes LAYER by name"
  (shapes-load "layer" layer))

;; shapes extensions
(defun shapes-extend (extension)
  "Load a shapes EXTENSION by name"
  (shapes-load "extension" extension))

#+end_src

** Extensions
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/shapes-extensions.el
:END:

#+begin_src emacs-lisp

(shapes-extend "get")
(shapes-extend "queries")
(shapes-extend "execution")
(shapes-extend "operators")

#+end_src

** Package manager
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/shapes-package-manager.el
:END:

#+begin_src emacs-lisp

(shapes-module "straight")
(shapes-module "use-package")

#+end_src

** Config management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./core/shapes-config-management.el
:END:
*** Tangling

#+begin_src emacs-lisp

(shapes-module "async")

(defun custom/shapes-tangle (org-file &optional quiet)
  "Asynchronously tangle an org file."
  (let ((init-tangle-start-time (current-time))
	(file (buffer-file-name))
	(async-quiet-switch "-q"))
    (async-start
     `(lambda ()
              (dolist (comp-dir (mapcar (lambda (dir) (concat ,config-directory dir)) '("core" "layers" "modules" "extensions")))
                (dolist (file (directory-files comp-dir t directory-files-no-dot-files-regexp))
                  (delete-file file)))
	      (require 'org)
	      (add-hook 'org-babel-post-tangle-hook
			(lambda ()
				(string-match "\\(^.*/\\)\\(.*\\)\\(/shapes-\\)\\(.*\\)\\(.el\\)" (buffer-file-name))
				(let ((component (match-string 4 (buffer-file-name)))
				      (comp-type (match-string 2 (buffer-file-name))))
				     (end-of-buffer)
				     (insert (concat
					      "\n"
					      "(provide 'shapes-" (if (string-match-p "^.*s" comp-type)
                                                                      (substring comp-type 0 -1)
                                                                    comp-type)
                                              "-" component ")\n"
					      ";;; shapes-" component ".el ends here"))
				     (save-buffer))))
		   (org-babel-tangle-file ,org-file))
     (unless quiet
       `(lambda (result)
		     (if result
			 (message "SUCCESS: %s successfully tangled (%.2fs)."
				  ,(file-name-nondirectory org-file)
				  (float-time (time-subtract (current-time)
							     ',init-tangle-start-time)))
		       (message "ERROR: %s tangling failed." ,org-file)))))))

(defun custom/shapes-tangle-auto ()
  "Automatically tangle Org Mode files in the Emacs config directory"
  (let* ((file   (expand-file-name buffer-file-name))
	 (source (string-match (concat config-directory ".*.org$") file))
	 (shapes (string-match (concat config-directory "shapes.org$") buffer-file-name))
	 (org-confirm-babel-evaluate nil))
    (if source
	(if shapes
	    (custom/shapes-tangle file)
	  (org-babel-tangle)))))

(add-hook 'after-save-hook #'custom/shapes-tangle-auto)

#+end_src

*** Littering

#+begin_src emacs-lisp

(shapes-module "no-littering")

#+end_src

*** Patching

#+begin_src emacs-lisp

(shapes-module "el-patch")

#+end_src

*** Execution

#+begin_src emacs-lisp

(global-set-key (kbd "C-x e") #'eval-buffer)

#+end_src

*** Inspection

#+begin_src emacs-lisp

(global-set-key (kbd "C-c SPC") #'whitespace-mode)

#+end_src

*** Debugging

#+begin_src emacs-lisp

(setq debug-on-error nil)

#+end_src


* Layers

Content of a layer:
- Settings
- Built-in modes
- Modules
- Extensions
- Bindings

** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-ui.el
:END:
*** Text
**** Typefaces

#+begin_src emacs-lisp

;; icons
(shapes-module "all-the-icons")

#+end_src

**** Highlights

#+begin_src emacs-lisp

;; highlights
(shapes-module "rainbow-mode")

#+end_src

*** Buffer

#+begin_src emacs-lisp

;; centering
(shapes-module "olivetti")

;; line numbers
(global-set-key (kbd "C-c l") #'display-line-numbers-mode)

#+end_src

*** Frame

#+begin_src emacs-lisp

;; size
(add-to-list 'default-frame-alist '(height . 50))
(add-to-list 'default-frame-alist '(width  . 70))

;; tabs
(tab-bar-mode -1)
;; scroll bar
(scroll-bar-mode -1)
;; toolbar
(tool-bar-mode -1)
;; tooltips
(tooltip-mode -1)
;; menu bar
(menu-bar-mode -1)

;; title
(setq-default frame-title-format '("%b"))

#+end_src

*** Window

#+begin_src emacs-lisp

;; fringes
(set-fringe-mode nil)

;; balance
(global-set-key (kbd "C-x -") #'balance-windows)

;; split threshold
(setq split-width-threshold 70)

#+end_src

*** Warnings

#+begin_src emacs-lisp

;; visible bell
(setq visible-bell t)

#+end_src

*** Mode line

#+begin_src emacs-lisp

;; time
(display-time-mode t)

;; column numbers
(column-number-mode)

;; mode display
(shapes-module "delight")

#+end_src

*** Dashboard

#+begin_src emacs-lisp

;; requirements
(shapes-module "projectile")
(shapes-module "all-the-icons")
(shapes-module "page-break-lines")

;; dashboard
(shapes-module "emacs-dashboard")

#+end_src

*** Extensions

#+begin_src emacs-lisp

;; extensions
(shapes-extend "ui")

#+end_src

** Themes
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-themes.el
:END:

Shapes themes layer. It requires three variables to be defined: the light and dark themes (~light~ and ~dark~ respectively), and the mode line of choice (~modeline~).

#+begin_src emacs-lisp

(defcustom light 'modus-operandi
  "Light theme")
(defcustom dark  'modus-vivendi
  "Dark theme")

;; creation
(shapes-module "autothemer")

;; theme bundles
(shapes-module "ef-themes")
(shapes-module "nano-theme")
(shapes-module "doom-themes")
(shapes-module "modus-themes")
(shapes-module "solarized-theme")
(shapes-module "catppuccin-themes")
;; standalone themes
(shapes-module "sweet-theme")
(shapes-module "graphite-theme")
(shapes-module "chocolate-theme")

;; extensions
(shapes-extend "theme-switch")

;; scheduling
(shapes-module "circadian")

#+end_src

** Mode line
*** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-modeline-doom.el
:END:

#+begin_src emacs-lisp

;; modules
(shapes-module "doom-modeline")

;; extensions
(shapes-extend "theme-modeline")

#+end_src

*** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-modeline-nano.el
:END:

#+begin_src emacs-lisp

;; modules
(shapes-module "nano-modeline")

;; extensions
(shapes-extend "theme-modeline")

#+end_src

*** Moody
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-modeline-moody.el
:END:

#+begin_src emacs-lisp

(shapes-module "moody")

;; modeline height
(setq moody-mode-line-height 22)

;; adjust modeline elements to enable moody
(let ((line (face-attribute 'mode-line :underline)))
  (set-face-attribute 'mode-line          nil :overline   line)
  (set-face-attribute 'mode-line-inactive nil :overline   line)
  (set-face-attribute 'mode-line-inactive nil :underline  line)
  (set-face-attribute 'mode-line          nil :box        nil)
  (set-face-attribute 'mode-line-inactive nil :box        nil))

;; extensions
(shapes-extend "theme-modeline")

#+end_src

*** Spaceline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-modeline-spaceline.el
:END:

#+begin_src emacs-lisp

;; modules
(shapes-module "spaceline")

#+end_src


** Input
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-input.el
:END:

#+begin_src emacs-lisp

;; bindings
(global-set-key (kbd "C-=") #'save-buffer)

;; confirmation
(advice-add 'yes-or-no-p :override #'y-or-n-p)
;; advanced commands
(put 'narrow-to-region 'disabled nil)

;; modules
(shapes-module "evil")
(shapes-module "god-mode")

#+end_src

** Completion
*** ivy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-completion-ivy.el
:END:

#+begin_src emacs-lisp

(shapes-module "ivy")

#+end_src

*** vertico
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-completion-vertico.el
:END:

#+begin_src emacs-lisp

(shapes-module "vertico")
(shapes-module "orderless")

;; icons
(shapes-module "all-the-icons")
(shapes-module "all-the-icons-completion")

#+end_src
** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-navigation.el
:END:

#+begin_src emacs-lisp

;; scrolling
(pixel-scroll-precision-mode)
(setq auto-window-vscroll nil)
(setq mouse-wheel-progressive-speed nil)

;; windows
(winner-mode)

;; modules
(shapes-module "ace-window")

;; extensions
(shapes-extend "navigation")

;; bindings
(global-set-key (kbd "C-S-n") #'make-frame-command)

#+end_src


** Search
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-search.el
:END:

#+begin_src emacs-lisp

;; modules
(shapes-module "swiper")
(shapes-module "rg")

;; extensions
(shapes-extend "search")

#+end_src

** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-editing.el
:END:

#+begin_src emacs-lisp

;; settings
(setq-default indent-tabs-mode nil)

;; built-ins
(global-so-long-mode 1)

;; modules
(shapes-module "vundo")
(shapes-module "multiple-cursors")

;; extensions
(shapes-extend "editing")

#+end_src

** Workflow
*** Session
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-session.el
:END:

#+begin_src emacs-lisp

;; built-ins
(desktop-save-mode 1)

;; modules
(shapes-module "workgroups")

;; extensions
(shapes-extend "session")
(shapes-extend "external-programs")

#+end_src 

*** Project interaction
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-project-interaction.el
:END:

#+begin_src emacs-lisp

;; modules
(shapes-module "projectile")
(shapes-module "treemacs")

#+end_src
a

** Version control
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-version-control.el
:END:

#+begin_src emacs-lisp

(shapes-module "magit")
(shapes-module "forge")

#+end_src

** File management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-file-management.el
:END:

~backup-directory-alist~, which determines where backups are saved, is set by ~no-littering~.

#+begin_src emacs-lisp

;; buffer backups
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 2)
(setq kept-old-versions 2)

;; file manager
(shapes-module "dirvish")

;; extensions
(shapes-extend "file-management")

#+end_src


** IDE
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-ide.el
:END:

#+begin_src emacs-lisp

;; remove duplicates in shell history
(setq comint-input-ignoredups t)
;; indentation
(setq-default c-basic-offset 4)

;; outline
(shapes-module "hideshow")
;; editing
(shapes-module "puni")
(shapes-module "embrace")
;; completion
(shapes-module "company")
;; syntax checking
(shapes-module "flycheck")
;; language server protocol
(shapes-module "lsp-mode")

;; lisp
(shapes-module "rainbow-delimiters")
;; python
(shapes-module "elpy")
;; rust
(shapes-module "rustic")

#+end_src

** PDF
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-pdf.el
:END:

#+begin_src emacs-lisp

;; settings
(setq doc-view-resolution 250)

;; requirements
(shapes-module "tablist")

;; modules
(shapes-module "pdf-tools")
(shapes-module "pdf-view-restore")

;; extensions
(shapes-extend "pdf")

#+end_src

** LaTeX
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-latex.el
:END:

#+begin_src emacs-lisp

(add-hook 'latex-mode-hook (lambda () (visual-line-mode nil)))

#+end_src

** Org Mode
*** org
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-org.el
:END:

#+begin_src emacs-lisp

;; bindings
(global-set-key (kbd "C-x c") #'org-capture)

;; always use property inheritance
(setq-default org-use-property-inheritance t)

;; dependencies
(shapes-layer  "editing")

;; org
(shapes-module "org")

;; editing
(shapes-module "org-paragraph")
(shapes-module "org-download")

;; templates
(shapes-module "org-tempo")
(shapes-module "org-capture")

;; agenda - IMPORTANT: LOAD BEFORE org-roam
(shapes-module "org-agenda")
(shapes-module "org-contacts")
(shapes-module "org-calendar")

;; notes
(shapes-module "bitacora")
(shapes-module "org-roam")

;; presentations
(shapes-module "org-reveal")

;; programming
(shapes-module "org-babel")

;; extensions
(shapes-extend "org-get")
(shapes-extend "org-queries")
(shapes-extend "org-editing")
(shapes-extend "org-ui")
(shapes-extend "org-outline")
(shapes-extend "org-navigation")
(shapes-extend "org-applications")

#+end_src

*** org-ui
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-org-ui.el
:END:

#+begin_src emacs-lisp

;; org-indent-mode
(setq org-startup-indented nil)
;; list indentation
(setq-default org-list-indent-offset 1)
;; startup with inline images
(setq org-startup-with-inline-images t)
;; do not force inline images to their actual width
(setq org-image-actual-width nil)
;; do not consider empty lines content
(setq org-cycle-separator-lines 2)

;; line wrapping
(add-hook 'org-mode-hook (lambda () (progn (visual-line-mode 1) (setq line-move-visual t))))

;; design
(shapes-module "org-modern")
(setq org-modern-table        nil)
(setq org-modern-block-fringe nil)

;; markup
(shapes-module "org-appear")

#+end_src

*** org-agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-org-agenda.el
:END:
**** Files

#+begin_src emacs-lisp

(let ((files org-agenda-files))
  (dolist (file files)
    (if (not (file-exists-p file))
        (progn (setq org-agenda-files (remove file files))
               (print (concat "WARNING: ignoring nonexistent agenda file: " file))))))

#+end_src

**** Tags

#+begin_src emacs-lisp

(setq org-tag-alist
      '((:startgroup)
	;; Put mutually exclusive tags here
	(:endgroup)
	("home"     . ?h)
	("work"     . ?w)))

#+end_src

**** Views

#+begin_src emacs-lisp

;; Configure custom agenda views
(setq org-agenda-custom-commands
      '(("d" "Dashboard"
	 ((agenda "" ((org-deadline-warning-days 7)))
	  (todo "NEXT" ((org-agenda-overriding-header "Next Tasks")))
	  (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

	("n" "Next Tasks"
	 ((todo "NEXT" ((org-agenda-overriding-header "Next Tasks")))))

	("w" "Work Tasks" tags-todo "work")

	("e" "Emacs Tasks" tags-todo "emacs")

	("z" "Low Effort" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
	 ((org-agenda-overriding-header "Low Effort Tasks")
	  (org-agenda-max-todos 20)
	  (org-agenda-files org-agenda-files)))

	("s" "Workflow Status"
	 ((todo "WAIT"
		((org-agenda-overriding-header "Waiting on External")
		 (org-agenda-files org-agenda-files)))
	  (todo "REVIEW"
		((org-agenda-overriding-header "In Review")
		 (org-agenda-files org-agenda-files)))
	  (todo "PLAN"
		((org-agenda-overriding-header "In Planning")
		 (org-agenda-todo-list-sublevels nil)
		 (org-agenda-files org-agenda-files)))
	  (todo "BACKLOG"
		((org-agenda-overriding-header "Project Backlog")
		 (org-agenda-todo-list-sublevels nil)
		 (org-agenda-files org-agenda-files)))
	  (todo "READY"
		((org-agenda-overriding-header "Ready for Work")
		 (org-agenda-files org-agenda-files)))
	  (todo "ACTIVE"
		((org-agenda-overriding-header "Active Projects")
		 (org-agenda-files org-agenda-files)))
	  (todo "COMPLETED"
		((org-agenda-overriding-header "Completed Projects")
		 (org-agenda-files org-agenda-files)))
	  (todo "CANC"
		((org-agenda-overriding-header "Cancelled Projects")
		 (org-agenda-files org-agenda-files)))))))

#+end_src

**** Keywords

#+begin_src emacs-lisp

;; Define TODO keyword sequences
(setq org-todo-keywords
      '((sequence "TODO(t)" "NEXT(n)" "WAIT(w@/!)" "|" "DONE(d!)")
	(sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(r)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

#+end_src

*** org-typesetting
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-org-typesetting.el
:END:
**** Text
***** Typefaces
****** Body

#+begin_src emacs-lisp

(defun custom/org-typefaces-body ()
  (with-eval-after-load 'org-faces

    ;; Code
    (set-face-attribute 'org-block                 nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-code                  nil :inherit '(shadow fixed-pitch))
    (set-face-attribute 'org-verbatim              nil :inherit '(shadow fixed-pitch))

    ;; Tables
    (set-face-attribute 'org-table                 nil :inherit '(shadow fixed-pitch))

    ;; Lists
    (set-face-attribute 'org-checkbox              nil :inherit 'fixed-pitch)

    ;; Meta
    (set-face-attribute 'org-meta-line             nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info         nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-document-info-keyword nil :inherit 'fixed-pitch)
    (set-face-attribute 'org-special-keyword       nil :inherit 'fixed-pitch)))

(add-hook 'org-mode-hook #'custom/org-typefaces-body)

#+end_src

****** Heading

#+begin_src emacs-lisp

;; use levels 1 through 8
(setq org-n-level-faces 8)

;; do not cycle header style after 8th level
(setq org-cycle-level-faces nil)

;; hide leading stars
(setq org-hide-leading-starts t)

;; font sizes
(defun custom/org-heading-typefaces () 
  (with-eval-after-load 'org-faces
    (dolist (face '((org-level-1 . 1.175)
                    (org-level-2 . 1.175)
                    (org-level-3 . 1.175)
                    (org-level-4 . 1.175)
                    (org-level-5 . 1.175)
                    (org-level-6 . 1.175)
                    (org-level-7 . 1.175)
                    (org-level-8 . 1.175)))
         (set-face-attribute (car face) nil :font typeface-heading :weight 'bold :height (cdr face)))))

(add-hook 'org-mode-hook #'custom/org-heading-typefaces)

#+end_src

***** Pretty entities

#+begin_src emacs-lisp

;; symbols, super- and subscripts
(setq org-pretty-entities nil)

#+end_src

**** Icons
***** Ellipses

Candidates:
- triangles
  ▼
  ▾
  ▿
- rhomboids
  ⬙
  ⟡
  ⬥
  ♦
  ♢
- non-compliant
  ⧨
  
-----

#+begin_src emacs-lisp

;; Change ellipsis ("...") to remove clutter
(setq org-ellipsis " ♢")

#+end_src

*** org-latex-preview
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./layers/shapes-org-latex-preview.el
:END:

#+begin_src emacs-lisp

(shapes-module "org-fragtog")

#+end_src

**** TODO Options

- mail bug in

Importantly, ~modus-vivendi~ will not behave correctly with
the default ~org-format-latex-options~, with LaTeX previews
displaying as white boxes. [[https://debbugs.gnu.org/db/52/52277.html][This has been previously reported]].

~org-format-latex-options~ has ~:foreground~ and ~:background~
attributes. These may be assigned to

- a color,
- ~default~, instructing Org Mode to determine ~:foreground~ or
  ~:background~ from the foreground or background color of the
  default face, or
- ~auto~, doing the same for the text face.

By default, the ~:foreground~ and ~:background~ in ~org-format-latex-options~
are set to ~default~. With default settings, changing the color
of the ~default~ font has the following effects on the LaTeX preview SVGs:

- modus-operandi
   - ~default :foreground~: text color
   - ~default :background~: no effect
- modus-vivendi
   - ~default :foreground~: background color
   - ~default :background~: no effect

By eliminating the ~:background~ attribute from ~org-format-latex-options~
the issue is resolved.

1. ~modus-operandi~ does not suffer from this issue nor do various
   other themes. This makes me believe the issue lies with
   ~modus-vivendi~ itself.
2. However, the ~:background~ attribute in ~org-format-latex-options~
   seems to have no effect, a potential bug in Org Mode

#+begin_src emacs-lisp

(setq org-format-latex-options
        (list :foreground 'default
              :scale       1.000))

#+end_src

**** Header

#+begin_src emacs-lisp

(setq custom/org-latex-preview-class-args "fleqn")
(setq custom/org-latex-preview-width      "18cm")

(setq org-format-latex-header
      (string-join `("\\documentclass[" ,custom/org-latex-preview-class-args "]{article}"
		         "\\usepackage[usenames]{color}"
			
			 "\\usepackage{bm}"
			
			 "\\pagestyle{empty}"
			 "\\setlength{\\textwidth}{" ,custom/org-latex-preview-width "}"
			 "\\addtolength{\\textwidth}{-3cm}"
			 "\\setlength{\\oddsidemargin}{1.5cm}"
			 "\\addtolength{\\oddsidemargin}{-2.54cm}"
			 "\\setlength{\\evensidemargin}{\\oddsidemargin}"
			 "\\setlength{\\textheight}{\\paperheight}"
			 "\\addtolength{\\textheight}{-\\headheight}"
			 "\\addtolength{\\textheight}{-\\headsep}"
			 "\\addtolength{\\textheight}{-\\footskip}"
			 "\\addtolength{\\textheight}{-3cm}"
			 "\\setlength{\\topmargin}{1.5cm}"
			 "\\addtolength{\\topmargin}{-2.54cm}")
		   "\n"))

#+end_src

**** Equation preview format

#+begin_src emacs-lisp

;; SVG LaTeX equation preview
(setq org-latex-create-formula-image-program 'dvisvgm)

#+end_src

**** Equation preview directory

#+begin_src emacs-lisp

;; theme-specific LaTeX preview directory
(defun custom/latex-preview-directory ()
  "Set `org-preview-latex-image-directory' to the SVG
LaTeX preview directory of the current theme"
  (setq org-preview-latex-image-directory
   (concat "/tmp/ltximg/" (custom/get-active-theme) "/")))

#+end_src

**** Equation preview reload hook

#+begin_src emacs-lisp

(defun custom/latex-preview-reload ()
  "Reload all LaTeX previews in buffer,
ensuring the LaTeX preview directory
matches the current theme."
  (if (string-equal major-mode "org-mode")
      (progn (org-latex-preview '(64))
	        (custom/latex-preview-directory)
		(org-latex-preview '(16)))))

(add-hook 'org-mode-hook #'custom/latex-preview-reload)

#+end_src


* Modules

Content of a module:
- Package installation
- Package setup

** Infrastructure
*** Package management
**** straight
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-straight.el
:END:

#+begin_src emacs-lisp

;; straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

**** use-package
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-use-package.el
:END:

#+begin_src emacs-lisp

;; use-package
(straight-use-package 'use-package)

;; fall back to straight.el
(setq straight-use-package-by-default t)

#+end_src

*** Config management
**** Async
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-async.el
:END:

#+begin_src emacs-lisp

;; async
(straight-use-package 'async)
(require 'async)

#+end_src

**** Littering
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-no-littering.el
:END:

#+begin_src emacs-lisp

;; no-littering
(straight-use-package 'no-littering)
(require 'no-littering)

#+end_src

**** Patching
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-el-patch.el
:END:

#+begin_src emacs-lisp

;; el-patch
(straight-use-package 'el-patch)
(require 'el-patch)

#+end_src


** UI
*** Home
**** emacs-dashboard
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-emacs-dashboard.el
:END:

#+begin_src emacs-lisp

;; requirements
(require 'projectile)
(require 'all-the-icons)
(require 'page-break-lines)

(straight-use-package 'dashboard)
(require 'dashboard)

(dashboard-setup-startup-hook)

;; options
(setq dashboard-center-content t)
(setq dashboard-set-file-icons t)

;; initial buffer choice
(if (and (not initial-buffer-choice)
         (string-equal (buffer-name (current-buffer)) "*scratch*"))
    (setq initial-buffer-choice (lambda () (get-buffer "*dashboard*"))))

#+end_src

*** Buffer
**** olivetti
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-olivetti.el
:END:

#+begin_src emacs-lisp

;; centering
(straight-use-package 'olivetti)

(add-hook 'olivetti-mode-on-hook (lambda () (olivetti-set-width 0.9)))

;; normal modes
(dolist (mode '(org-mode-hook
		     shell-mode-hook
		     markdown-mode-hook
                latex-mode-hook))
  (add-hook mode 'olivetti-mode))

;; Programming modes
(add-hook 'prog-mode-hook 'olivetti-mode)

#+end_src

***** Patches

#+begin_src emacs-lisp

(require 'el-patch)

#+end_src

****** olivetti-set-width

#+begin_src emacs-lisp

(el-patch-feature olivetti)
(el-patch-defun olivetti-set-width (width)
  "Set text body width to WIDTH with relative margins.
WIDTH may be an integer specifying columns or a float specifying
a fraction of the window width."
  (interactive
   (list (if current-prefix-arg
             (prefix-numeric-value current-prefix-arg)
           (read-number "Set text body width (integer or float): "
                        olivetti-body-width))))
  (setq olivetti-body-width width)
  (olivetti-set-buffer-windows)
  (el-patch-remove (message "Text body width set to %s" olivetti-body-width)))

#+end_src

**** solaire-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-solaire-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'solaire-mode)
(require 'solaire-mode)

#+end_src

**** page-break-lines
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-page-break-lines.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'page-break-lines)
(require 'page-break-lines)

#+end_src

*** Mode line
**** delight
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-delight.el
:END:

#+begin_src emacs-lisp

;; Customize names displayed in mode line
(straight-use-package 'delight)
(require 'delight)

;; Remove default modes from mode line
(delight '((global-command-log-mode nil "")
	   (olivetti-mode           nil "")
	   (which-key-mode          nil "")
	   (visual-line-mode        nil "simple")
	   (buffer-face-mode        nil "simple")
	   (org-indent-mode         nil "org")
	   (eldoc-mode              nil "eldoc")
	   ;; Major modes
	   (emacs-lisp-mode "EL" :major)))

#+end_src

*** Typefaces
**** all-the-icons
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-all-the-icons.el
:END:

#+begin_src emacs-lisp

;; Symbol library
(straight-use-package 'all-the-icons)

#+end_src

Now that ~all-the-icons~ is installed, all the icon typefaces must be actually present in
the local machine:

#+begin_src emacs-lisp :tangle no

(all-the-icons-install-fonts)

#+end_src

*** Highlights
**** svg-tag-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-svg-tag-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'svg-tag-mode)
(require 'svg-tag-mode)

(defconst date-re "[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}")
(defconst time-re "[0-9]\\{2\\}:[0-9]\\{2\\}")
(defconst day-re "[A-Za-z]\\{3\\}")
(defconst day-time-re (format "\\(%s\\)? ?\\(%s\\)?" day-re time-re))

(defun svg-progress-percent (value)
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ (string-to-number value) 100.0)
                                    nil :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag (concat value "%")
                           nil :stroke 0 :margin 0)) :ascent 'center))

(defun svg-progress-count (value)
  (let* ((seq (mapcar #'string-to-number (split-string value "/")))
         (count (float (car seq)))
         (total (float (cadr seq))))
  (svg-image (svg-lib-concat
              (svg-lib-progress-bar (/ count total) nil
                                    :margin 0 :stroke 2 :radius 3 :padding 2 :width 11)
              (svg-lib-tag value nil
                           :stroke 0 :margin 0)) :ascent 'center)))

(setq svg-tag-tags
      `(
        ;; Org tags
        (":\\([A-Za-z0-9]+\\)" . ((lambda (tag) (svg-tag-make tag))))
        (":\\([A-Za-z0-9]+[ \-]\\)" . ((lambda (tag) tag)))
        
        ;; Task priority
        ("\\[#[A-Z]\\]" . ( (lambda (tag)
                              (svg-tag-make tag :face 'org-priority 
                                            :beg 2 :end -1 :margin 0))))

        ;; Progress
        ("\\(\\[[0-9]\\{1,3\\}%\\]\\)" . ((lambda (tag) (svg-progress-percent (substring tag 1 -2)))))
        ("\\(\\[[0-9]+/[0-9]+\\]\\)"   . ((lambda (tag) (svg-progress-count (substring tag 1 -1)))))
        
        ;; TODO / DONE
        ("TODO" . ((lambda (tag) (svg-tag-make "TODO" :face 'org-todo :inverse t :margin 0))))
        ("DONE" . ((lambda (tag) (svg-tag-make "DONE" :face 'org-done :margin 0))))


        ;; Citation of the form [cite:@Knuth:1984]
        ("\\(\\[cite:@[A-Za-z]+:\\)" . ((lambda (tag)
                                          (svg-tag-make tag
                                                        :inverse t
                                                        :beg 7 :end -1
                                                        :crop-right t))))
        ("\\[cite:@[A-Za-z]+:\\([0-9]+\\]\\)" . ((lambda (tag)
                                                (svg-tag-make tag
                                                              :end -1
                                                              :crop-left t))))
        
        ;; Active date (with or without day name, with or without time)
        (,(format "\\(<%s>\\)" date-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :end -1 :margin 0))))
        (,(format "\\(<%s \\)%s>" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0))))
        (,(format "<%s \\(%s>\\)" date-re day-time-re) .
         ((lambda (tag)
            (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0))))

        ;; Inactive date  (with or without day name, with or without time)
         (,(format "\\(\\[%s\\]\\)" date-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :end -1 :margin 0 :face 'org-date))))
         (,(format "\\(\\[%s \\)%s\\]" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :beg 1 :inverse nil :crop-right t :margin 0 :face 'org-date))))
         (,(format "\\[%s \\(%s\\]\\)" date-re day-time-re) .
          ((lambda (tag)
             (svg-tag-make tag :end -1 :inverse t :crop-left t :margin 0 :face 'org-date))))))

#+end_src

**** rainbow-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-rainbow-mode.el
:END:

#+begin_src emacs-lisp

;; highlight HTML color strings in their own color
(straight-use-package 'rainbow-mode)

#+end_src

*** Completion
**** all-the-icons-completion
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-all-the-icons-completion.el
:END:

#+begin_src emacs-lisp

(require 'all-the-icons)

(straight-use-package '(all-the-icons-completion :type git :host github :repo "MintSoup/all-the-icons-completion"))

(all-the-icons-completion-mode)

#+end_src

** Themes
*** Themes
**** Ef
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-ef-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(ef-themes :type git :host nil :repo "https://git.sr.ht/~protesilaos/ef-themes"))
(require 'ef-themes)

#+end_src

**** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-nano-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'nano-theme)
(require 'nano-theme)

;; always use load-theme + enable-theme for the nano themes
(advice-add 'enable-theme :around (lambda (orig-fun THEME) (if (string-match "^nano-.*" (symbol-name THEME))
                                                               (progn (load-theme THEME t t)
                                                                      (funcall orig-fun THEME))
                                                             (funcall orig-fun THEME))))

#+end_src

**** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-doom-themes.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'doom-themes)
(require 'doom-themes)

#+end_src

**** Modus
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-modus-themes.el
:END:

#+begin_src emacs-lisp

(setq modus-themes-headings
      '((0 . (monochrome))))

(straight-use-package 'modus-themes)
(modus-themes-load-themes)

#+end_src

**** Catpuccin
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-catppuccin-themes.el
:END:

#+begin_src emacs-lisp

(require 'autothemer)

(cl-flet ((repo (name) (concat config-directory "straight/repos/" name)))
  ;; install and rename repository directory to "catppuccin-themes"
  (if (not (file-exists-p (repo "catppuccin-themes/catppuccin-theme.el")))
      (progn (straight-use-package '(catppuccin-themes :type git :host github :repo "catppuccin/emacs"))
             (copy-directory (repo "emacs")
                             (repo "catppuccin-themes"))
             (delete-directory (repo "emacs") t)))
  (require 'catppuccin-theme           (repo "catppuccin-themes/catppuccin-theme.el"))
  (require 'catppuccin-frappe-theme    (repo "catppuccin-themes/catppuccin-frappe-theme.el"))
  (require 'catppuccin-latte-theme     (repo "catppuccin-themes/catppuccin-latte-theme.el"))
  (require 'catppuccin-mocha-theme     (repo "catppuccin-themes/catppuccin-mocha-theme.el"))
  (require 'catppuccin-macchiato-theme (repo "catppuccin-themes/catppuccin-macchiato-theme.el")))

#+end_src

**** Solarized
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-solarized-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'solarized-theme)
(require 'solarized-theme)

#+end_src

**** Standalone
***** Sweet
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-sweet-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'sweet-theme)
(require 'sweet-theme)

#+end_src

***** Graphite
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-graphite-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(graphite-theme :type git :host github :repo "codemicmaves/graphite-theme"))
(require 'graphite-light-theme)
(require 'graphite-dark-theme)

#+end_src

***** Chocolate
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-chocolate-theme.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'chocolate-theme)
(require 'chocolate-theme)

#+end_src

***** Doom Zen Writer
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-doom-zen-writer-theme.el
:END:

#+begin_src emacs-lisp

(load-file (concat config-directory "local/themes/doom-zen-writer-theme.el"))

#+end_src

*** Creation
**** autothemer
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-autothemer.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'autothemer)
(require 'autothemer)

#+end_src

*** Scheduling
**** circadian
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-circadian.el
:END:

#+begin_src emacs-lisp

(setq calendar-latitude      52.00667)
(setq calendar-longitude     4.355561)
(setq calendar-loadtion-name "Delft")
(setq calendar-standard-time-zone-name "CEST")
(setq calendar-daylight-time-zone-name "CET")

(straight-use-package 'circadian)
(setq circadian-themes `((:sunrise . ,light)  
			 (:sunset  . ,dark)))
(circadian-setup)

#+end_src

** Mode line
*** Nano
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-nano-modeline.el
:END:

#+begin_src emacs-lisp

;; nano-modeline
(straight-use-package 'nano-modeline)

;; mode line initialization hook
(add-hook 'after-init-hook #'nano-modeline-mode)

#+end_src

*** Doom
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-doom-modeline.el
:END:

#+begin_src emacs-lisp

;; doom-modeline
(straight-use-package 'doom-modeline)

;; bar
(setq-default doom-modeline-bar-width 0.01)

;; mode line initialization hook
(add-hook 'after-init-hook #'doom-modeline-mode)

#+end_src

*** Moody
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-moody.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'moody)

;; configuration
(setq x-underline-at-descent-line t)
(moody-replace-mode-line-buffer-identification)
(moody-replace-vc-mode)
(moody-replace-eldoc-minibuffer-message-function)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src

*** Spaceline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-spaceline.el
:END:

#+begin_src emacs-lisp

;; spaceline
(straight-use-package 'spaceline)
(require 'spaceline-config)

;; mode line initialization hook
(add-hook 'after-init-hook #'spaceline-emacs-theme)

#+end_src


** Input
*** Editing
**** evil
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-evil.el
:END:

#+begin_src emacs-lisp

;; evil
(straight-use-package 'evil)
(require 'evil)

;; bindings
(global-set-key (kbd "C-<escape>") #'evil-mode)

#+end_src

***** bugs

#+begin_src emacs-lisp

;; eliminate blinking cursor in pdf-pdf-view
(add-hook 'pdf-view-mode-hook (lambda ()
                                (set (make-local-variable 
                                      'evil-emacs-state-cursor)
                                     (list nil))))

#+end_src

***** states
****** evil-god

#+begin_src emacs-lisp

;; evil god state
(straight-use-package 'evil-god-state)
(require 'evil-god-state)

(evil-define-key 'normal global-map (kbd ",") #'evil-execute-in-god-state)

(evil-define-key 'god    global-map (kbd "<escape>") #'evil-god-state-bail)

;; mode indicators
(setq evil-normal-state-tag   (propertize " COMMAND " 'face '((:background "dark khaki"     :foreground "black")))
      evil-emacs-state-tag    (propertize "  EMACS  " 'face '((:background "turquoise"      :foreground "black")))
      evil-insert-state-tag   (propertize " ------- " 'face '((:background "dark sea green" :foreground "black")))
      evil-replace-state-tag  (propertize " REPLACE " 'face '((:background "dark orange"    :foreground "black")))
      evil-motion-state-tag   (propertize "  MOTION " 'face '((:background "khaki"          :foreground "black")))
      evil-visual-state-tag   (propertize "  VISUAL " 'face '((:background "light salmon"   :foreground "black")))
      evil-operator-state-tag (propertize " OPERATE " 'face '((:background "sandy brown"    :foreground "black"))))

(setq evil-default-cursor (quote (t "#750000"))
      evil-visual-state-cursor '("green" hollow)
      evil-normal-state-cursor '("green" box)
      evil-insert-state-cursor '("pink" (bar . 2)))

#+end_src

****** evil-org

#+begin_src emacs-lisp

(with-eval-after-load 'org
  (straight-use-package 'evil-org)
  (require 'evil-org)
  (evil-org-set-key-theme '(navigation insert textobjects additional calendar))

  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)

  ;; hooks
  (add-hook 'org-mode-hook  (lambda () (if evil-mode (evil-org-mode))))
  (add-hook 'evil-mode-hook (lambda () (if (string-equal major-mode "org-mode") (evil-org-mode)))))

#+end_src

**** meow
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-meow.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'meow)
(require 'meow)

#+end_src

***** setup

#+begin_src emacs-lisp

(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty)
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . meow-undo-in-selection)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)))

#+end_src

***** load

#+begin_src emacs-lisp

(meow-setup)
(meow-global-mode 1)

#+end_src

*** Commands
**** god-mode
:PROPERTIES:
:header-args: emacs-lisp :tangle ./modules/shapes-god-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'god-mode)
(require 'god-mode)

;; god
(global-set-key (kbd "<escape>") #'god-mode-all)

;; local
(define-key god-local-mode-map (kbd "i") #'god-local-mode)

;; bindings
(define-key god-local-mode-map (kbd ".") #'repeat)
(define-key god-local-mode-map (kbd "]") #'forward-paragraph)
(define-key god-local-mode-map (kbd "[") #'backward-paragraph)

#+end_src

** Guidance
*** counsel
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-counsel.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'counsel)
(require 'counsel)

(global-set-key (kbd "<menu>") #'counsel-M-x)

#+end_src

*** helpful
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-helpful.el
:END:

#+begin_src emacs-lisp

;; replace description key bindings by their helpful equivalents
(straight-use-package 'helpful)

(setq counsel-describe-function-function  #'helpful-callable)
(setq counsel-describe-variable-function  #'helpful-variable)

(global-set-key [remap describe-function] #'helpful-function)
(global-set-key [remap describe-command]  #'helpful-command)
(global-set-key [remap describe-variable] #'helpful-variable)
(global-set-key [remap describe-key]      #'helpful-key)

#+end_src

*** which-key
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-which-key.el
:END:

#+begin_src emacs-lisp

;; command suggestions
(straight-use-package 'which-key)
(require 'which-key)

(setq which-key-idle-delay 1.0)

(which-key-mode)

#+end_src

*** command-log-mode                                                  :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-command-log-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'command-log-mode)
(require 'command-log-mode)

(global-command-log-mode)

#+end_src

** Completion
*** ivy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-ivy.el
:END:

#+begin_src emacs-lisp

;; ivy
(straight-use-package 'ivy)
(require 'ivy)

(ivy-mode 1)

;; minibuffer bindings
(let ((map ivy-minibuffer-map))
  (cl-loop for binding in '(("<tab>"       . ivy-alt-done)
			    ("<up>"        . ivy-previous-line-or-history)
			    ("C-l"         . ivy-alt-done)
			    ("C-j"         . ivy-next-line)
			    ("C-k"         . ivy-previous-line)
			    ("<backspace>" . ivy-backward-delete-char))
            do (define-key map (kbd (car binding)) (cdr binding))))

;; switch-buffer bindings
(let ((map ivy-switch-buffer-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
 			        ("C-l"   . ivy-done)
			        ("C-d"   . ivy-switch-buffer-kill))
            do (define-key map (kbd (car binding)) (cdr binding))))

;; reverse-i-search bindings
(let ((map ivy-reverse-i-search-map))
  (cl-loop for binding in '(("C-k"   . ivy-previous-line)
			        ("C-d"   . ivy-reverse-i-search-kill))
            do (define-key map (kbd (car binding)) (cdr binding))))

#+end_src

*** ivy-rich                                                          :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-ivy-rich.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'ivy-rich)
(require 'ivy-rich)

(ivy-rich-mode 1)

#+end_src

*** vertico
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-vertico.el
:END:

#+begin_src emacs-lisp

(require 'savehist)
(savehist-mode)

(straight-use-package 'vertico)
(vertico-mode)

(defun crm-indicator (args)
  (cons (format "[CRM%s] %s"
                (replace-regexp-in-string
                 "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                 crm-separator)
                (car args))
        (cdr args)))
(advice-add 'completing-read-multiple :filter-args #'crm-indicator)

(setq minibuffer-prompt-properties
      '(read-only t cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)

(setq enable-recursive-minibuffers t)

#+end_src

*** orderless
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-orderless.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'orderless)

(setq completion-styles '(orderless basic))
(setq completion-category-defaults nil)
(setq completion-category-overrides '((file (styles partial-completion))))

#+end_src

** Navigation
*** ace-window
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-ace-window.el
:END:

#+begin_src emacs-lisp

;; ace-window
(straight-use-package 'ace-window)
(require 'ace-window)

(global-set-key (kbd "C-x o") #'ace-window)

#+end_src


** Search
*** swiper
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-swiper.el
:END:

#+begin_src emacs-lisp

;; Swiper
(straight-use-package 'swiper)
(require 'swiper)

#+end_src

**** mc

#+begin_src emacs-lisp

(defun custom/swiper-multiple-cursors ()
  (interactive)
  (swiper-mc)
  (minibuffer-keyboard-quit))

;; M-RET: multiple-cursors-mode
(define-key swiper-map (kbd "M-<return>") #'custom/swiper-multiple-cursors)

#+end_src

**** isearch

#+begin_src emacs-lisp

(defun custom/swiper-isearch (orig-fun &rest args)
  "`swiper-isearch' the selected region. If none are, `swiper-isearch'."
  (if (region-active-p)
      (let ((beg (region-beginning))
	    (end (region-end)))
	(deactivate-mark)
	(apply orig-fun (list (buffer-substring-no-properties beg end))))
    (apply orig-fun args)))

(advice-add 'swiper-isearch :around #'custom/swiper-isearch)

(define-key global-map (kbd "C-s") #'swiper-isearch)

#+end_src

*** ripgrep
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-rg.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'rg)
(require 'rg)

#+end_src

** Editing
*** Undo
**** TODO vundo
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-vundo.el
:END:

- undo-fu
- Back
   - Record character number in current line relative to the end of the line
   - If impossible to go to previous position, to recorded character number of previous line
   - Org Mode
      - restore visibility before undone command
      - if previous command created heading
         - undo heading creation and restore visibility

#+begin_src emacs-lisp

;; vundo
(straight-use-package 'vundo)

(global-set-key (kbd "C-v") #'vundo)

#+end_src

**** undo-tree                                                        :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-undo-tree.el
:END:

#+begin_src emacs-lisp

;; undo-tree
(use-package undo-tree
  :bind (("M-/" . undo-tree-visualize)
         :map undo-tree-visualizer-mode-map
         ("RET" . undo-tree-visualizer-quit)
         ("ESC" . undo-tree-visualizer-quit))
  :config
  (global-undo-tree-mode))

#+end_src

***** Visualize in side buffer

#+begin_src emacs-lisp

;; visualize in side buffer
(defun custom/undo-tree-split-side-by-side (orig-fun &rest args)
  "Split undo-tree side-by-side"
  (let ((split-height-threshold nil)
        (split-width-threshold 0))
    (apply orig-fun args)))

(advice-add 'undo-tree-visualize :around #'custom/undo-tree-split-side-by-side)

#+end_src

*** Multiline
**** multiple-cursors
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-multiple-cursors.el
:END:

#+begin_src emacs-lisp

;; Multiple cursors
(straight-use-package 'multiple-cursors)
(require 'multiple-cursors)

;; mc-lists
(setq mc/list-file (concat config-directory "persistent/mc-lists.el"))

;; Create cursors
(global-set-key (kbd "C-.")         #'mc/mark-next-like-this)
(global-set-key (kbd "C-;")         #'mc/mark-previous-like-this)
(global-set-key (kbd "C-<mouse-1>") #'mc/add-cursor-on-click)
(global-unset-key [C-down-mouse-1]) ; necessary

;; Return as usual
(define-key mc/keymap (kbd "<return>")       #'electric-newline-and-maybe-indent)

;; Exit multiple-cursors-mode
(define-key mc/keymap (kbd "<escape>")       #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<mouse-1>")      #'multiple-cursors-mode)
(define-key mc/keymap (kbd "<down-mouse-1>")   nil) ; necessary

#+end_src
** Workflow
*** Export
**** htmlize
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-htmlize.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'htmlize)

#+end_src

*** Session
**** workgroups
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-workgroups.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'workgroups)
(require 'workgroups)

(setq wg-prefix-key (kbd "C-c w"))

;; save commands
(define-key wg-map (kbd "s")   #'wg-save)
(define-key wg-map (kbd "C-s") #'wg-update-all-workgroups-and-save)

;; suppress animation
(setq wg-morph-on nil)

(global-set-key (kbd "C-c w") #'workgroups-mode)

#+end_src

*** Project interaction
**** projectile
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-projectile.el
:END:

#+begin_src emacs-lisp

;; projectile
(straight-use-package 'projectile)
(require 'projectile)

(projectile-mode)

;; command map prefix
(define-key projectile-mode-map (kbd "M-p") 'projectile-command-map)

#+end_src

**** treemacs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-treemacs.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'treemacs)
(require 'treemacs)

#+end_src

***** Filter

#+begin_src emacs-lisp

(defvar custom/treemacs-ignored '(".*__pycache__.*")
  "Files and directories ignored by treemacs")

(defun custom/treemacs-ignore-filter (file _)
  (cl-loop for ignored in custom/treemacs-ignored
	   if (string-match ignored file)
	      return t
	   finally return nil))
(push #'custom/treemacs-ignore-filter treemacs-ignored-file-predicates)

#+end_src

***** Bindings

#+begin_src emacs-lisp

(cl-loop for binding in '(("M-0"       . treemacs-select-window)
			        ("C-x t 1"   . treemacs-delete-other-windows)
			        ("C-x t t"   . treemacs)
			        ("C-x t d"   . treemacs-select-directory)
			        ("C-x t B"   . treemacs-bookmark)
			        ("C-x t C-t" . treemacs-find-file)
			        ("C-x t M-t" . treemacs-find-tag))
	 do (global-set-key (kbd (car binding)) (cdr binding)))

#+end_src

***** Settings

#+begin_src emacs-lisp

(setq treemacs-collapse-dirs                   (if treemacs-python-executable 3 0)
      treemacs-deferred-git-apply-delay        0.5
      treemacs-directory-name-transformer      #'identity
      treemacs-display-in-side-window          t
      treemacs-eldoc-display                   'simple
      treemacs-file-event-delay                5000
      treemacs-file-extension-regex            treemacs-last-period-regex-value
      treemacs-file-follow-delay               0.2
      treemacs-file-name-transformer           #'identity
      treemacs-follow-after-init               t
      treemacs-expand-after-init               t
      treemacs-find-workspace-method           'find-for-file-or-pick-first
      treemacs-git-command-pipe                ""
      treemacs-goto-tag-strategy               'refetch-index
      treemacs-indentation                     2
      treemacs-indentation-string              " "
      treemacs-is-never-other-window           nil
      treemacs-max-git-entries                 5000
      treemacs-missing-project-action          'ask
      treemacs-move-forward-on-expand          nil
      treemacs-no-png-images                   nil
      treemacs-no-delete-other-windows         t
      treemacs-project-follow-cleanup          nil
      treemacs-persist-file                    (expand-file-name ".cache/treemacs-persist" user-emacs-directory)
      treemacs-position                        'left
      treemacs-read-string-input               'from-child-frame
      treemacs-recenter-distance               0.1
      treemacs-recenter-after-file-follow      nil
      treemacs-recenter-after-tag-follow       nil
      treemacs-recenter-after-project-jump     'always
      treemacs-recenter-after-project-expand   'on-distance
      treemacs-litter-directories              '("/node_modules" "/.venv" "/.cask")
      treemacs-show-cursor                     nil
      treemacs-show-hidden-files               t
      treemacs-silent-filewatch                nil
      treemacs-silent-refresh                  nil
      treemacs-sorting                         'alphabetic-asc
      treemacs-select-when-already-in-treemacs 'move-back
      treemacs-space-between-root-nodes        t
      treemacs-tag-follow-cleanup              t
      treemacs-tag-follow-delay                1.5
      treemacs-text-scale                      nil
      treemacs-user-mode-line-format           nil
      treemacs-user-header-line-format         nil
      treemacs-wide-toggle-width               70
      treemacs-width                           35
      treemacs-width-increment                 1
      treemacs-width-is-initially-locked       t
      treemacs-workspace-switch-cleanup        nil)

;; The default width and height of the icons is 22 pixels. If you are
;; using a Hi-DPI display, uncomment this to double the icon size.
;; (treemacs-resize-icons 44)

(treemacs-follow-mode t)
(treemacs-filewatch-mode t)
(treemacs-fringe-indicator-mode 'always)

(pcase (cons (not (null (executable-find "git")))
             (not (null treemacs-python-executable)))
  (`(t . t)
   (treemacs-git-mode 'deferred))
  (`(t . _)
   (treemacs-git-mode 'simple)))

(treemacs-hide-gitignored-files-mode nil)

#+end_src

***** Extensions

#+begin_src emacs-lisp

(straight-use-package 'treemacs-icons-dired)

(straight-use-package 'treemacs-projectile)

(straight-use-package 'treemacs-tab-bar)

(straight-use-package 'treemacs-magit)

#+end_src

** Templates
*** yasnippet
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-yasnippet.el
:END:

#+begin_src emacs-lisp

;; yasnippet
(straight-use-package 'yasnippet)

(yas-global-mode 1)

#+end_src

**** <

#+begin_src emacs-lisp

(defun custom/<-snippet (orig-fun &rest args)
  "Require < before snippets."
  (interactive)
  (setq line (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
	(if (not (string-equal line ""))
	    (if (string-equal (substring line 0 1) "<")
		(progn (save-excursion (move-beginning-of-line nil)
				       (right-char 1)
				       (delete-region (line-beginning-position) (point)))
		       (apply orig-fun args)))))

(advice-add 'yas-expand :around #'custom/<-snippet)

#+end_src

**** Snippets

#+begin_src emacs-lisp

;; yasnippet-snippets
(straight-use-package 'yasnippet-snippets)

#+end_src


** Version control
*** magit
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-magit.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'magit)
(require 'magit)

(global-set-key (kbd "C-x g") #'magit-status)

#+end_src

*** forge
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-forge.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'forge)

#+end_src

** File management
*** dirvish
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-dirvish.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'dirvish)
(require 'dirvish)

;; override dired
(dirvish-override-dired-mode)

#+end_src


** IDE
*** General
**** Editing
***** Wrapping
****** embrace
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-embrace.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'embrace)

#+end_src

***** Parenthesis
****** puni
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-puni.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'puni)

;; mode hooks
(dolist (hook '(prog-mode-hook
                sgml-mode-hook
                nxml-mode-hook
                tex-mode-hook
                eval-expression-minibuffer-setup-hook))
  (add-hook hook #'puni-mode))

#+end_src

****** smartparens                                                    :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-smartparens.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'smartparens)

#+end_src

****** paredit                                                        :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-paredit.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'paredit)

#+end_src

**** Outline
***** hideshow
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-hideshow.el
:END:

#+begin_src emacs-lisp

(require 'hideshow)

(add-hook 'prog-mode-hook #'hs-minor-mode)

#+end_src

****** TODO Cycle

- fold back in 1 when no children

#+begin_src emacs-lisp

(defun custom/hs-cycle (&optional level)
  (interactive "p")
  (save-excursion
    (let (message-log-max (inhibit-message t))
      (if (= level 1)
	  (pcase last-command
	    ('hs-cycle
	     (hs-hide-level 1)
	   (setq this-command 'hs-cycle-children))
	    ('hs-cycle-children
	     ;; TODO: Fix this case. `hs-show-block' needs to be
	     ;; called twice to open all folds of the parent
	     ;; block.
	     (save-excursion (hs-show-block))
	     (hs-show-block)
	     (setq this-command 'hs-cycle-subtree))
	    ('hs-cycle-subtree
	     (hs-hide-block))
	    (_
	     (if (not (hs-already-hidden-p))
		 (hs-hide-block)
	       (hs-hide-level 1)
	       (setq this-command 'hs-cycle-children))))
	(hs-hide-level level)
	(setq this-command 'hs-hide-level)))))

(defun custom/hs-global-cycle ()
  (interactive)
  (pcase last-command
    ('hs-global-cycle
     (save-excursion (hs-show-all))
     (setq this-command 'hs-global-show))
    (_ (hs-hide-all))))

(define-key hs-minor-mode-map (kbd "C-\\") #'custom/hs-cycle)

#+end_src

**** Completion
***** company
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-company.el
:END:

#+begin_src emacs-lisp

;; company
(straight-use-package 'company)
(require 'company)

#+end_src

**** Syntax checking
***** flycheck
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-flycheck.el
:END:

#+begin_src emacs-lisp

;; flycheck
(straight-use-package 'flycheck)
(require 'flycheck)

(add-hook 'prog-mode-hook #'flycheck-mode)

#+end_src

**** Language server protocol
***** eglot                                                         :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-eglot.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'eglot)

#+end_src

***** lsp-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-lsp-mode.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'lsp-mode)
(require 'lsp-mode)

#+end_src

***** lsp-bridge                                                    :ARCHIVE:
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-lsp-bridge.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'lsp-bridge)
(require 'lsp-bridge)

#+end_src

*** Specific
**** Lisp
***** rainbow-delimiters
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-rainbow-delimiters.el
:END:

#+begin_src emacs-lisp

;; rainbow-delimieters
(straight-use-package 'rainbow-delimiters)
(require 'rainbow-delimiters)

;; enable rainbow delimiters on all programming modes
(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

#+end_src
**** Python
***** elpy
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-elpy.el
:END:

#+begin_src bash :tangle no

sudo apt-get install python3-venv

#+end_src

#+begin_src emacs-lisp

;; elpy
(straight-use-package 'elpy)
(elpy-enable)

#+end_src

****** RPC

#+begin_src emacs-lisp

(setq elpy-rpc-timeout 5)

(setq elpy-rpc-backend "jedi")

(setq elpy-rpc-python-command "python3")

#+end_src

****** Navigation

#+begin_src emacs-lisp

(define-key elpy-mode-map (kbd "C-M-n") 'elpy-nav-forward-block)
(define-key elpy-mode-map (kbd "C-M-p") 'elpy-nav-backward-block)

#+end_src

**** Matlab
***** matlab-emacs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-matlab-emacs.el
:END:

#+begin_src emacs-lisp

(straight-use-package '(matlab-emacs :type git :host nil :repo "https://git.code.sf.net/p/matlab-emacs/src"))
(load-library "matlab-load")

(add-to-list 'auto-mode-alist '("\\.m$" . matlab-mode))

#+end_src

**** Rust
***** rustic
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-rustic.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'rustic)

;; Do not format org-babel blocks after a successful build
(setq rustic-babel-format-src-block nil)
;; Do not display compilation buffer of babel process
(setq rustic-babel-display-compilation-buffer nil)

;; Add cargo to exec-path
(add-to-list 'exec-path "~/.cargo/bin")

#+end_src

** PDF
*** pdf-tools
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-pdf-tools.el
:END:

#+begin_src emacs-lisp

;; requirements
(require 'tablist)

(straight-use-package 'pdf-tools)
(pdf-tools-install)
(pdf-loader-install)
(require 'pdf-tools)

;; replace swiper
(define-key pdf-view-mode-map (kbd "C-s") #'isearch-forward)

;; page display size
(setq-default pdf-view-display-size 'fit-page)
;; automatically annotate highlights
(setq pdf-annot-activate-created-annotations t)

;; [c]enter
(define-key pdf-view-mode-map (kbd "c") #'pdf-view-center-in-window)
;; [j]ump 
(define-key pdf-view-mode-map (kbd "j") #'pdf-view-goto-label)
;; [h]highlight
(define-key pdf-view-mode-map (kbd "h") #'pdf-annot-add-highlight-markup-annotation)
;; [t]ext annotation
(define-key pdf-view-mode-map (kbd "t") #'pdf-annot-add-text-annotation)
;; [d]elete annotation
(define-key pdf-view-mode-map (kbd "d") #'pdf-annot-delete)

;; themed view
(define-key pdf-view-mode-map (kbd "C-c C-r t") #'pdf-view-themed-minor-mode)
;; fine-grained zooming
(setq pdf-view-resize-factor 1.1)

#+end_src

*** pdf-view-restore
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-pdf-view-restore.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'pdf-view-restore)

(add-hook 'pdf-view-mode-hook 'pdf-view-restore-mode)

#+end_src

** Org Mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org)
(require 'org)

#+end_src

*** Patches

#+begin_src emacs-lisp

(require 'el-patch)

#+end_src

**** org-self-insert-command

#+begin_src emacs-lisp

(el-patch-feature org)
(el-patch-defun org-self-insert-command (N)
  "Like `self-insert-command', use overwrite-mode for whitespace in tables.
If the cursor is in a table looking at whitespace, the whitespace is
overwritten, and the table is not marked as requiring realignment."
  (interactive "p")
  (el-patch-remove (org-fold-check-before-invisible-edit 'insert))
  (cond
   ((and org-use-speed-commands
	 (let ((kv (this-command-keys-vector)))
	   (setq org-speed-command
		 (run-hook-with-args-until-success
		  'org-speed-command-hook
		  (make-string 1 (aref kv (1- (length kv))))))))
    (cond
     ((commandp org-speed-command)
      (setq this-command org-speed-command)
      (call-interactively org-speed-command))
     ((functionp org-speed-command)
      (funcall org-speed-command))
     ((consp org-speed-command)
      (eval org-speed-command t))
     (t (let (org-use-speed-commands)
	  (call-interactively 'org-self-insert-command)))))
   ((and
     (= N 1)
     (not (org-region-active-p))
     (org-at-table-p)
     (progn
       ;; Check if we blank the field, and if that triggers align.
       (and (featurep 'org-table)
	    org-table-auto-blank-field
	    (memq last-command
		  '(org-cycle org-return org-shifttab org-ctrl-c-ctrl-c))
	    (if (or (eq (char-after) ?\s) (looking-at "[^|\n]*  |"))
		;; Got extra space, this field does not determine
		;; column width.
		(let (org-table-may-need-update) (org-table-blank-field))
	      ;; No extra space, this field may determine column
	      ;; width.
	      (org-table-blank-field)))
       t)
     (looking-at "[^|\n]*  |"))
    ;; There is room for insertion without re-aligning the table.
    (self-insert-command N)
    (org-table-with-shrunk-field
     (save-excursion
       (skip-chars-forward "^|")
       ;; Do not delete last space, which is
       ;; `org-table-separator-space', but the regular space before
       ;; it.
       (delete-region (- (point) 2) (1- (point))))))
   (t
    (setq org-table-may-need-update t)
    (self-insert-command N)
    (org-fix-tags-on-the-fly)
    (when org-self-insert-cluster-for-undo
      (if (not (eq last-command 'org-self-insert-command))
	  (setq org-self-insert-command-undo-counter 1)
	(if (>= org-self-insert-command-undo-counter 20)
	    (setq org-self-insert-command-undo-counter 1)
	  (and (> org-self-insert-command-undo-counter 0)
	       buffer-undo-list (listp buffer-undo-list)
	       (not (cadr buffer-undo-list)) ; remove nil entry
	       (setcdr buffer-undo-list (cddr buffer-undo-list)))
	  (setq org-self-insert-command-undo-counter
		(1+ org-self-insert-command-undo-counter))))))))

#+end_src

**** TODO org-indent--compute-prefixes

- el-patch

#+begin_src emacs-lisp

(defun custom/org-indent--compute-prefixes ()
  "Recompute line prefixes for regular text to
match the indentation of the parent heading."
  (dotimes (n org-indent--deepest-level)
      (let ((indentation (if (= n 0) 0 1)))
        (aset org-indent--text-line-prefixes
	        n
	        (org-add-props
	           (concat (make-string (+ n indentation) ?\s))
		    nil 'face 'org-indent)))))

(advice-add 'org-indent--compute-prefixes :after #'custom/org-indent--compute-prefixes)

#+end_src

*** UI
**** org-modern
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-modern.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-modern)

(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

#+end_src

***** Lists
****** Markers

#+begin_src emacs-lisp

(setq org-modern-list '((?+ . "-")
 		  	     (?- . "•")
 			     (?* . "▶")))

#+end_src

****** Checkboxes

#+begin_src emacs-lisp

(setq org-modern-checkbox nil)

#+end_src

***** Tables

#+begin_src emacs-lisp

;; Vertical table line width
(setq org-modern-table-vertical 1)

;; Horizontal table line width
(setq org-modern-table-horizontal 1)

#+end_src

***** Highlights

#+begin_src emacs-lisp

;; Tags
(setq org-modern-tag nil)

;; Priorities
(setq org-modern-priority nil)

#+end_src

**** org-appear
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-appear.el
:END:

#+begin_src emacs-lisp

(setq org-hide-emphasis-markers t)

(setq org-hidden-keywords '(title))

;; org-appear
(straight-use-package '(org-appear :type git :host github :repo "awth13/org-appear"))
(add-hook 'org-mode-hook #'org-appear-mode)

;; links
(setq org-appear-autolinks t)

;; keywords
(setq org-appear-autokeywords t)

;; symbols
(setq org-appear-autoentities t)

;; subscripts and superscripts
(setq org-appear-autosubmarkers t)
(setq org-appear-inside-latex t)

#+end_src

**** org-fragtog
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-fragtog.el
:END:

#+begin_src emacs-lisp

;; org-fragtog
(straight-use-package 'org-fragtog)
(require 'org-fragtog)

(add-hook 'org-mode-hook #'org-fragtog-mode)

#+end_src

*** Editing
**** org-paragraph
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-paragraph.el
:END:

#+begin_src emacs-lisp

(require 'org-paragraph (concat config-directory "elisp/packages/org-paragraph.el"))

#+end_src

***** org-meta-arrows-h

#+begin_src emacs-lisp

(defun custom/org-meta-arrows-h (orig-fun &rest args)
  "Paragraph indentation with `org-meta<arrows>'.
Furthermore, if a region is active and its
beginning lies on an Org Mode heading,
`custom/org-command-expand-region' to execute ORIG-FUN."
  (interactive)
  (cond ((custom/org-relative-line-paragraph) (custom/org-paragraph orig-fun args))
	    ((region-active-p)                    (custom/org-indent-region orig-fun args))
	    (t                                    (apply orig-fun args))))

(advice-add 'org-metaleft  :around #'custom/org-meta-arrows-h)
(advice-add 'org-metaright :around #'custom/org-meta-arrows-h)

#+end_src

***** TODO org-meta-arrows-v

- paragraphs
- visibility change when heading visibility is CHILDREN
   - save previous visibility
      - custom/org-subtree-state
         - overlay = overlays-in subtree-beg subtree-end
         - overlay-properties?
   - org-meta-v
   - if post visibility is not equal to previous
      - cycle back to previous visibility
   - rough
      - visibility change -> assume prev was CHILDREN -> 2 x org-cycle-internal-local

#+begin_src emacs-lisp

(defun custom/org-meta-arrows-v (orig-fun &rest args)
  (interactive)
  (if (custom/org-at-ellipsis)
      (progn (beginning-of-visual-line) (end-of-line)))
  (apply orig-fun args)
  (if (custom/org-relative-line-heading-folded)
      (outline-hide-subtree)))

(advice-add 'org-metaup   :around #'custom/org-meta-arrows-v)
(advice-add 'org-metadown :around #'custom/org-meta-arrows-v)

#+end_src

**** org-download
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-download.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-download)

(dolist (mode '(org-mode-hook
		dired-mode-hook))
  (add-hook mode 'org-download-enable))

;; download directory
(setq-default org-download-image-dir "./figures")

;; customize #+DOWNLOADED attribute
(defun custom/org-download-annotate (link)
  "Create a captioned and labeled figure."
  (concat "#+CAPTION:\n"
          "#+NAME: fig:\n"))
(setq org-download-annotate-function #'custom/org-download-annotate)

#+end_src

*** Templates
**** org-tempo
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-tempo.el
:END:

#+begin_src emacs-lisp

;; required as of Org 9.2
(require 'org-tempo)

;; navigation
(define-key org-mode-map (kbd "C-c f") #'tempo-forward-mark)
(define-key org-mode-map (kbd "C-c b") #'tempo-backward-mark)

#+end_src

***** LaTeX

#+begin_src emacs-lisp

;; equations
(tempo-define-template "latex-equation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    p n
			    "\\end{equation}" >)
			  "<eq"
			  "LaTeX equation template")

(tempo-define-template "latex-derivation"
		          '("#+NAME: eq:" p n
			    "\\begin{equation}" n
			    "\\arraycolsep=3pt\\def\\arraystretch{2.25}" n
			    "\\begin{array}{lll}" n
			    p n
			    "\\end{array}" n
			    "\\end{equation}" >)
			  "<de"
			  "LaTeX derivation template")

#+end_src

***** Figures

#+begin_src emacs-lisp

;; figures
(tempo-define-template "fig"
		          '("#+NAME: fig:" p n
			    "#+CAPTION: " p n
			    "#+ATTR_ORG: :width 450" n
			    "[[./" p "]]" >)
			  "<f"
			  "Org Mode figure template")

#+end_src

***** Code blocks

#+begin_src emacs-lisp

(defun custom/tempo-code-block (key language)
  (tempo-define-template language
		         `("#+begin_src " ,language n
			   n
			   p n
			   n
			   "#+end_src" >)
			 key
			 language))

(dolist (pair '(("<sh"   "shell")
		("<el"   "emacs-lisp")
		("<py"   "python")
                ("<rs"   "rust")
                ("<cpp"  "C++")
		("<bash" "bash")
                ("<tx"   "latex")))
  (apply 'custom/tempo-code-block pair))

#+end_src

**** org-capture
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-capture.el
:END:

#+begin_src emacs-lisp

(require 'org-capture)

#+end_src

***** TODO Templates

- lecture
   - specify directory
   - template

*** Applications
**** Notes
***** bitacora
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-bitacora.el
:END:

#+begin_src emacs-lisp

(require 'bitacora (concat config-directory "elisp/packages/bitacora.el"))

#+end_src

***** org-roam
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-roam.el
:END:

Importantly, [[https://org-roam.discourse.group/t/no-emacsql-sqlite-binary-available-aborting-error-when-installing-org-roam-v2-on-mac/2178/6][a C compiler (eg: gcc or clang) must be installed for ~emacsql-sqlite~ to install correctly]].

#+begin_src emacs-lisp

;; org-roam
(straight-use-package 'org-roam)

#+end_src

****** UI

#+begin_src emacs-lisp

;; org-roam-ui
(straight-use-package 'org-roam-ui)

#+end_src

******** Follow

#+begin_src emacs-lisp

(setq org-roam-ui-follow t)

#+end_src

******** Theme

#+begin_src emacs-lisp

;; sync theme and ui
(setq org-roam-ui-sync-theme nil)

#+end_src

******** Startup

#+begin_src emacs-lisp

(setq org-roam-ui-open-on-start nil)

#+end_src

******** Update

#+begin_src emacs-lisp

(setq org-roam-ui-update-on-save t)

#+end_src

****** Hooks

#+begin_src emacs-lisp

;; node visit hook
(defvar custom/org-roam-node-visit-hook nil
   "Hook ran after `org-roam-node-visit'.")

(defun custom/run-org-roam-node-visit-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'custom/org-roam-node-visit-hook))

;; enable-theme
(advice-add 'org-roam-node-visit :after #'custom/run-org-roam-node-visit-hook)

#+end_src

****** Startup
******* db-autosync-mode

#+begin_src emacs-lisp

(if (and (boundp 'org-roam-directory) (file-directory-p org-roam-directory))
    (org-roam-db-autosync-mode))

#+end_src

****** Keymap

#+begin_src emacs-lisp

(setq custom/org-roam-map (make-keymap))
(global-set-key (kbd "C-r") custom/org-roam-map)

;; Capture
(define-key custom/org-roam-map (kbd "c") #'org-roam-capture)

;; Find node
(define-key custom/org-roam-map (kbd "n") #'org-roam-node-find)

;; Insert reference
(define-key custom/org-roam-map (kbd "i") #'org-roam-node-insert)

#+end_src

****** Templates
******* Default

#+begin_src emacs-lisp

(setq org-roam-capture-templates
      '(("m" "mathematics" plain "%?"
         :target (file+head "mathematics/%<%Y%m%d%H%M%S>-${slug}.org"
			           "#+STARTUP: subtree\n\n\n\n#+title:${title}\n\n\n")
         :unnarrowed t)
        ("c" "control" plain "%?"
         :target (file+head "control/%<%Y%m%d%H%M%S>-${slug}.org"
			           "#+STARTUP: subtree\n\n\n\n#+title:${title}\n\n\n")
         :unnarrowed t)))

#+end_src

****** Timestamps

#+begin_src emacs-lisp

;; org-roam-timestamps
(straight-use-package 'org-roam-timestamps)
(require 'org-roam-timestamps)

;; remember
(setq org-roam-timestamps-remember-timestamps nil)
(setq org-roam-timestamps-minimum-gap 3600)

;; visit hook
(add-hook 'custom/org-roam-node-visit-hook #'org-roam-timestamps-mode)

;; capture hook
(defvar custom/org-roam-timestamps-mode-active-before-capture nil)

(defun custom/org-roam-timestamps-mode-off ()
  "Disable `org-roam-timestamps-mode' in Org Roam capture buffers."
  (setq custom/org-roam-timestamps-mode-active-before-capture org-roam-timestamps-mode)
  (org-roam-timestamps-mode -1))
(add-hook 'org-roam-capture-new-node-hook #'custom/org-roam-timestamps-mode-off)

(defun custom/org-roam-timestamps-mode-back ()
  "Re-enable `org-roam-timestamps-mode' after finalizing capture,
if it was previously enabled."
  (if custom/org-roam-timestamps-mode-active-before-capture
      (org-roam-timestamps-mode)))
(add-hook 'org-capture-after-finalize-hook #'custom/org-roam-timestamps-mode-back)

#+end_src

**** Agenda
***** org-agenda
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-agenda.el
:END:

#+begin_src emacs-lisp

;; org-agenda
(require 'org-agenda)
(global-set-key (kbd "C-c a") #'org-agenda)

#+end_src

****** Entries
******* Tag alignment

#+begin_src emacs-lisp

;; Tag indentation
(setq org-tags-column 70)

#+end_src

****** Agenda
******* Editing

#+begin_src emacs-lisp

;; Mark items as done
(defun custom/org-agenda-todo-done ()
  (interactive)
  (org-agenda-todo 'done))

(define-key org-agenda-mode-map (kbd "d") 'custom/org-agenda-todo-done)

#+end_src

******* Navigation
******** TODO Visit

- org-recenter -> unfold -> move away -> fold back
   - arrows -> fold previous item
   - recenter -> unfold item
- currently- 
   - org-recenter -> all todo items unfolded

#+begin_src emacs-lisp :tangle no

(defun custom/org-agenda-recenter (arg)
  (interactive "P")
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (eq last-command this-command)
        (progn (custom/org-restore-outline-state)
	       (org-agenda-recenter arg))
      (progn (custom/org-save-outline-state)
	     (org-agenda-recenter arg))))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-agenda-mode-map (kbd "<tab>") 'org-agenda-recenter)

#+end_src

**** Contacts
***** org-contacts
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-contacts.el
:END:

#+begin_src emacs-lisp

;; org-contacts
(straight-use-package '(org-contacts :type git :host nil :repo "https://repo.or.cz/org-contacts.git"))
(require 'org-contacts)

#+end_src

****** Template

#+begin_src emacs-lisp

(defvar custom/org-capture-contacts "* %(org-contacts-template-name)
:PROPERTIES:
:ADDRESS: %^{289 Cleveland St. Brooklyn, 11206 NY, USA}
:BIRTHDAY: %^{yyyy-mm-dd}
:EMAIL: %(org-contacts-template-email)
:NOTE: %^{NOTE}
:END:" "org-contacts template")

(add-to-list 'org-capture-templates
   `(("c" "contact" entry
      (file ,(nth 0 org-contacts-files))
      ,custom/org-capture-contacts)))

#+end_src

**** Calendar
***** org-calendar
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-calendar.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'calfw)
(straight-use-package 'calfw-org)
(straight-use-package 'calfw-ical)

;; org-agenda configuration is lost otherwise
(with-eval-after-load 'org-agenda
  (require 'calfw-org)
  (require 'calfw-ical))

(defun custom/org-calendar ()
  "Open `calfw' Org Agenda calendar."
  (interactive)
  (require 'org-agenda)
  (let ((inhibit-message t))
       (cfw:open-org-calendar)))

(global-set-key (kbd "C-c c") #'custom/org-calendar)

#+end_src

**** Programming
***** org-babel
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-babel.el
:END:
****** Editing

#+begin_src emacs-lisp

;; src edit buffer in current window
(setq org-src-window-setup "current-window")

#+end_src

****** Languages

#+begin_src emacs-lisp

;; Language packages
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python     . t)
   (C          . t)
   (shell      . t)
   (latex      . t)))

#+end_src

******* Bash

#+begin_src emacs-lisp

(defun org-babel-bash-initiate-session (&optional session _params)
  "Initiate a bash/sh session named SESSION according to PARAMS."
  (org-babel-sh-initiate-session session _params))

#+end_src

******* Python

#+begin_src emacs-lisp

(setq org-babel-python-command "python3")

#+end_src

****** Execution

#+begin_src emacs-lisp

;; suppress security confirmation when evaluating code
(setq org-confirm-babel-evaluate nil)

#+end_src

****** Typesetting
******* Indentation

#+begin_src emacs-lisp

;; Set indentation of code blocks to 0
(setq org-edit-src-content-indentation 0)

;; Indent code blocks appropriately when inside headers
(setq org-src-preserve-indentation     nil)

;; Make code indentation reasonable
(setq org-src-tab-acts-natively        t)

#+end_src

****** Default header arguments

#+begin_src emacs-lisp

(setq org-babel-default-header-args
      '((:noweb   . "yes")
        (:async   . "yes")
        (:session . "ob-session")
        (:results . "replace")
        (:exports . "code")
        (:cache   . "no")
        (:hlines  . "no")
        (:tangle  . "no")))

#+end_src

***** ob-async
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-ob-async.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'ob-async)
(require 'ob-async)

#+end_src

**** Presentations
***** org-reveal
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-reveal.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'org-reveal)
(require 'ox-reveal)
(load-library "ox-reveal")

(setq org-reveal-root "https://cdn.jsdelivr.net/npm/reveal.js")

#+end_src

**** Time-tracking
***** org-agenda-log-mode
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-org-agenda-log-mode.el
:END:

#+begin_src emacs-lisp

;; Org Agenda log mode
(setq org-agenda-start-with-log-mode t)
(setq org-log-done 'time)
(setq org-log-into-drawer t)

#+end_src

** Tabulated lists
*** tablist
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./modules/shapes-tablist.el
:END:

#+begin_src emacs-lisp

(straight-use-package 'tablist)

#+end_src


* Extensions

Content of an extension:
- Functions
   - If interactive, function bindings
- Macros

** Utilities
*** Get
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-get.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** UI
***** get-active-theme

#+begin_src emacs-lisp

;; Retrieve current theme
(defun custom/get-active-theme ()
  (substring (format "%s" (nth 0 custom-enabled-themes))))

#+end_src

**** Text
***** get-point

#+begin_src emacs-lisp

(defun custom/get-point (command &rest args)
  (interactive)
  (save-excursion
    (apply command args)
    (point)))

#+end_src

***** get-last-change

#+begin_src emacs-lisp

(defun custom/get-last-change ()
  "Retrieve last change in current buffer."
  (setq last-change (nth 1 buffer-undo-list))
  (let ((beg (car last-change))
        (end (cdr last-change)))
    (buffer-substring-no-properties beg end)))

#+end_src

***** count-substrings

#+begin_src emacs-lisp

(defun custom/count-substrings (regexp str)
  "Return the number of substrings of STR matching REGEXP"
  (loop with start = 0
        for count from 0
        while (string-match regexp str start)
        do (setq start (match-end 0))
        finally return count))

#+end_src

**** Data
***** get-keyword-key-value

#+begin_src emacs-lisp

(defun custom/get-keyword-key-value (kwd)
   (let ((data (cadr kwd)))
     (list (plist-get data :key)
           (plist-get data :value))))

#+end_src

**** Buffer
***** get-visible-buffers

#+begin_src emacs-lisp

(defun custom/get-visible-buffers ()
  (cl-delete-duplicates (mapcar #'window-buffer (window-list))))

#+end_src

***** get-buffer-by-file-name

#+begin_src emacs-lisp

(defun custom/get-buffer-by-file-name (file)
  (cl-loop for buffer in (buffer-list)
	        if (string-equal (buffer-name buffer) (file-name-nondirectory file))
	           return buffer
		finally return nil))

#+end_src

**** Window
***** get-active-window-number

#+begin_src emacs-lisp

(defun custom/get-active-window-number ()
  "Retrieve the current window's number."
  (setq window (prin1-to-string (get-buffer-window (current-buffer))))
  (string-match "^[^0-9]*\\([0-9]+\\).*$" window)
  (match-string 1 window))

#+end_src

**** Keymap
***** get-keymaps

#+begin_src emacs-lisp

(defvar custom/keymap-list '()
  "List containing the symbols of all keymaps in the `obarray'.")

(defun custom/get-keymaps ()
  "Return a list containing the symbols of all keymaps in the `obarray'."
  (mapatoms (lambda (m) (if (condition-case nil
                                (or (keymapp (symbol-value m))
                                    (keymapp m))
                              (error nil))
                            (add-to-list 'custom/keymap-list m))
          obarray))
  (when (called-interactively-p 'interactive)
        (message "Keymap list updated, %s keymaps found" (length custom/keymap-list)))
  custom/keymap-list)

#+end_src

***** get-keymap-symbol

#+begin_src emacs-lisp

(defun custom/get-keymap-symbol (keymap)
  "Return the symbol to which KEYMAP is bound, or nil if no such symbol exists."
  (catch 'gotit
    (mapatoms (lambda (sym)
                (and (boundp sym)
                     (eq (symbol-value sym) keymap)
                     (not (eq sym 'keymap))
                     (throw 'gotit sym))))))

#+end_src

-----
References:

- [[https://stackoverflow.com/a/14490054][user4815162342, Answer to "Emacs name of current local keymap?", StackOverflow]]

*** Queries
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-queries.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** At
***** eolp

#+begin_src emacs-lisp

(defun custom/eolp (orig-fun &rest args)
  (interactive)
  (or (apply orig-fun args) (looking-at-p "[[:blank:]]*$")))

(advice-add 'eolp :around #'custom/eolp)

#+end_src

***** at-point

#+begin_src emacs-lisp

(defun custom/at-point (go-to-point &optional point)
  (let ((point (or point (point))))
    (save-excursion
      (funcall go-to-point)
      (= point (point)))))

#+end_src

***** at-indent

#+begin_src emacs-lisp

(defun custom/at-indent (&optional point)
  (and (custom/relative-line-indented) (custom/at-point 'back-to-indentation point)))

#+end_src

**** Line
***** relative-line

#+begin_src emacs-lisp

(defun custom/relative-line (query &optional number &rest args)
  "Return the result of a boolean query at the beginning
of the current visual line, or another specified by its
relative position to the current line.
Optionally, `args' may be given as input to be passed
to the query at execution."
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-visual-line)
      (beginning-of-line-text (+ number 1))
      (apply query args))))

#+end_src

***** relative-line-regex

#+begin_src emacs-lisp

(defun custom/relative-line-regex (pattern &optional number)
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-line-text (+ number 1))
      (setq line (buffer-substring-no-properties (custom/get-point 'beginning-of-line) (custom/get-point 'end-of-line))))
    (string-match-p pattern line)))

#+end_src

***** relative-line-list

#+begin_src emacs-lisp

(defun custom/relative-line-list (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*\\([0-9]+[.\\)]\\{1\\}\\|[-+*]\\{1\\}\\)[[:blank:]]+.*$" number))

#+end_src

***** relative-line-empty

#+begin_src emacs-lisp

(defun custom/relative-line-empty (&optional number)
  (custom/relative-line-regex "^[[:space:]]*$" number))

#+end_src

***** TODO relative-line-wrapped

- &optional number

#+begin_src emacs-lisp

(defun custom/relative-line-wrapped ()
  (> (custom/get-point 'beginning-of-visual-line) (custom/get-point 'beginning-of-line-text)))

#+end_src

***** relative-line-indented

#+begin_src emacs-lisp

(defun custom/relative-line-indented (&optional number)
  (custom/relative-line-regex "^[[:blank:]]+.*$" number))

  #+end_src

***** relative-line-list-ordered

#+begin_src emacs-lisp

(defun custom/relative-line-list-ordered (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

***** relative-line-list-unordered

#+begin_src emacs-lisp

(defun custom/relative-line-list-unordered (&optional number)
  (custom/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+.*$" number))

#+end_src

**** Region
***** region-blank

#+begin_src emacs-lisp

(defun custom/region-blank (&optional beg end)
  (let ((beg (or beg (region-beginning)))
	      (end (or end (region-end))))
    (setq region (buffer-substring-no-properties beg end))
    (string-match "\\`[[:space:]]*\\'$" region)))

#+end_src

***** region-multiline-visual

#+begin_src emacs-lisp

(defun custom/region-multiline-visual ()
  "Return t if a region is active and spans more than one visual line."
  (and (region-active-p) (> (custom/region-count-visual-lines) 1)))

#+end_src

***** region-count-visual-lines

#+begin_src emacs-lisp

(defun custom/region-count-visual-lines ()
  "Count visual lines in an active region."
  (interactive)
  (save-excursion 
    (beginning-of-visual-line)
    (count-screen-lines (region-beginning) (region-end))))

#+end_src

*** Execution
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-execution.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** @buffers

#+begin_src emacs-lisp

(defmacro custom/@buffers (command &optional buffers)
  (let ((buffers (or buffers (buffer-list))))
    `(cl-loop for buffer in ',buffers
              do (if (buffer-live-p buffer)
                     (save-window-excursion
                       (switch-to-buffer buffer)
                       ,command)))))

#+end_src

*** Operators
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-operators.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** <>

#+begin_src emacs-lisp

(defun <> (a b c)
  (and (> b a) (> c b)))

#+end_src


** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-ui.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Text
**** Theme accents

#+begin_src emacs-lisp

;; accent typefaces
(defvar custom/accents '(custom/italic))

(defun custom/theme-accents (orig-fun &rest args)
  "Many themes will override certain face *attributes*, such as `italic'. To prevent
this, this function loops over all accent typefaces in `custom/accents', which contains
faces (defined with `defface') named ~custom/<attribute>~, and makes the ~<attribute>~
inherit from ~custom/<attribute>~.

As such, when this function is run, the `italic' face attribute will be made to
inherit from `custom/italic' as in the expression below.

   (set-face-attribute 'italic nil :inherit 'custom/italic)

Thus, our preferred accent typefaces will stand whatever harassment they may be put
through as a theme loads."
  ;; load theme
  (apply orig-fun args)
  ;; restore accents
  (cl-loop for accent in custom/accents
	   do (let ((face (intern (car (last (split-string (symbol-name accent) "/"))))))
		     (set-face-attribute face nil :inherit accent))))

(advice-add 'load-theme :around #'custom/theme-accents)

#+end_src

*** Window
**** Quit

#+begin_src emacs-lisp

(defun custom/quit-window ()
  (interactive)
  (if current-prefix-arg
      (quit-window)
    (quit-window 1)))

(with-eval-after-load 'helpful
  (cl-loop for map in '(help-mode-map
                        helpful-mode-map)
           do (define-key (symbol-value map) [remap quit-window] #'custom/quit-window)))

#+end_src

**** Resize
***** window-resize

#+begin_src emacs-lisp

(defun custom/window-resize (width)
  (window-resize nil (- width (window-width)) t))

#+end_src

***** window-resize-fraction

#+begin_src emacs-lisp

(defun custom/window-resize-fraction (fr &optional min)
  "Resize window to a fraction of the frame width."
  (interactive)
  (let ((width (max (if min min 0) (truncate (* fr (frame-width))))))
    (window-resize nil (- width (window-width)) t)))

#+end_src

*** Warnings
**** C-g is undefined

#+begin_src emacs-lisp

;; Record last sent message
(defvar last-message nil)
(defadvice message (after my-message pre act) (setq last-message ad-return-value))

(defun custom/undefined-override (orig-fun &rest args)
  "Override `undefined' function to suppress
undefined key binding messages when interrupting
key binding input with C-g."
  (let ((inhibit-message t)
	    (message-log-max nil))
    (progn (apply orig-fun args)
	       (setq _message last-message)))
  (if (string-match-p (regexp-quote "C-g is undefined") _message)
      (keyboard-quit)
    (message _message)))

;; Override the undefined key binding notice with a keyboard-quit
(advice-add 'undefined :around #'custom/undefined-override)

#+end_src

*** Mode line
**** Hide

#+begin_src emacs-lisp

(defcustom custom/mode-line nil
  "Variable containing the format of the hidden mode line")

(defcustom custom/header-line nil
  "Variable containing the format of the hidden header line")

(defun custom/hide-mode-line ()
  "Hide `modeline' in current buffer"
  (interactive)
  (let ((m mode-line-format)
        (h header-line-format))
       (custom/@buffers (if (or m h)
                            (progn (setq custom/mode-line   m)
                                   (setq custom/header-line h)
                                   (setq mode-line-format   nil)
                                   (setq header-line-format nil))
                          (progn (setq mode-line-format custom/mode-line)
                                 (setq header-line-format custom/header-line))))))

(global-set-key (kbd "M-m") #'custom/hide-mode-line)

#+end_src

**** Invert

#+begin_src emacs-lisp

(defun custom/mode-line-invert ()
  (interactive)
  (if mode-line-format
      (custom/@buffers (progn (set 'header-line-format mode-line-format)
                              (set 'mode-line-format nil)))
    (custom/@buffers (progn (set 'mode-line-format header-line-format)
                            (set 'header-line-format nil)))))

(global-set-key (kbd "M-t") #'custom/mode-line-invert)

#+end_src

** Themes
*** Switch
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-theme-switch.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** Load

#+begin_src emacs-lisp

(defun custom/enable-or-load-theme (theme)
  (condition-case nil
      (enable-theme theme)
    (error (load-theme theme))))

#+end_src

**** Hook

#+begin_src emacs-lisp

(defvar custom/enable-or-load-theme-hook nil
   "`load-theme' hook.")

(defun custom/enable-or-load-theme-hook (&rest _args)
   "Run `load-theme-hook'."
   (run-hooks 'custom/enable-or-load-theme-hook))

(advice-add 'enable-theme :after #'custom/enable-or-load-theme-hook)
(advice-add 'load-theme   :after #'custom/enable-or-load-theme-hook)

#+end_src

**** Toggle

#+begin_src emacs-lisp

(defun custom/theme-toggle ()
  "Toggle between `dark' and `light' themes
using `enable-theme'"
  (interactive)
  (let ((theme (nth 0 custom-enabled-themes)))
    (cond ((string-equal theme light) (progn (disable-theme light)
					     (custom/enable-or-load-theme dark)))
	  (t                          (progn (disable-theme dark)
					     (custom/enable-or-load-theme light))))))

(global-set-key (kbd "C-t") #'custom/theme-toggle)

#+end_src

**** Light and dark

#+begin_src emacs-lisp

(defcustom custom/light-dark-themes '("modus"
                                      "nano")
  "Themes with light and dark versions.")

(defcustom custom/theme-advice-dark '()
  "List of functions run when loading the `dark' theme, if it is included in `custom/light-dark-themes'.")

(defcustom custom/theme-advice-light '()
  "List of functions run when loading the `light' theme, if it is included in `custom/light-dark-themes'.")

(defun custom/theme-specific-advice (orig-fun &rest args)
  "Apply theme-specific advice when enabling themes, and
preserve modeline status through theme changes."
  (setq modeline-status mode-line-format)
  (apply orig-fun args)
  (let ((theme (nth 0 args)))
    (if (string-match-p (string-join custom/light-dark-themes "\\|") (symbol-name theme))
        (let ((advice-list (if (string-equal theme light)
                               custom/theme-advice-light
                             custom/theme-advice-dark)))
          (dolist (advice advice-list)
            (funcall advice))))
  (setq mode-line-format modeline-status)))

;; add
(advice-add 'enable-theme :around #'custom/theme-specific-advice)
(advice-add 'load-theme   :around #'custom/theme-specific-advice)

#+end_src

***** Line numbers

#+begin_src emacs-lisp

(defvar custom/dark-line-number-colors '("#cfcfcf" "#262626")
  "Line number HTML colors for dark themes: FOREGROUND, BACKGROUND")

(defvar custom/light-line-number-colors '("#878787" "#ededed")
  "Line number HTML colors for light themes: FOREGROUND, BACKGROUND")

(defun custom/line-number-set-colors (fg bg)
  "Set the foreground (FG) and background (BG) colors of the line numbers
displayed by `display-line-numbers-mode'."
  (set-face-attribute 'line-number nil :foreground fg :background bg))

(defun custom/set-dark-line-number-colors ()
  (apply 'custom/line-number-set-colors custom/dark-line-number-colors))

(defun custom/set-light-line-number-colors ()
  (apply 'custom/line-number-set-colors custom/light-line-number-colors))

(add-to-list 'custom/theme-advice-dark  #'custom/set-dark-line-number-colors)
(add-to-list 'custom/theme-advice-light #'custom/set-light-line-number-colors)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src

*** Mode line
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-theme-modeline.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

#+begin_src emacs-lisp

(defun custom/modeline-set-colors (fg fg-in bg bg-in)
  "Set the color of the mode and header lines and blend the 
`doom-modeline-bar' with the background."
  (set-face-attribute 'mode-line            nil :foreground fg    :background bg    :box nil)
  (set-face-attribute 'mode-line-inactive   nil :foreground fg-in :background bg-in :box nil)
  ;; header line
  (set-face-attribute 'header-line          nil :foreground fg-in :background bg-in :box nil))

(defvar custom/dark-modeline-colors '("#cfcfcf" "#cfcfcf" "#454545" "#242424")
  "Dark modeline HTML colors: FOREGROUND, FOREGROUND-INACTIVE, BACKGROUND, BACKGROUND-INACTIVE")

(defvar custom/light-modeline-colors '("#616161" "#878787" "#c4c4c4" "#ededed")
  "Light modeline HTML colors: FOREGROUND, FOREGROUND-INACTIVE, BACKGROUND, BACKGROUND-INACTIVE")

(defun custom/set-dark-modeline-colors ()
  (apply 'custom/modeline-set-colors custom/dark-modeline-colors))

(defun custom/set-light-modeline-colors ()
  (apply 'custom/modeline-set-colors custom/light-modeline-colors))

(add-to-list 'custom/theme-advice-dark  #'custom/set-dark-modeline-colors)
(add-to-list 'custom/theme-advice-light #'custom/set-light-modeline-colors)

;; reload active theme
(let ((active-theme (car custom-enabled-themes)))
  (if active-theme (enable-theme active-theme)))

#+end_src


** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-editing.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Delete
**** Line

#+begin_src emacs-lisp

(defun custom/delete-line ()
  (delete-region (custom/get-point 'beginning-of-line) (custom/get-point 'end-of-line)))

#+end_src

**** Word

Do not save whole killed words in kill ring.

#+begin_src emacs-lisp

(defun custom/delete-word-forward (&optional arg)
  (interactive)
  (delete-region (point) (progn (forward-word arg) (point))))

(defun custom/delete-word-backward (&optional arg)
  (interactive)
  (delete-region (point) (progn (backward-word arg) (point))))

(global-set-key (kbd "C-<delete>") #'custom/delete-word-forward)
(global-set-key (kbd "C-<backspace>")  #'custom/delete-word-backward)

#+end_src

**** Hungry

#+begin_src emacs-lisp

(defun custom/@delete-hungry (query)
  "Conditional region deletion.

Default: `delete-region'

If region starts at the beginning of an
indented line, delete region and indent.

If `query', delete the region and its indent 
plus one character."
  (setq beg (region-beginning) end (region-end))
  (if (custom/at-indent beg)
	    (save-excursion (beginning-of-visual-line)
                      (if (and query (not (bobp)) (not (custom/relative-line-empty -1)))
                          (left-char))
                      (delete-region (point) end))
    (delete-region beg end)))

(defun custom/delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the current mode is derived from 
`prog-mode',  delete the region and its indent plus 
one character."
  (interactive)
  (custom/@delete-hungry (derived-mode-p 'prog-mode)))

#+end_src

**** TODO Forward

- region deletion

#+begin_src emacs-lisp

(defun custom/nimble-delete-forward ()
  "Conditional forward deletion.

Default: `delete-forward-char' 1

If next line is empty, forward delete indent of 
next line plus one character."
  (interactive)
  (cond ((and (eolp) (custom/relative-line-indented 1)) (progn (setq beg (point)) (next-line) (back-to-indentation) (delete-region beg (point))))
	    ((custom/relative-line-empty)                   (delete-region (point) (custom/get-point 'next-line)))
	    (t                                              (delete-forward-char 1))))

(global-set-key (kbd "<delete>") #'custom/nimble-delete-forward)

#+end_src

**** Backward

#+begin_src emacs-lisp

(defun custom/nimble-delete-backward ()
  "Conditional forward deletion.

Default: `delete-backward-char' 1

If `multiple-cursors-mode' is active, `delete-backward-char' 1.

If region is active, delete region.

If cursor lies either `custom/at-indent' or is preceded only by
whitespace, delete region from `point' to `beginning-of-visual-line'."
  (interactive)
  (if (not (bound-and-true-p multiple-cursors-mode))
      (cond ((and (region-active-p) (not (custom/region-blank))) (custom/delete-hungry))
	         ((custom/at-indent)                                  (delete-region (point) (custom/get-point 'beginning-of-visual-line)))
		 (t                                                   (delete-backward-char 1)))
    (delete-backward-char 1)))

(global-set-key (kbd "<backspace>") #'custom/nimble-delete-backward)

#+end_src

*** Kill ring
**** Size

#+begin_src emacs-lisp

;; Increase kill ring size
(setq kill-ring-max 200)

#+end_src

**** Mouse

#+begin_src emacs-lisp

(defun custom/kill-ring-mouse ()
  "If a region is active, save the region to the
kill ring. Otherwise, yank the last entry in the
kill ring."
  (interactive)
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (yank)))

(global-set-key   (kbd "<mouse-3>") #'custom/kill-ring-mouse)
(global-unset-key (kbd "<down-mouse-3>"))

#+end_src

*** TODO Regions

- insert-char in region
   - delete, insert char
- arrow exit
   - <right> -> right of region
   - <left>  -> left of region

*** Selection
**** Defaults

#+begin_src emacs-lisp

;; Unset secondary overlay key bindings
(global-unset-key [M-mouse-1])
(global-unset-key [M-drag-mouse-1])
(global-unset-key [M-mouse-3])
(global-unset-key [M-mouse-2])

#+end_src

*** TODO Comments

- if region is active and cursor is in empty line, region is not commented
- if last arrow command was up or left, move up, if last arrow command was right or down, move down

#+begin_src emacs-lisp

(defun custom/smart-comment ()
  "If a region is active, comment out all lines in the
region. Otherwise, comment out current line if it is
not empty. In any case, advance to next line."
  (interactive)
  (let (beg end)
    ;; If a region is active
    (if (region-active-p)
	      ;; If the beginning and end of the region are in
	      ;; the same line, select entire line
	      (if (= (count-lines (region-beginning) (region-end)) 1)
		  (setq beg (line-beginning-position) end (line-end-position))
		;; Else, select region from the start of its first
		;; line to the end of its last.
		(setq beg (save-excursion (goto-char (region-beginning)) (line-beginning-position))
		      end (save-excursion (goto-char (region-end)) (line-end-position))))
      ;; Else, select line
      (setq beg (line-beginning-position) end (line-end-position)))

    ;; Comment or uncomment region
    ;; If Org Mode is active
    (if (not (custom/relative-line-empty))
	      (comment-or-uncomment-region beg end))
    ;; Move to the beginning of the next line
    (beginning-of-line-text 2)))

(global-set-key (kbd "C-x ;") #'custom/smart-comment)

#+end_src

*** Rectangular regions

#+begin_src emacs-lisp

;; Ensure rectangular-region-mode is loaded
(require 'rectangular-region-mode)

#+end_src

**** Mouse rectangle

#+begin_src emacs-lisp

;; Multiple cursor rectangle definition mouse event
(defun custom/mouse-rectangle (start-event)
  (interactive "e")
  (deactivate-mark)
  (mouse-set-point start-event)
  (set-rectangular-region-anchor)
  (rectangle-mark-mode +1)
  (let ((drag-event))
    (track-mouse
      (while (progn
               (setq drag-event (read-event))
               (mouse-movement-p drag-event))
        (mouse-set-point drag-event)))))

(global-set-key (kbd "M-<down-mouse-1>") #'custom/mouse-rectangle)

#+end_src

**** TODO Multiple cursors

- arrow exit
   - <right>
      - right
   - <left>
      - left

#+begin_src emacs-lisp

;; Enter multiple-cursors-mode
(defun custom/rectangular-region-multiple-cursors ()
  (interactive)
  (rectangular-region-mode 0)
  (multiple-cursors-mode 1)
  (deactivate-mark)
  (mc/for-each-fake-cursor
   (if (invisible-p (marker-position (overlay-get cursor 'point)))
       (mc/remove-fake-cursor cursor))))

(define-key rectangular-region-mode-map (kbd "<return>") #'custom/rectangular-region-multiple-cursors)

#+end_src

**** Quit

#+begin_src emacs-lisp

;; Exit rectangular-region-mode
(define-key rectangular-region-mode-map (kbd "<escape>") #'rrm/keyboard-quit)
(define-key rectangular-region-mode-map (kbd "<mouse-1>") #'rrm/keyboard-quit)

#+end_src

** Search
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-search.el
:END:
*** Search and replace

#+begin_src emacs-lisp

(defun custom/query-replace-regexp ()
  (interactive)
  (save-excursion
    (beginning-of-buffer)
    (call-interactively 'query-replace-regexp)))

(global-set-key (kbd "M-/") #'custom/query-replace-regexp)

#+end_src

** Workflow
*** Session
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-session.el
:END:

#+begin_src emacs-lisp

(defun custom/load-session ()
  (interactive)
  (let ((session (read-file-name "Select session: "
                                 "~/sessions/"
                                 nil
                                 nil
                                 (car (directory-files "~/sessions/" nil "\\`[^.]*\\'")))))
    (desktop-change-dir session)
    (wg-load (concat session ".wg"))
    (call-interactively 'wg-switch-to-workgroup)))

(global-set-key (kbd "C-x s") #'custom/load-session)

#+end_src

*** External programs
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-external-programs.el
:END:
**** Keymap
#+begin_src emacs-lisp

(defcustom custom/external-application-map (make-keymap)
  "External application keymap")

(defcustom custom/external-application-bindings '()
  "List of external application key-binding pairs")

(defun custom/bind-external-application (binding)
  (add-to-list 'custom/external-application-bindings binding))

(global-set-key (kbd "C-c C-o") custom/external-application-map)

#+end_src

**** Codium

#+begin_src emacs-lisp

(defun open-in-codium ()
  (interactive)
  (let ((root (projectile-root-bottom-up (file-name-directory buffer-file-name))))
    (call-process-shell-command (concat "codium " root "&") nil 0)))

(custom/bind-external-application '("c" . open-in-codium))

#+end_src

**** Firefox

#+begin_src emacs-lisp

(defun open-in-firefox ()
  (interactive)
  (call-process-shell-command (concat "firefox-trunk \"" (buffer-file-name) "\"") nil 0))

(custom/bind-external-application '("f" . open-in-firefox))

#+end_src

**** Binding definition

#+begin_src emacs-lisp

(dolist (binding custom/external-application-bindings)
  (define-key custom/external-application-map (kbd (car binding)) (cdr binding)))

#+end_src


** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-navigation.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Text
**** TODO end

- in wrapped line
   - end of visual line -> end of line
- else
   - end of line -> end of visual line

#+begin_src emacs-lisp

;; Double end to go to the beginning of line
(defvar custom/double-end-timeout 0.4)

(defun custom/double-end ()
  "Move to end of visual line. If the command is repeated 
within `custom/double-end-timeout' seconds, move to end
of line."
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
             (<= (time-to-seconds (time-since last-called)) custom/double-end-timeout))
        (progn (beginning-of-visual-line) (end-of-line))
      (end-of-visual-line)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<end>") #'custom/double-end)

#+end_src

**** home

#+begin_src emacs-lisp

(defun custom/home ()
  "Conditional homing. 

Default: `beginning-of-line-text'

If the current line is empty, home to `beginning-of-line'.

If the current line holds a list item, home back to `beginning-of-line-text'.

If the current line is indented, home `back-to-indentation'.

If the current mode is derived from `prog-mode', home `back-to-indentation'.

If the current line is a wrapped visual line, home to
`beginning-of-visual-line'."
  (interactive)
  (cond ((custom/relative-line-empty)    (beginning-of-line))
	((custom/relative-line-list)     (beginning-of-line-text))
	((custom/relative-line-indented) (back-to-indentation))
	((custom/relative-line-wrapped)  (beginning-of-visual-line))
	((derived-mode-p 'prog-mode)     (back-to-indentation))
	((custom/relative-line-wrapped)  (beginning-of-visual-line))
        (t                               (beginning-of-line-text))))

(defvar custom/double-home-timeout 0.4)

(defun custom/double-home ()
  "Dynamic homing command with a timeout of `custom/double-home-timeout' seconds.
- Single press: `custom/home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
	     (<= (time-to-seconds (time-since last-called)) custom/double-home-timeout))
	(progn (beginning-of-visual-line)
	       (beginning-of-line-text))
      (custom/home)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<home>") #'custom/double-home)

#+end_src

**** previous-line

#+begin_src emacs-lisp

(defun custom/previous-line (orig-fun &rest args)
  "If a region is active and either the current mode is derived from
`prog-mode' or the cursor lies in an `org-babel' source code block,
arrow-up to `end-of-visual-line' of `previous-line'."
  (apply orig-fun args)
  (if (and (region-active-p) (or (derived-mode-p 'prog-mode) (org-in-src-block-p)))
      (progn (point-to-register 'region-up-register)
             (end-of-visual-line))))

(advice-add 'previous-line :around #'custom/previous-line)

(defun custom/region-up-register ()
  "Move cursor to `region-up-register', defined in
`custom/previous-line'."
  (interactive)
  (let ((end (region-end)))
    (ignore-errors (jump-to-register 'region-up-register))
    (set-register 'region-up-register nil)
    (push-mark end)))

(global-set-key (kbd "S-<home>") #'custom/region-up-register)

#+end_src

**** beginning-of-line-text

#+begin_src emacs-lisp

(defun custom/beginning-of-line-text (orig-fun &rest args)
  "Correctly go to `beginning-of-line-text' in numbered lists."
  (interactive)
  (let ((ordered-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}"))
    (if (save-excursion (beginning-of-line)
			    (looking-at-p ordered-line-regex))
	    (progn (beginning-of-line)
		   (re-search-forward ordered-line-regex))
      (apply orig-fun args))))

(advice-add 'beginning-of-line-text :around #'custom/beginning-of-line-text)

#+end_src

*** Window
**** Split and follow

#+begin_src emacs-lisp

;; split and follow
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (other-window 1))
(global-set-key (kbd "C-x 2") #'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (other-window 1))
(global-set-key (kbd "C-x 3") #'split-and-follow-vertically)

#+end_src

**** Previous window
***** Record

#+begin_src emacs-lisp

(defvar custom/window-previous nil
  "Selected window before the last window change.")

(defvar custom/window-pre-command nil
  "Auxiliary variable containing the `selected-window'
before the execution of any command.")

(defun custom/record-window-pre-command ()
  (setq custom/window-pre-command (selected-window)))
(add-hook 'pre-command-hook #'custom/record-window-pre-command)

(defun custom/record-window-previous ()
  (let ((window-post (selected-window)))
    (if (not (eq window-post custom/window-pre-command))
	      (setq custom/window-previous custom/window-pre-command))))
(add-hook 'post-command-hook #'custom/record-window-previous)

#+end_src

***** TODO Command

- if single window, do nothing

#+begin_src emacs-lisp

(defun custom/goto-window-previous ()
  (interactive)
  (let ((target  custom/window-previous)
	      (current (selected-window)))
    (if target
	      (progn (select-window target)
		     (setq custom/window-previous current)))))

(global-set-key (kbd "C-c p") #'custom/goto-window-previous)

#+end_src


** File management
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-file-management.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

*** Buffer
**** Reload from disk

#+begin_src emacs-lisp

(defun custom/reload-from-disk (&optional buffer)
  "Revert BUFFER contents to the contents of its
file saved on disk, ignoring the auto-save file.
If the buffer has unsaved modifications, prompt
the user for confirmation."
  (interactive)
  (let ((buffer (or buffer (current-buffer))))
    (save-window-excursion
      (switch-to-buffer buffer)
      (if (not (buffer-modified-p))
	     (revert-buffer t t)
	   (revert-buffer t nil)))))

(global-set-key (kbd "C-c r") #'custom/reload-from-disk)

#+end_src

*** Batch processing
**** DOS to UNIX

#+begin_src emacs-lisp

;; Transform all files in directory from DOS to Unix line breaks
(defun custom/dos2unix (&optional dir)
  (let ((default-directory (or dir (file-name-directory buffer-file-name))))
    (shell-command "find . -maxdepth 1 -type f -exec dos2unix \\{\\} \\;")))

#+end_src


** PDF
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-pdf.el
:END:
*** Jump

#+begin_src emacs-lisp

(defun custom/pdf-view-jump-to-top ()
  (interactive)
  (image-previous-line 9999))

(defun custom/pdf-view-jump-to-bottom ()
  (interactive)
  (image-next-line 9999))

(define-key pdf-view-mode-map (kbd "<home>") #'custom/pdf-view-jump-to-top)
(define-key pdf-view-mode-map (kbd "<end>")  #'custom/pdf-view-jump-to-bottom)

#+end_src

*** Scroll

#+begin_src emacs-lisp

(defun custom/pdf-view-next-line (&optional arg)
  "Scroll upward by ARG lines. Stay in page."
  (interactive "P")
  (image-next-line (if arg arg 1)))

(defun custom/pdf-view-previous-line (&optional arg)
  "Scroll upward by ARG lines. Stay in page."
  (interactive "P")
  (image-next-line (if arg (* -1 arg) -1)))

(define-key pdf-view-mode-map (kbd "<wheel-down>") #'custom/pdf-view-next-line)
(define-key pdf-view-mode-map (kbd "<wheel-up>")   #'custom/pdf-view-previous-line)
(define-key pdf-view-mode-map (kbd "C-<wheel-down>") (lambda () (interactive) (custom/pdf-view-next-line 10)))
(define-key pdf-view-mode-map (kbd "C-<wheel-up>")   (lambda () (interactive) (custom/pdf-view-previous-line 10)))

#+end_src

*** Fit page

#+begin_src emacs-lisp

(defun custom/pdf-view-fit-height ()
  (interactive)
  (setq pdf-view-display-size 'fit-page)
  (pdf-view-redisplay t)
  (pdf-view-center-in-window)
  (custom/pdf-view-jump-to-top))

(defun custom/pdf-view-fit-width ()
  (interactive)
  (setq pdf-view-display-size 'fit-width)
  (pdf-view-redisplay t)
  (pdf-view-center-in-window))

(define-key pdf-view-mode-map (kbd "<tab>") #'custom/pdf-view-fit-height)
(define-key pdf-view-mode-map (kbd "C-<tab>") #'custom/pdf-view-fit-width)

#+end_src

*** Theme change

#+begin_src emacs-lisp

(defun custom/pdf-refresh-themed-view ()
  (if pdf-view-themed-minor-mode
      (progn (pdf-view-themed-minor-mode -1)
             (pdf-view-themed-minor-mode))))

(add-hook 'custom/enable-or-load-theme-hook #'custom/pdf-refresh-themed-view)

#+end_src

** Org Mode
*** Utilities
**** Get
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-get.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

***** org-get-title

#+begin_src emacs-lisp

(defun custom/org-get-title (&optional buffer)
  (let ((buffer (or buffer (current-buffer))))
    (with-current-buffer buffer
      (nth 1
	   (assoc "TITLE"
		  (org-element-map (org-element-parse-buffer 'greater-element)
		      '(keyword)
		    #'custom/get-keyword-key-value))))))

#+end_src

***** org-get-file-title

#+begin_src emacs-lisp

(defun custom/org-get-file-title (file)
  (with-current-buffer (find-file-noselect file)
       (custom/org-get-title)))

#+end_src

***** org-get-subtree-region

#+begin_src emacs-lisp

(defun custom/org-get-subtree-region (&optional element)
  "Retrieve the beginning and end of the current subtree."
  (if (org-element--cache-active-p)
      (let* ((heading (org-element-lineage
                       (or element (org-element-at-point))
                       '(headline) t))
	     (head (org-element-property :begin heading))
	     (next (org-element-property :end   heading)))
	  (if (and heading next)
	      (progn (save-excursion (goto-char head)
				     (beginning-of-line 2)
				     (setq beg (point)))
		     (save-excursion (goto-char next)
				     (beginning-of-line)
				     (setq end (max beg (point))))
		     (list beg end))))))

#+end_src

***** org-get-subtree-content

#+begin_src emacs-lisp

(defun custom/org-get-subtree-content ()
  "Retrieve the content of the current subtree."
  (setq content (apply #'buffer-substring-no-properties (custom/org-get-subtree-region))))

#+end_src

**** Queries
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-queries.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

***** in
****** org-in-src-block-p

#+begin_src emacs-lisp

;; `org-in-src-block-p' gives false positives as of Org Mode 9.5.3. For
;; this reason, determine if cursor in src block with the more reliable
;; `org-babel-where-is-src-block-head'
(defun custom/org-in-src-block-p (orig-fun &rest args)
  (if args
      (apply orig-fun args)
    (org-babel-where-is-src-block-head)))

(advice-add 'org-in-src-block-p :around #'custom/org-in-src-block-p)

#+end_src

***** at
****** org-at-ellipsis

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis (&optional position)
  (or (custom/org-at-ellipsis-h position) (custom/org-at-ellipsis-l position)))

#+end_src

****** org-at-ellipsis-l

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis-l (&optional position)
  (and (custom/org-relative-line-list-folded) (custom/at-point 'end-of-visual-line)))

#+end_src 

****** org-at-ellipsis-h

#+begin_src emacs-lisp

(defun custom/org-at-ellipsis-h (&optional position) 
  (and (custom/org-relative-line-heading-folded) (custom/at-point 'end-of-visual-line)))

#+END_src 

****** org-at-keyword

#+begin_src emacs-lisp

(defun custom/org-at-keyword (&optional number)
  (custom/relative-line-regex "^#+.*$" number))

#+END_src 

****** org-at-heading

#+begin_src emacs-lisp

(defun custom/org-at-heading (&optional point)
  (let ((point (or point (point))))
    (save-excursion (goto-char point) (custom/org-relative-line-heading))))

#+end_src

****** TODO org-at-bol-list

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-bol-list () 
  (and (custom/org-relative-line-list) (custom/at-point 'beginning-of-line-text)))

#+END_src 

****** TODO org-at-bol-heading

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-bol-heading () 
  (and (custom/org-relative-line-heading) (custom/at-point 'custom/org-goto-heading-bol)))

#+END_src 

****** TODO org-at-eol-heading

- &option point

#+begin_src emacs-lisp

(defun custom/org-at-eol-heading ()
  (and (custom/org-relative-line-heading) (eolp) (not (custom/org-at-ellipsis-h)) (not (custom/org-relative-line-heading-empty))))

#+end_src

***** after
****** org-after-list-or-indent

#+begin_src emacs-lisp

(defun custom/org-after-list-or-indent ()
  (or (custom/org-relative-line-list -1) (custom/relative-line-indented -1)))

#+end_src

***** line
****** org-relative-line-list

#+begin_src emacs-lisp

(defun custom/org-relative-line-list (&optional number)
  (custom/relative-line (lambda () (progn (beginning-of-line-text) (org-at-item-p)))  number))

#+end_src

****** org-relative-line-heading

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading (&optional number)
  (custom/relative-line 'org-at-heading-p number))

#+end_src

****** org-relative-line-paragraph

#+begin_src emacs-lisp

(defun custom/org-relative-line-paragraph (&optional number)
  "Determine whether the current line -or the NUMBER'th line relative to it
is an indented paragraph."
  (let ((number (or number 0)))
    (and (not (custom/org-relative-line-heading number))
	       (not (custom/org-relative-line-list    number))
	       (not (org-in-src-block-p))
	       (custom/relative-line-indented number)
	       (or  (custom/org-relative-line-list      (- number 1))
		    (custom/org-relative-line-paragraph (- number 1))))))

#+end_src

****** org-relative-line-list-empty

#+begin_src emacs-lisp

(defun custom/org-relative-line-list-empty (&optional number)
  (and (custom/org-relative-line-list)
       (or (custom/relative-line-regex "^[[:blank:]]*[-+*]\\{1\\}[[:blank:]]+$" number)
	         (custom/relative-line-regex "^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]+$" number))))

#+end_src

****** org-relative-line-list-folded

#+begin_src emacs-lisp

(defun custom/org-relative-line-list-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded list item."
  (custom/relative-line (lambda () (and (org-at-item-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-empty

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-empty (&optional number)
  (custom/relative-line (lambda () (beginning-of-line-text) (org-point-at-end-of-empty-headline)) number))

#+end_src

****** org-relative-line-heading-folded

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-folded (&optional number)
  "Returns non-nil if `point-at-eol' of current visual line
is on a folded heading."
  (custom/relative-line (lambda () (and (org-at-heading-p) (invisible-p (point-at-eol)))) number))

#+end_src

****** org-relative-line-heading-or-list

#+begin_src emacs-lisp

(defun custom/org-relative-line-heading-or-list (&optional number)
  (custom/relative-line 'org-at-heading-or-item-p number))

#+end_src

***** subtree
****** org-subtree-blank

#+begin_src emacs-lisp

(defun custom/org-subtree-blank ()
  "Return t if the current subtree consists of
a `custom/region-blank'."
  (interactive)
  (apply #'custom/region-blank (custom/org-get-subtree-region)))

#+end_src

****** org-subtree-empty

#+begin_src emacs-lisp

(defun custom/org-subtree-empty ()
  (interactive)
  (string-equal "" (custom/org-get-subtree-content)))

#+end_src

****** org-headings-follow

#+begin_src emacs-lisp

(defun custom/org-headings-follow ()
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
    (save-excursion (custom/org-goto-heading-next)
		           (and (not (= pos (point))) (custom/org-relative-line-heading)))))

#+end_src

****** org-headings-precede

#+begin_src emacs-lisp

(defun custom/org-headings-precede ()
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
    (save-excursion (custom/org-goto-heading-previous)
		          (and (not (= pos (point))) (custom/org-relative-line-heading)))))

#+end_src

****** org-subtree-blank-up-to-point

#+begin_src emacs-lisp

(defun custom/org-subtree-blank-up-to-point ()
  (interactive)
  (let ((heading-eol (save-excursion (custom/org-goto-heading-current) (end-of-line) (point))))
    (custom/region-blank heading-eol (point))))

#+end_src

***** heading
****** org-heading-first-child

#+begin_src emacs-lisp

(defun custom/org-heading-first-child ()
  (save-excursion
    (custom/org-goto-heading-current)
    (let ((pos (custom/get-point 'beginning-of-visual-line)))
      (org-backward-heading-same-level 1)
      (= pos (custom/get-point 'beginning-of-visual-line)))))

#+end_src

****** org-heading-has-children

#+begin_src emacs-lisp

(defun custom/org-heading-has-children ()
  (interactive)
  (save-excursion (org-goto-first-child)))

#+end_src


*** UI
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-ui.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** Theme

#+begin_src emacs-lisp

;; theme reload advice
(defun custom/org-theme-reload ()
  "Re-set Org Mode UI typesetting after theme changes"
  (save-window-excursion
    (cl-loop for buffer in (custom/get-visible-buffers)
	     do (select-window (get-buffer-window buffer))
	     if (string-equal major-mode "org-mode")
             do (custom/org-ui-typeset))))

(add-hook 'custom/enable-or-load-theme-hook #'custom/org-theme-reload)

#+end_src

**** Outline
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-outline.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

- deprecated cl warning
   - find dependency

***** Hide
****** org-hide-previous-subtree

#+begin_src emacs-lisp

(defun custom/org-hide-previous-subtree ()
  "Cycle previous Org Mode heading."
  (save-excursion (custom/org-goto-heading-previous)
		  (outline-hide-subtree)))

#+end_src

***** Show
****** org-show

#+begin_src emacs-lisp

(defun custom/org-show (orig-fun &rest args)
  (if (custom/org-at-ellipsis)
      (progn (custom/org-goto-heading-bol) (apply orig-fun args))
    (apply orig-fun args)))

#+end_src

****** org-show-subtree

#+begin_src emacs-lisp

(advice-add 'org-show-subtree :around #'custom/org-show)

#+end_src

****** org-show-children

#+begin_src emacs-lisp

(advice-add 'org-show-children :around #'custom/org-show)

#+end_src

****** org-show-minimum

#+begin_src emacs-lisp

(defun custom/org-show-minimum ()
  (if (or (custom/org-relative-line-list-folded)
	        (custom/org-relative-line-heading-folded))
      (progn (if (custom/org-at-ellipsis)
		       (progn (beginning-of-visual-line) (end-of-line)))
	           (org-show-entry)
	           (if (custom/org-heading-has-children) (org-show-children)))))

#+end_src

***** TODO Cycle

- bug
   - https://lists.gnu.org/archive/html/emacs-orgmode/2022-05/msg00150.html
   - https://www.reddit.com/r/emacs/comments/ulpdhu/org_mode_command_doesnt_update_a_buffer_if_i_use/

#+begin_src emacs-lisp

(defun custom/org-cycle (orig-fun &rest args)
  "Conditional `org-cycle'.

Default: `org-cycle'

If cursor lies at `end-of-visual-line' of folded heading or list,
move cursor to `end-of-line' of the current visual line and then
call `org-cycle'.

If cursor lies at a paragraph directly under a list item and not
indented at the level of the previous list item, indent the paragraph."
  (interactive)
  (if (or (custom/org-relative-line-list-folded) (custom/org-relative-line-heading-folded))
      (if (= (point) (custom/get-point 'end-of-visual-line))
	  (progn (beginning-of-visual-line)
		 (end-of-line)
		 (apply orig-fun args))
	(apply orig-fun args))
    (if (and (org-in-src-block-p) (not (custom/org-at-keyword)))
	      (org-indent-line)
      (apply orig-fun args))))

(advice-add 'org-cycle :around #'custom/org-cycle)

#+end_src

***** C-Cycle

#+begin_src emacs-lisp

(defun custom/c-cycle ()
  (interactive)
  (if (and (org-in-src-block-p) (not (invisible-p (point-at-eol))))
      (progn (org-babel-goto-src-block-head)
             (org-fold-hide-block-toggle))
    (org-fold-hide-subtree)))

(define-key org-mode-map (kbd "C-<tab>") #'custom/c-cycle)

#+end_src

***** TODO Restore

- Not working

- rewrite get-outline-state and set-outline-state
   - org-macs.el

****** Implementation
******* get-outline-state

#+begin_src emacs-lisp

(defun custom/org-identify-hidden-overlays (overlay &optional use-markers)
  (when (eq (overlay-get overlay 'invisible) 'outline)
    (let ((beg (overlay-start overlay))
          (end (overlay-end overlay)))
      (and beg end (> end beg)
           (if use-markers
               (cons (copy-marker beg)
                     (copy-marker end t))
             (cons beg end))))))

(defun custom/org-get-outline-state (&optional use-markers)
  "Return a list of the locations of all outline overlays.
These are overlays with the `invisible' property value `outline'.
The return value is a list of cons cells, with start and stop
positions for each overlay.
If USE-MARKERS is set, return the positions as markers."
  (let (beg end)
    (org-with-wide-buffer
     (delq nil
       (mapcar 'custom/org-identify-hidden-overlays
           (overlays-in (point-min) (point-max)))))))

#+end_src

******* save-outline-state

#+begin_src emacs-lisp

(defun custom/org-save-outline-state ()
  "Save org outline state in `custom/org-outline-state'.
It can be recovered afterwards with `custom/org-recover-outline-state'."
  (setq custom/org-outline-state (custom/org-get-outline-state t)))

#+end_src

******* set-outline-state

#+begin_src emacs-lisp

(defvar-local custom/org-outline-state nil
  "Variable to save the org outline.")
(put 'custom/org-outline-state 'permanent-local t)

(defun custom/org-set-outline-state (data)
  "Create visibility overlays for all positions in DATA.
DATA should have been made by `custom/org-get-outline-state'."
  (org-with-wide-buffer
   (org-show-all)
   (dolist (c data) (org-flag-region (car c) (cdr c) t 'outline))))

#+end_src

******* restore-outline-state

#+begin_src emacs-lisp

(defun custom/org-restore-outline-state ()
  "Restore Org Mode outline stored in `custom/org-outline-state'."
  (when custom/org-outline-state
    (custom/org-set-outline-state custom/org-outline-state)
    (setq custom/org-outline-state nil)))

#+end_src

****** Advice

#+begin_src emacs-lisp

(defun custom/org-mode (orig-fun &rest args)
  (if (string-equal major-mode "org-mode")
      (progn (custom/org-save-outline-state)
             (apply orig-fun args)
             (custom/org-restore-outline-state))
    (apply orig-fun args)))

(advice-add 'org-mode :around #'custom/org-mode)

#+end_src

**** Typesetting

#+begin_src emacs-lisp

;; UI typesetting
(defun custom/org-ui-typeset ()
  "Typeset the following Org Mode UI elements:
- title of Org Mode documents
- indent typeface used in `org-indent-mode' and `visual-line-mode'"
  (with-eval-after-load 'org-faces       (set-face-attribute 'org-document-title nil :font typeface-title :weight 'regular :height 200))
  (with-eval-after-load 'org-indent-mode (set-face-attribute 'org-indent         nil :inherit '(org-hide fixed-pitch))))

(add-hook 'org-mode-hook #'custom/org-ui-typeset)

#+end_src

**** Variable pitch

#+begin_src emacs-lisp

(defface custom/variable-pitch-marker
  '((nil :inherit fixed-pitch))
  "List marker typeface.")

(defface custom/variable-pitch-indent
  '((nil :inherit fixed-pitch :invisible t))
  "Indent typeface.")

(defvar custom/variable-pitch-keywords '(("^[[:blank:]]*[0-9]+[.\\)]\\{1\\}[[:blank:]]\\{1\\}" 0 'custom/variable-pitch-marker)
					 ("^[[:blank:]]*[-+]\\{1\\}[[:blank:]]\\{1\\}"         0 'custom/variable-pitch-marker)
					 ("^[[:blank:]]+"                                  0 'custom/variable-pitch-indent))
  "Variable pitch font-lock keywords.")

(font-lock-add-keywords 'org-mode custom/variable-pitch-keywords 'append)

#+end_src

**** TODO Continuous numbering of equations

#+begin_src emacs-lisp

;; continuous numbering of Org Mode equations
(defun org-renumber-environment (orig-fun &rest args)
  (let ((results '()) 
        (counter -1)
        (numberp))

    (setq results (cl-loop for (begin .  env) in 
                        (org-element-map (org-element-parse-buffer) 'latex-environment
                          (lambda (env)
                            (cons
                             (org-element-property :begin env)
                             (org-element-property :value env))))
                        do
                        (cond
                         ((and (string-match "\\\\begin{equation}" env)
                               (not (string-match "\\\\tag{" env)))
                          (cl-incf counter)
                          (cons begin counter))
                         ((string-match "\\\\begin{align}" env)
                          (prog2
                              (cl-incf counter)
                              (cons begin counter)                          
                            (with-temp-buffer
                              (insert env)
                              (goto-char (point-min))
                              ;; \\ is used for a new line. Each one leads to a number
                              (cl-incf counter (count-matches "\\\\$"))
                              ;; unless there are nonumbers.
                              (goto-char (point-min))
                              (cl-decf counter (count-matches "\\nonumber")))))
                         (t
                          (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))
  
  (apply orig-fun args))

(advice-add 'org-create-formula-image :around #'org-renumber-environment)

#+end_src


*** Editing
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-editing.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** Text
***** Undo

#+begin_src emacs-lisp

(defun custom/org-undo ()
  (interactive)
  (if (org-babel-where-is-src-block-head)
      (let ((beg (point)))
	         (cond ((eq last-command 'custom/org-return)    (undo 2))
                 ((eq last-command 'custom/smart-comment) (undo 1))
	               (t                                       (undo 1)))
           (if (org-babel-where-is-src-block-head)
	             (save-excursion (goto-char (org-babel-where-is-src-block-head))
				     (next-line)
				     (setq hang (point))))
		 (if (= hang (point))
		     (progn (goto-char beg)
			    (beginning-of-line-text))))
    (undo 1)))

(define-key org-mode-map (kbd "C-/") 'custom/org-undo)

#+end_src

***** Insert
****** Items
******* org-insert-item-respect-content

#+begin_src emacs-lisp

(defun custom/org-insert-item-respect-content ()
  (interactive)
  (let ((struct (org-list-struct))
	    (unfold (if (custom/org-relative-line-list-folded) nil (point-marker))))
    (org-list-set-item-visibility (point-at-bol) struct 'folded)
    (save-excursion
      (beginning-of-visual-line)
      (kill-ring-save (point) (custom/get-point 'beginning-of-line-text)))
    (end-of-visual-line)
    (org-return)
    (yank)
    (if unfold (save-excursion (goto-char unfold) (org-list-set-item-visibility (point-at-bol) struct 'subtree)))))

#+end_src

****** Headings
******* Margins
******** org-heading-margin-post

#+begin_src emacs-lisp

(defun custom/org-heading-margin-post ()
  "Return margin between current heading and next."
  (if (org-current-level)
      (let ((pos            (custom/get-point 'custom/org-goto-heading-bol))
	           (end-of-subtree (custom/get-point 'custom/org-goto-subtree-end))
		   (next-heading   (custom/get-point 'custom/org-goto-heading-next)))
	          (if (not (and (= pos end-of-subtree) (custom/org-relative-line-heading)))
		      (buffer-substring-no-properties end-of-subtree next-heading)
		    ""))
    (if (custom/org-headings-follow)
	       (buffer-substring-no-properties (point) (custom/get-point 'custom/org-goto-heading-next))
      "")))

#+end_src

******** org-heading-margin-delete-post

#+begin_src emacs-lisp

(defun custom/org-heading-margin-delete-post ()
  "Delete newline after new headings created by
`respect-content' heading commands."
  (if (custom/org-subtree-blank)
      (apply 'delete-region (custom/org-get-subtree-region))))

#+end_src

******** org-heading-margin-insert-previous

#+begin_src emacs-lisp

(defun custom/org-heading-margin-insert-previous ()
  "If the previous subtree is not empty,
insert a margin of 1 empty line."
  (let ((insert-margin (save-excursion (if (custom/org-heading-first-child)
					          (custom/org-goto-heading-previous)
					        (org-backward-heading-same-level 1))
				              (not (custom/org-subtree-blank)))))
    (if insert-margin
      (progn (beginning-of-visual-line)
	            (org-return)
		    (beginning-of-line-text)))))

#+end_src

******* org-insert-heading

#+begin_src emacs-lisp

(defun custom/org-insert-heading (command &optional margin)
  "Primitive for custom heading functions.

If cursor if at an Org Mode heading's
ellipsis, go to the `end-of-line' of the
heading's visual line.

If cursor lies on an Org Mode heading,
`custom/org-show-minimum'.

If cursor is outside top level heading,
insert heading at point, without removing
any of the previous space.

If the previous subtree is not empty,
insert a margin of 1 empty line.
This is because Org Mode heading insertion
commands will automatically remove all [[:space:]]
until first preceding non-empty line.

If MARGIN is t:
- insert margin between content under parent heading and new one"
  (interactive)
  (if (custom/org-at-ellipsis-h)         (progn (beginning-of-visual-line) (end-of-line)))
  (if (custom/org-relative-line-heading) (custom/org-show-minimum))
  ;; Insert heading
  (cond ((not (org-current-level)) (insert "* "))
	      (t                         (funcall command)))
  ;; Insert margin
  (if margin (custom/org-heading-margin-insert-previous))
  ;; Hide previous subtree
  (if (save-excursion (custom/org-goto-heading-previous)
		            (custom/org-relative-line-heading-folded))
      (custom/org-hide-previous-subtree)))

#+end_src

******* org-insert-subheading

#+begin_src emacs-lisp

(defun custom/org-insert-subheading (orig-fun &optional arg)
  "Make `org-insert-subheading' ARG optional."
  (interactive)
  (let ((arg (or arg 0)))
    (funcall orig-fun arg)))

(advice-add 'org-insert-subheading :around #'custom/org-insert-subheading)

#+end_src

******* org-insert-heading-at-point

#+begin_src emacs-lisp

(defun custom/org-insert-heading-at-point ()
  (interactive)
  (custom/org-insert-heading 'org-insert-heading (not (custom/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-subheading-at-point

#+begin_src emacs-lisp

(defun custom/org-insert-subheading-at-point ()
  (interactive)
  (custom/org-insert-heading 'org-insert-subheading (not (custom/org-subtree-blank-up-to-point))))

#+end_src

******* org-insert-heading-after-subtree

#+begin_src emacs-lisp

(defun custom/org-insert-heading-after-subtree ()
  "Insert heading after current subtree. As
`org-insert-heading-respect-content' does not
behave well with folded Org Mode headings, if
the previous heading is folded:
1. Unfold the heading
2. Create the new heading after its subtree
3. Fold it back"
  (let ((margin-post        (custom/count-substrings "\n" (custom/org-heading-margin-post)))
	(prev-same-level    (custom/get-point 'beginning-of-visual-line))
	(prev-lower-level   (custom/get-point 'custom/org-goto-child-last))
	(folded-same-level  (custom/org-relative-line-heading-folded))
	(folded-lower-level (save-excursion (custom/org-goto-child-last)
                                            (custom/org-relative-line-heading-folded))))

    ;; Go to current heading
    (custom/org-goto-heading-current)

    ;; Unfold if necessary
    (if folded-same-level  (save-excursion (org-show-subtree)))
    (if folded-lower-level (save-excursion (custom/org-goto-subtree-end) (org-show-subtree)))
    
    ;; Insert heading
    (cond ((not (org-current-level)) (insert "* "))
	        (t                         (progn (custom/org-goto-heading-current) (org-insert-heading-respect-content))))
    (custom/org-heading-margin-delete-post)

    ;; Insert margin with previous heading
    (custom/org-heading-margin-insert-previous)
    
    ;; Fold back if necessary
    (if folded-same-level  (save-excursion (goto-char prev-same-level)  (outline-hide-subtree)))
    (if folded-lower-level (save-excursion (goto-char prev-lower-level) (outline-hide-subtree)))

    ;; Recover margin with following heading
    (if (> margin-post 1) (save-excursion (insert "\n")))))
  
#+end_src

******* org-insert-subheading-after-subtree

#+begin_src emacs-lisp

(defun custom/org-insert-subheading-after-subtree ()
  "`org-insert-subheading' respecting content."
  (interactive)
  (custom/org-show-minimum)
  (if (custom/org-heading-has-children)
      (progn (custom/org-goto-child-last)
	           (custom/org-insert-heading-after-subtree))
    (progn (custom/org-insert-heading-after-subtree)
	         (org-do-demote))))

#+end_src

****** Edition at ellipses

#+begin_src emacs-lisp

(defvar custom/org-functions-at-ellipsis '(org-self-insert-command
					   custom/kill-ring-mouse)
  "Functions whose behavior at Org Mode ellipses
will be advised by `custom/org-edit-at-ellipsis'")

(defun custom/org-edit-at-ellipsis (orig-fun &rest args)
  "Execute commands invoked at an Org Mode heading's
ellipsis in the first line under the heading."
  (if (custom/org-at-ellipsis-h)
      (progn (beginning-of-visual-line)
	     (custom/org-show-minimum)
	     (end-of-line)
	     (org-return)
	     (apply orig-fun args))
    (apply orig-fun args)))

(dolist (function custom/org-functions-at-ellipsis)
  (advice-add function :around #'custom/org-edit-at-ellipsis))

#+end_src

***** Return
****** return

- References
   - https://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/

#+begin_src emacs-lisp

;; org-return
(defun custom/org-return ()
  "Conditional `org-return'."
  (interactive)
  (cond ((custom/org-relative-line-list-empty)          (progn (custom/delete-line) (org-return)))
	     ((custom/org-at-bol-list)                       (progn (beginning-of-visual-line) (org-return) (beginning-of-line-text)))
	     ((custom/org-at-ellipsis-l)                     (custom/org-insert-item-respect-content))
	     ((custom/org-relative-line-paragraph)           (org-insert-item))
	     ((custom/org-relative-line-list)                (org-meta-return))
	     ((and (custom/org-after-list-or-indent) (bolp)) (org-return))
	     ((custom/org-at-bol-heading)                    (save-excursion (beginning-of-visual-line) (org-return t)))
	     ((custom/org-at-eol-heading)                    (progn (newline 2) (if (custom/org-subtree-blank) (progn (newline) (previous-line)))))
	     ((custom/org-at-ellipsis-h)                     (org-return))
	     (t                                              (org-return t))))

(define-key org-mode-map (kbd "<return>") 'custom/org-return)

#+end_src

****** TODO C-return

- at ellipsis -> doesn't work

- on non-empty line
   - insert heading at line

- list paragraphs
   - custom/org-toggle-paragraph
      - keep cursor in place

- bugs
   - if at empty heading or heading separated by more than 1 empty line from next
      - star is inserted in line of next heading
         - "* " is inserted in line of next heading
   - cycle previous heading to remove spurious separation line

- if list not empty -> move contents to new item
- if after list
   - create list item from current line
- if before list
   - create list item at top of list

- if at indented paragraph in list
   - turn paragraph into list item
- if at non-empty line, turn entire non-empty line into either header or list item
   - if at middle of word inside list
      - new indented list item, break word and place second part in new item

#+begin_src emacs-lisp

;; org-meta-return
(defun custom/org-control-return ()
  (interactive)
  (cond ((custom/org-relative-line-list-empty) (progn (org-meta-return) (next-line) (end-of-line)))
	    ((custom/org-relative-line-heading)    (custom/org-insert-heading-after-subtree))
	    ((custom/org-relative-line-list)       (progn (end-of-line) (org-meta-return)))
	    ((custom/org-relative-line-paragraph)  (custom/org-paragraph-toggle))
	    (t                                     (custom/org-insert-heading-after-subtree))))

(define-key org-mode-map (kbd "C-<return>") #'custom/org-control-return)

#+end_src

****** M-return

#+begin_src emacs-lisp

(defun custom/org-meta-return ()
  (interactive)
  (custom/org-insert-subheading-after-subtree))

(define-key org-mode-map (kbd "M-<return>") 'custom/org-meta-return)

#+end_src

****** TODO S-return

- heading with keywords
   - skip keywords

#+begin_src emacs-lisp

(defun custom/org-super-return ()
  (interactive)
  (cond ((or (custom/org-relative-line-list)
	         (custom/org-relative-line-paragraph)) (org-return t))
	    (t                                         (custom/org-insert-subheading-at-point))))

(define-key org-mode-map (kbd "S-<return>") 'custom/org-super-return)

#+end_src

****** MS-return

#+begin_src emacs-lisp
 
(define-key org-mode-map (kbd "M-S-<return>") 'custom/org-insert-heading-at-point)

#+end_src

****** CS-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-S-<return>") 'org-insert-todo-heading)

#+end_src

****** CM-return

#+begin_src emacs-lisp

(define-key org-mode-map (kbd "C-M-<return>") 'org-insert-todo-subheading)

#+end_src

***** Delete
****** Hungry

#+begin_src emacs-lisp

(defun custom/org-delete-hungry ()
  "If the region starts at the beginning of an 
indented line and the cursor lies on an Org Mode
src block, delete the region and its indent plus 
one character."
  (interactive)
  (custom/@delete-hungry (org-in-src-block-p)))

#+end_src

****** TODO Forward

- next line = empty list item -> delete next line

#+begin_src emacs-lisp

(defun custom/org-nimble-delete-forward ()
  "Org Mode complement to `custom/nimble-delete-forward'."
  (interactive)
  (cond ((and (custom/org-at-ellipsis-h)
	           (custom/org-relative-line-heading 1))  (progn (beginning-of-visual-line 2)
								 (beginning-of-line-text)
								 (delete-forward-char 1)))
	      (t (custom/nimble-delete-forward))))

(define-key org-mode-map (kbd "<delete>") 'custom/org-nimble-delete-forward)

#+end_src

****** TODO Backward

- bullets with extra space between marker and text
   -    no action

- if at beginning of empty heading and a heading lies below
   - bring next heading to level of current one
      - delete newline + stars of the next heading
- delete empty heading
   - go to previous line
   - delete newline
      - maybe cycle previous

#+begin_src emacs-lisp

(defun custom/org-nimble-delete-backward ()
  "Org Mode complement to `custom/nimble-delete-backward'."
  (interactive)
  (cond ((and (region-active-p)
	           (not (custom/region-blank)))                 (custom/org-delete-hungry))
	     ((or  (custom/org-at-ellipsis-h)
		   (custom/org-at-ellipsis-l))                  (progn (beginning-of-visual-line) (end-of-line) (delete-backward-char 1)))
	     ((and (or (custom/org-relative-line-heading-empty)
		       (custom/org-relative-line-list-empty))
		   (org-current-level))                         (delete-region (point) (custom/get-point 'end-of-line 0)))
	     ((or  (custom/org-relative-line-heading-empty)
		   (custom/org-relative-line-list-empty))       (delete-region (point) (custom/get-point 'beginning-of-visual-line)))
	     ((custom/org-at-bol-list)                          (custom/org-toggle-item))
        (t                                                 (custom/nimble-delete-backward))))

(define-key org-mode-map (kbd "<backspace>") 'custom/org-nimble-delete-backward)

#+end_src

***** Toggle
****** org-toggle-item

#+begin_src emacs-lisp

(defun custom/org-toggle-item ()
  (interactive)
  (let ((toggle-off (custom/org-relative-line-list))
	     (indent     (+ 1 org-list-indent-offset))
	     (marker     (point)))
    (beginning-of-line-text)
    (delete-backward-char indent)
    (if toggle-off
	     (insert (make-string indent ?\s))
      (org-toggle-item 0))
    (goto-char marker)))

#+end_src

**** Structure
***** TODO indent-region

- use markers
   - https://www.gnu.org/software/emacs/manual/html_node/elisp/Overview-of-Markers.html
  
- regions spanning headings
   - nested headings
      - indent of 1 for every heading from top level in region
- bad interaction with wrapped lines

#+begin_src emacs-lisp

(defun custom/org-indent-region (command &rest args)
  "Indent Org Mode region.

If the region spans Org Mode headings or items:
1. Extend region by pushing `region-beginning' to its
`beginning-of-visual-line'
2. Execute COMMAND
3. Restore the region to its previous limits, shifting
its limits to match shifts in the position of the
text it spans, such as when indenting with `org-metaright'
or outdenting with `org-metaleft'."
  (if (or (custom/org-relative-line-heading) (custom/org-relative-line-list))
      (let ((beg (region-beginning))
	         (end (region-end))
		 (pos (point)))
	
	        ;; Determine mark
	        (setq mark (if (= pos beg) end beg))
		;; Count lines in region
		(setq lines (count-screen-lines beg end))

		;; Get initial cursor position wrt bol
		(setq relative-pos-0 (- pos (custom/get-point 'beginning-of-line)))
		;; Execute command
		(save-excursion (goto-char beg)
				(push-mark (custom/get-point 'beginning-of-line))
		 		(goto-char end)
				(end-of-visual-line)
				(apply command args))
		;; Get aftermath cursor position
		(setq pos-1 (point))
		;; Calculate cursor displacement
		(setq disp (- pos-1 pos))
		
           ;; Get aftermath cursor position wrt bol
		(setq relative-pos-1 (- pos-1 (custom/get-point 'beginning-of-line)))
		;; Calculate cursor displacement wrt bol
		(setq relative-disp (- relative-pos-1 relative-pos-0))

		;; Calculate mark shift
		(cond
		 ((custom/org-at-heading beg)  (setq shift disp))
		 ((= mark beg)                 (setq shift relative-disp))
		 ((= mark end)                 (setq shift (* relative-disp lines))))

		;; Push mark
		(push-mark (+ mark shift)))
    (apply command args)))

#+end_src

**** Preferences
***** Keep text selection after executing commands

#+begin_src emacs-lisp

(defun custom/with-mark-active (&rest args)
  "Keep mark active after command. To be used as advice AFTER any
function that sets `deactivate-mark' to t."
  (setq deactivate-mark nil))

(advice-add 'org-metaright      :after #'custom/with-mark-active)
(advice-add 'org-metaleft       :after #'custom/with-mark-active)
(advice-add 'org-metaup         :after #'custom/with-mark-active)
(advice-add 'org-metadown       :after #'custom/with-mark-active)

(advice-add 'org-shiftmetaright :after #'custom/with-mark-active)
(advice-add 'org-shiftmetaleft  :after #'custom/with-mark-active)
(advice-add 'org-shiftmetaup    :after #'custom/with-mark-active)
(advice-add 'org-shift-metadown :after #'custom/with-mark-active)

#+end_src

***** Do not insert newline before Org Mode headigs

#+begin_src emacs-lisp

;; Do not insert newline before Org Mode headings
(setf org-blank-before-new-entry '((heading . nil) (plain-list-item . nil)))

#+end_src


*** Navigation
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-navigation.el
:END:

#+begin_src emacs-lisp
;;; -*- lexical-binding: t; -*-
#+end_src

**** Line
***** org-end

#+begin_src emacs-lisp

(defun custom/org-end ()
  "Conditional end in Org Mode.

Default: `custom/end'

If `org-at-table-p', go to `org-table-end-of-field'."
  (cond ((and (region-active-p) (custom/org-relative-line-heading-folded)) (end-of-line))
        ((org-at-table-p)                                                  (org-table-end-of-field 1))
	(t                                                                 (end-of-visual-line))))

(defvar custom/org-double-end-timeout 0.4)

(defun custom/org-double-end ()
  "Dynamic homing command with a timeout of `custom/org-double-end-timeout' seconds.
- Single press: `custom/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) custom/org-double-end-timeout)
	         (not (org-at-table-p)))
        (progn (beginning-of-visual-line) (end-of-line))
      (custom/org-end)))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-mode-map (kbd "<end>") 'custom/org-double-end)

#+end_src

***** TODO org-home

- home in invisible tags -> to beginning of tag text

#+begin_src emacs-lisp

(defun custom/org-home ()
     "Conditional homing in Org Mode.

Default: `custom/home'

If a multi-visual-line region is active and the cursor lies on a heading or
list item, home to `beginning-of-visual-line'.

If a region is active the cursor lies `custom/org-at-ellipsis-h', home to
`beginning-of-visual-line'.

If the cursor lies `custom/org-at-ellipsis-h' (no active region), home to
the `beginning-of-line-text' of the heading's visual line.

If the cursor lies on at heading or list, home to `beginning-of-line-text'.

If the cursor lies in a source code block, and the current line is a wrapped
visual line, home to `beginning-of-visual-line'.

If the cursor lies in a source code block, home `back-to-indentation'.

If `org-at-table-p', home to `org-table-beginning-of-field'."
   (interactive)
   (cond ((and (custom/region-multiline-visual) (custom/org-relative-line-heading-or-list))  (beginning-of-visual-line))
         ((and (region-active-p) (custom/org-at-ellipsis-h))                                 (beginning-of-visual-line))
         ((custom/org-at-ellipsis-h)                                                         (custom/org-goto-heading-bol))
	     ((custom/org-at-ellipsis-l)                                                         (custom/org-goto-heading-bol))
	     ((custom/relative-line-wrapped)                                                     (beginning-of-visual-line))
         ((custom/org-relative-line-heading-or-list)                                         (beginning-of-line-text))
         ((org-in-src-block-p)                                                               (back-to-indentation))
	     ((org-at-table-p)                                                                   (org-table-beginning-of-field 1))
         (t                                                                                  (custom/home))))

(defvar custom/org-double-home-timeout 0.4)

(defun custom/org-double-home ()
  "Dynamic homing command with a timeout of `custom/org-double-home-timeout' seconds.
- Single press: `custom/org-home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) custom/org-double-home-timeout)
	         (not (org-at-table-p)))
	    (beginning-of-line)
      (custom/org-home)))
  (put this-command 'custom/last-call-time (current-time)))

(define-key org-mode-map (kbd "<home>") 'custom/org-double-home)

#+end_src

**** Subtree
***** org-goto-child-last

#+begin_src emacs-lisp

(defun custom/org-goto-child-last ()
  (if (org-current-level)
      (progn (custom/org-goto-subtree-end)
	     (custom/org-goto-heading-current))))

#+end_src

***** org-goto-subtree-end

#+begin_src emacs-lisp

(defun custom/org-goto-subtree-end ()
  (custom/org-goto-heading-current)
  (org-end-of-subtree)
  (if (custom/org-relative-line-heading-folded) (end-of-visual-line)))

#+end_src

**** Heading
***** org-goto-heading-bol

#+begin_src emacs-lisp

(defun custom/org-goto-heading-bol ()
  (beginning-of-visual-line)
  (beginning-of-line-text))

#+end_src

***** org-goto-heading-next

#+begin_src emacs-lisp

(defun custom/org-goto-heading-next ()
  (custom/org-goto-heading-current)
  (let ((pos (custom/get-point 'beginning-of-visual-line)))
       (org-forward-heading-same-level 1)
       (if (= pos (point))
	   (progn (custom/org-goto-heading-parent)
		  (org-forward-heading-same-level 1)))))

#+end_src

***** org-goto-heading-parent

#+begin_src emacs-lisp

(defun custom/org-goto-heading-parent ()
  (let ((current (custom/get-point 'beginning-of-visual-line)))
    (if (and (org-current-level)
	        (not (= 1 (org-current-level)))
		(= current (custom/get-point 'beginning-of-visual-line)))
	   (outline-up-heading 1))))

#+end_src

***** org-goto-heading-current

#+begin_src emacs-lisp

(defun custom/org-goto-heading-current ()
  (if (org-current-level) (outline-back-to-heading)))

#+end_src

***** org-goto-heading-previous

#+begin_src emacs-lisp

(defun custom/org-goto-heading-previous ()
  (custom/org-goto-heading-current)
  (let ((current (custom/get-point 'beginning-of-visual-line)))
    ;; go to previous same-level heading
    (org-backward-heading-same-level 1)
    ;; if there was no previous same-level heading, go to parent if not at top
    (if (= (point) current)
	    (custom/org-goto-heading-parent)
      ;; else, attempt going to last subheading of previous same-level heading
      (custom/org-goto-child-last))))

#+end_src

**** Custom link types

Macros to make the creation of custom link types a breeze.

***** Link to items in a specific directory

#+begin_src emacs-lisp

(defmacro @custom/org-dir-link-complete (name dir)
  `(defun ,(intern (concat "org-" name "-link-complete")) ()
     "Create an org-link target string to a file in org-`name'-link-complete."
     (concat ,name ":" (file-relative-name (read-file-name "File: " ,dir) ,dir))))

(defmacro @custom/org-dir-link-follow (name dir)
  `(defun ,(intern (concat "org-" name "-link-follow")) (link)
     "Follow an org-link to a file in org-`name'-link-follow."
     (find-file (expand-file-name link ,dir))))

(defmacro @custom/org-dir-link (name dir)
  `(progn (@custom/org-dir-link-complete ,name ,dir)
          (@custom/org-dir-link-follow   ,name ,dir)
          (org-link-set-parameters ,name
                                   :complete ',(intern (concat "org-" name "-link-complete"))
                                   :follow   ',(intern (concat "org-" name "-link-follow")))))

#+end_src


*** Applications
:PROPERTIES:
:header-args:emacs-lisp+: :tangle ./extensions/shapes-org-applications.el
:END:
**** org-babel
***** TODO Result formatting

Modify ~org-babel-insert-result~ such that a list stores all result insertion formats,
allowing users to easily add custom result insertion formats.

- [[https://www.reddit.com/r/emacs/comments/z3lz0d/orgbabel_custom_result_formatting_automatic/][Discussion on Reddit]]

****** Default formats

#+begin_src emacs-lisp

(defvar custom/org-babel-result-wrap-formats
  '(((assq :wrap (nth 2 info))
     (let* ((full (or (cdr (assq :wrap (nth 2 info))) "results"))
	    (split (split-string full))
	    (type (car split))
	   (opening-line (concat "#+begin_" full))
	   (closing-line (concat "#+end_" type)))
       (cond
        ;; Escape contents from "export" wrap.  Wrap
        ;; inline results within an export snippet with
        ;; appropriate value.
        ((eq t (compare-strings type nil nil "export" nil nil t))
	 (let ((backend (pcase split
			  (`(,_) "none")
			  (`(,_ ,b . ,_) b))))
	   (funcall wrap
		    opening-line closing-line
		    nil nil
		    (format "{{{results(@@%s:"
			    backend) "@@)}}}")))
        ;; Escape contents from "example" wrap.  Mark
        ;; inline results as verbatim.
	((eq t (compare-strings type nil nil "example" nil nil t))
	 (funcall wrap
		  opening-line closing-line
		  nil nil
		  "{{{results(=" "=)}}}"))
	;; Escape contents from "src" wrap.  Mark
	;; inline results as inline source code.
	((eq t (compare-strings type nil nil "src" nil nil t))
	 (let ((inline-open
		(pcase split
		  (`(,_)
		   "{{{results(src_none{")
		  (`(,_ ,language)
		   (format "{{{results(src_%s{" language))
		  (`(,_ ,language . ,rest)
		   (let ((r (mapconcat #'identity rest " ")))
		     (format "{{{results(src_%s[%s]{"
			     language r))))))
	   (funcall wrap
		    opening-line closing-line
		    nil nil
		    inline-open "})}}}")))
	;; Do not escape contents in non-verbatim
	;; blocks.  Return plain inline results.
	(t
	 (funcall wrap
		  opening-line closing-line
		  t nil
		  "{{{results(" ")}}}")))))
    ((member "html" result-params)
     (funcall wrap "#+begin_export html" "#+end_export" nil nil
	      "{{{results(@@html:" "@@)}}}"))
    ((member "latex" result-params)
     (funcall wrap "#+begin_export latex" "#+end_export" nil nil
	      "{{{results(@@latex:" "@@)}}}"))
    ((member "org" result-params)
     (goto-char beg) (when (org-at-table-p) (org-cycle))
     (funcall wrap "#+begin_src org" "#+end_src" nil nil
	      "{{{results(src_org{" "})}}}"))
    ((member "code" result-params)
     (let ((lang (or lang "none")))
       (funcall wrap (format "#+begin_src %s%s" lang results-switches)
		"#+end_src" nil nil
		(format "{{{results(src_%s[%s]{" lang results-switches)
		"})}}}")))
    ((member "raw" result-params)
     (goto-char beg) (when (org-at-table-p) (org-cycle)))
    ((or (member "drawer" result-params)
	 ;; Stay backward compatible with <7.9.2
	 (member "wrap" result-params))
     (goto-char beg) (when (org-at-table-p) (org-cycle))
     (funcall wrap ":results:" ":end:" 'no-escape nil
	      "{{{results(" ")}}}"))
    ((and inline (member "file" result-params))
     (funcall wrap nil nil nil nil "{{{results(" ")}}}"))
    ((and (not (funcall tabulablep result))
	  (not (member "file" result-params)))
     (let ((org-babel-inline-result-wrap
	    ;; Hard code {{{results(...)}}} on top of
	    ;; customization.
	    (format "{{{results(%s)}}}"
		    org-babel-inline-result-wrap)))
       (org-babel-examplify-region
	beg end results-switches inline)))))

#+end_src

****** Custom formats
******* LaTeX equations

Display results inside of a LaTeX ~equation~ environment, and automatically preview it with ~org-latex-preview~.

#+begin_src emacs-lisp

(add-to-list 'custom/org-babel-result-wrap-formats
             '((member "latex-eq" result-params)
               (progn (funcall wrap "\\begin{equation}" "\\end{equation}" nil nil
	                       "{{{results(@@latex:" "@@)}}}"))
                      (org-latex-preview)))

#+end_src

****** Patch

#+begin_src emacs-lisp

(el-patch-feature org-babel)
(el-patch-defun org-babel-insert-result (result &optional result-params info hash lang exec-time)
  "Insert RESULT into the current buffer.

By default RESULT is inserted after the end of the current source
block.  The RESULT of an inline source block usually will be
wrapped inside a `results' macro and placed on the same line as
the inline source block.  The macro is stripped upon export.
Multiline and non-scalar RESULTS from inline source blocks are
not allowed.  When EXEC-TIME is provided it may be included in a
generated message.  With optional argument RESULT-PARAMS controls
insertion of results in the Org mode file.  RESULT-PARAMS can
take the following values:

replace - (default option) insert results after the source block
          or inline source block replacing any previously
          inserted results.

silent -- no results are inserted into the Org buffer but
          the results are echoed to the minibuffer and are
          ingested by Emacs (a potentially time consuming
          process).

none ---- no results are inserted into the Org buffer nor
          echoed to the minibuffer. they are not processed into
          Emacs-lisp objects at all.

file ---- the results are interpreted as a file path, and are
          inserted into the buffer using the Org file syntax.

list ---- the results are interpreted as an Org list.

raw ----- results are added directly to the Org file.  This is
          a good option if you code block will output Org
          formatted text.

drawer -- results are added directly to the Org file as with
          \"raw\", but are wrapped in a RESULTS drawer or results
          macro, allowing them to later be replaced or removed
          automatically.

org ----- results are added inside of a \"src_org{}\" or \"#+BEGIN_SRC
          org\" block depending on whether the current source block is
          inline or not.  They are not comma-escaped when inserted,
          but Org syntax here will be discarded when exporting the
          file.

html ---- results are added inside of a #+BEGIN_EXPORT HTML block
          or html export snippet depending on whether the current
          source block is inline or not.  This is a good option
          if your code block will output html formatted text.

latex --- results are added inside of a #+BEGIN_EXPORT LATEX
          block or latex export snippet depending on whether the
          current source block is inline or not.  This is a good
          option if your code block will output latex formatted
          text.

code ---- the results are extracted in the syntax of the source
          code of the language being evaluated and are added
          inside of a source block with the source-code language
          set appropriately.  Also, source block inlining is
          preserved in this case.  Note this relies on the
          optional LANG argument.

list ---- the results are rendered as a list.  This option not
          allowed for inline source blocks.

table --- the results are rendered as a table.  This option not
          allowed for inline source blocks.

INFO may provide the values of these header arguments (in the
`header-arguments-alist' see the docstring for
`org-babel-get-src-block-info'):

:file --- the name of the file to which output should be written.

:wrap --- the effect is similar to `latex' in RESULT-PARAMS but
          using the argument supplied to specify the export block
          or snippet type."
  (cond ((stringp result)
	 (setq result (org-no-properties result))
	 (when (member "file" result-params)
	   (setq result
                 (org-babel-result-to-file
		  result
		  (org-babel--file-desc (nth 2 info) result)
                  'attachment))))
	((listp result))
	(t (setq result (format "%S" result))))

  (if (and result-params (member "silent" result-params))
      (progn (message (replace-regexp-in-string "%" "%%" (format "%S" result)))
	     result)
    (let ((inline (let ((context (org-element-context)))
		    (and (memq (org-element-type context)
			       '(inline-babel-call inline-src-block))
			 context))))
      (when inline
	(let ((warning
	       (or (and (member "table" result-params) "`:results table'")
		   (and result (listp result) "list result")
		   (and result (string-match-p "\n." result) "multiline result")
		   (and (member "list" result-params) "`:results list'"))))
	  (when warning
	    (user-error "Inline error: %s cannot be used" warning))))
      (save-excursion
	(let* ((visible-beg (point-min-marker))
	       (visible-end (copy-marker (point-max) t))
	       (inline (let ((context (org-element-context)))
			 (and (memq (org-element-type context)
				    '(inline-babel-call inline-src-block))
			      context)))
	       (existing-result (org-babel-where-is-src-block-result t nil hash))
	       (results-switches (cdr (assq :results_switches (nth 2 info))))
	       ;; When results exist outside of the current visible
	       ;; region of the buffer, be sure to widen buffer to
	       ;; update them.
	       (outside-scope (and existing-result
				   (buffer-narrowed-p)
				   (or (> visible-beg existing-result)
				       (<= visible-end existing-result))))
	       beg end indent)
	  ;; Ensure non-inline results end in a newline.
	  (when (and (org-string-nw-p result)
		     (not inline)
		     (not (string-equal (substring result -1) "\n")))
	    (setq result (concat result "\n")))
	  (unwind-protect
	      (progn
		(when outside-scope (widen))
		(if existing-result (goto-char existing-result)
		  (goto-char (org-element-property :end inline))
		  (skip-chars-backward " \t"))
		(unless inline
		  (setq indent (current-indentation))
		  (forward-line 1))
		(setq beg (point))
		(cond
		 (inline
		   ;; Make sure new results are separated from the
		   ;; source code by one space.
		   (unless existing-result
		     (insert " ")
		     (setq beg (point))))
		 ((member "replace" result-params)
		  (delete-region (point) (org-babel-result-end)))
		 ((member "append" result-params)
		  (goto-char (org-babel-result-end)) (setq beg (point-marker)))
		 ((member "prepend" result-params))) ; already there
		(setq results-switches
		      (if results-switches (concat " " results-switches) ""))
		(let ((wrap
		       (lambda (start finish &optional no-escape no-newlines
				      inline-start inline-finish)
			 (when inline
			   (setq start inline-start)
			   (setq finish inline-finish)
			   (setq no-newlines t))
			 (let ((before-finish (copy-marker end)))
			   (goto-char end)
			   (insert (concat finish (unless no-newlines "\n")))
			   (goto-char beg)
			   (insert (concat start (unless no-newlines "\n")))
			   (unless no-escape
			     (org-escape-code-in-region
			      (min (point) before-finish) before-finish))
			   (goto-char end))))
		      (tabulablep
		       (lambda (r)
			 ;; Non-nil when result R can be turned into
			 ;; a table.
                         (and (proper-list-p r)
			      (cl-every
                               (lambda (e) (or (atom e) (proper-list-p e)))
			       result)))))
		  ;; insert results based on type
		  (cond
		   ;; Do nothing for an empty result.
		   ((null result))
		   ;; Insert a list if preferred.
		   ((member "list" result-params)
		    (insert
		     (org-trim
		      (org-list-to-generic
		       (cons 'unordered
			     (mapcar
			      (lambda (e)
				(list (if (stringp e) e (format "%S" e))))
			      (if (listp result) result
				(split-string result "\n" t))))
		       '(:splicep nil :istart "- " :iend "\n")))
		     "\n"))
		   ;; Try hard to print RESULT as a table.  Give up if
		   ;; it contains an improper list.
		   ((funcall tabulablep result)
		    (goto-char beg)
		    (insert (concat (orgtbl-to-orgtbl
				     (if (cl-every
					  (lambda (e)
					    (or (eq e 'hline) (listp e)))
					  result)
					 result
				       (list result))
				     nil)
				    "\n"))
		    (goto-char beg)
		    (when (org-at-table-p) (org-table-align))
		    (goto-char (org-table-end)))
		   ;; Print verbatim a list that cannot be turned into
		   ;; a table.
		   ((listp result) (insert (format "%s\n" result)))
		   ((member "file" result-params)
		    (when inline
		      (setq result (org-macro-escape-arguments result)))
		    (insert result))
		   ((and inline (not (member "raw" result-params)))
		    (insert (org-macro-escape-arguments
			     (org-babel-chomp result "\n"))))
		   (t (goto-char beg) (insert result)))
		  (setq end (copy-marker (point) t))
		  ;; Possibly wrap result.
		  (el-patch-swap
                    (cond
		     ((assq :wrap (nth 2 info))
		      (let* ((full (or (cdr (assq :wrap (nth 2 info))) "results"))
			     (split (split-string full))
			     (type (car split))
			     (opening-line (concat "#+begin_" full))
			     (closing-line (concat "#+end_" type)))
		        (cond
		         ;; Escape contents from "export" wrap.  Wrap
		         ;; inline results within an export snippet with
		         ;; appropriate value.
		         ((eq t (compare-strings type nil nil "export" nil nil t))
			  (let ((backend (pcase split
					   (`(,_) "none")
					   (`(,_ ,b . ,_) b))))
			    (funcall wrap
				     opening-line closing-line
				     nil nil
				     (format "{{{results(@@%s:"
					     backend) "@@)}}}")))
		         ;; Escape contents from "example" wrap.  Mark
		         ;; inline results as verbatim.
		         ((eq t (compare-strings type nil nil "example" nil nil t))
			  (funcall wrap
				   opening-line closing-line
				   nil nil
				   "{{{results(=" "=)}}}"))
		         ;; Escape contents from "src" wrap.  Mark
		         ;; inline results as inline source code.
		         ((eq t (compare-strings type nil nil "src" nil nil t))
			  (let ((inline-open
			         (pcase split
				   (`(,_)
				    "{{{results(src_none{")
				   (`(,_ ,language)
				    (format "{{{results(src_%s{" language))
				   (`(,_ ,language . ,rest)
				    (let ((r (mapconcat #'identity rest " ")))
				      (format "{{{results(src_%s[%s]{"
					      language r))))))
			    (funcall wrap
				     opening-line closing-line
				     nil nil
				     inline-open "})}}}")))
		         ;; Do not escape contents in non-verbatim
		         ;; blocks.  Return plain inline results.
		         (t
			  (funcall wrap
				   opening-line closing-line
				   t nil
				   "{{{results(" ")}}}")))))
		     ((member "html" result-params)
		      (funcall wrap "#+begin_export html" "#+end_export" nil nil
			       "{{{results(@@html:" "@@)}}}"))
		     ((member "latex" result-params)
		      (funcall wrap "#+begin_export latex" "#+end_export" nil nil
			       "{{{results(@@latex:" "@@)}}}"))
		     ((member "org" result-params)
		      (goto-char beg) (when (org-at-table-p) (org-cycle))
		      (funcall wrap "#+begin_src org" "#+end_src" nil nil
			       "{{{results(src_org{" "})}}}"))
		     ((member "code" result-params)
		      (let ((lang (or lang "none")))
		        (funcall wrap (format "#+begin_src %s%s" lang results-switches)
			         "#+end_src" nil nil
			         (format "{{{results(src_%s[%s]{" lang results-switches)
			         "})}}}")))
		     ((member "raw" result-params)
		      (goto-char beg) (when (org-at-table-p) (org-cycle)))
		     ((or (member "drawer" result-params)
			  ;; Stay backward compatible with <7.9.2
			  (member "wrap" result-params))
		      (goto-char beg) (when (org-at-table-p) (org-cycle))
		      (funcall wrap ":results:" ":end:" 'no-escape nil
			       "{{{results(" ")}}}"))
		     ((and inline (member "file" result-params))
		      (funcall wrap nil nil nil nil "{{{results(" ")}}}"))
		     ((and (not (funcall tabulablep result))
			   (not (member "file" result-params)))
		      (let ((org-babel-inline-result-wrap
			     ;; Hard code {{{results(...)}}} on top of
			     ;; customization.
			     (format "{{{results(%s)}}}"
				     org-babel-inline-result-wrap)))
		        (org-babel-examplify-region
		         beg end results-switches inline))))
                  (let ((formats (copy-tree custom/org-babel-result-wrap-formats)))
                    (eval (add-to-list 'formats 'cond)))))
                ;; Possibly indent results in par with #+results line.
		(when (and (not inline) (numberp indent) (> indent 0)
			   ;; In this case `table-align' does the work
			   ;; for us.
			   (not (and (listp result)
				     (member "append" result-params))))
		  (indent-rigidly beg end indent))
                (let ((time-info
                       ;; Only show the time when something other than
                       ;; 0s will be shown, i.e. check if the time is at
                       ;; least half of the displayed precision.
                       (if (and exec-time (> (float-time exec-time) 0.05))
                           (format " (took %.1fs)" (float-time exec-time))
                         "")))
                  (if (null result)
                      (if (member "value" result-params)
                          (message "Code block returned no value%s." time-info)
                        (message "Code block produced no output%s." time-info))
                    (message "Code block evaluation complete%s." time-info))))
	    (set-marker end nil)
	    (when outside-scope (narrow-to-region visible-beg visible-end))
	    (set-marker visible-beg nil)
	    (set-marker visible-end nil)))))))

#+end_src
