#+title:Emacs Configuration File
#+STARTUP: content
#+PROPERTY: header-args:emacs-lisp :results none :tangle ./init.el :mkdirp yes

* Setup

#+begin_src emacs-lisp

;;; -*- lexical-binding: t; -*-

#+end_src

** Startup
*** Frame

#+begin_src emacs-lisp

;; Initial frame size
(add-to-list 'default-frame-alist '(height . 50))
(add-to-list 'default-frame-alist '(width  . 70))

#+end_src

*** Buffers

#+begin_src emacs-lisp

;; Initial buffer
(setq initial-buffer-choice nil)

;; Buffers opened at startup
(defvar custom/background-buffers
  '("~/.emacs.d/init.org" "~/.emacs.d/org.org" "~/.emacs.d/backlog.org" "/home/emacs/test.org"))

(defun custom/spawn-background-buffers ()
  (cl-loop for buffer in custom/background-buffers
	   collect (find-file-noselect buffer)))

(add-hook 'after-init-hook #'custom/spawn-background-buffers)

#+end_src

*** Directory

#+begin_src emacs-lisp

;; Default directory
(setq default-directory "~/.emacs.d/")

#+end_src
** System information
*** Config directory

#+begin_src emacs-lisp

;; Config directory
(setq config-directory "~/.emacs.d/")

#+end_src

** Package management
*** straight.el

#+begin_src emacs-lisp

;; straight
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

#+end_src

*** use-package

#+begin_src emacs-lisp

(straight-use-package 'use-package)

#+end_src

*** Customize interface

#+begin_src emacs-lisp

;; Customize interface code blocks
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)

#+end_src

** Configuration management
*** Debugging

#+begin_src emacs-lisp

(setq debug-on-error t)

#+end_src

** General purpose functions
*** Queries
**** match-regexs

#+begin_src emacs-lisp

(defun custom/match-regexs (string patterns)
  "Return t if all provided regex PATTERNS
(provided as a list) match STRING."
  (cl-loop for pattern in patterns
	   if (not (string-match pattern string))
	   return nil
	   finally return t))

#+end_src
**** at
***** at-point

#+begin_src emacs-lisp

(defun custom/at-point (go-to-point &optional position)
  (let ((position (or position (point))))
    (save-excursion
      (funcall go-to-point)
      (= position (point)))))

#+end_src

***** at-bovl

#+begin_src emacs-lisp

(defun custom/at-bovl (&optional position)
  (custom/at-point 'beginning-of-visual-line position))

#+end_src

***** at-indent

#+begin_src emacs-lisp

(defun custom/at-indent (&optional position)
  (custom/at-point 'back-to-indentation position))

#+end_src

**** line
***** relative-line

#+begin_src emacs-lisp

(defun custom/relative-line (query &optional number &rest args)
  "Return the result of a boolean query at the beginning
of the current visual line, or another specified by its
relative position to the current line.
Optionally, `args' may be given as input to be passed
to the query at execution."
  (let ((number (or number 0)))
    (save-excursion
      (beginning-of-visual-line (+ number 1))
      (apply query args))))

#+end_src

***** relative-line-regex

#+begin_src emacs-lisp

(defun custom/relative-line-regex (pattern &optional number)
  (custom/relative-line 'looking-at-p number pattern))

#+end_src

***** relative-line-empty

#+begin_src emacs-lisp

(defun custom/relative-line-empty (&optional number)
  (custom/relative-line-regex "[[:blank:]]*$" number))

#+end_src

***** relative-line-indented

#+begin_src emacs-lisp

(defun custom/relative-line-indented (&optional number)
  (custom/relative-line-regex "[[:blank:]]+.*$" number))

  #+end_src

**** region
***** region-count-visual-lines

#+begin_src emacs-lisp

(defun custom/region-count-visual-lines ()
  "Count visual lines in an active region."
  (interactive)
  (save-excursion 
    (beginning-of-visual-line)
    (count-screen-lines (region-beginning) (region-end))))

#+end_src

***** region-multiline-visual

#+begin_src emacs-lisp

(defun custom/region-multiline-visual ()
  "Return t if a region is active and spans more than one visual line."
  (and (region-active-p) (> (custom/region-count-visual-lines) 1)))

#+end_src

**** in-mode

#+begin_src emacs-lisp

(defun custom/in-mode (mode)
  "Return t if mode is currently active."
  (string-equal major-mode mode))

#+end_src

**** current-theme

#+begin_src emacs-lisp

;; Retrieve current theme
(defun custom/current-theme ()
  (substring (format "%s" (nth 0 custom-enabled-themes))))

#+end_src

**** current-window-number

#+begin_src emacs-lisp

(defun custom/current-window-number ()
  "Retrieve the current window's number."
  (setq window (prin1-to-string (get-buffer-window (current-buffer))))
  (string-match "^[^0-9]*\\([0-9]+\\).*$" window)
  (match-string 1 window))

#+end_src

*** Retrieval
**** get-point

#+begin_src emacs-lisp

(defun custom/get-point (command &rest args)
  (interactive)
  (save-excursion
    (apply command args)
    (point)))

#+end_src

**** active-region

#+begin_src emacs-lisp

;; Retrieve active region
(defun custom/active-region (beg end)
  (set-mark beg)
  (goto-char end)
  (activate-mark))

#+end_src

*** Operators
**** <>

#+begin_src emacs-lisp

(defun <> (a b c)
  (and (> b a) (> c b)))

#+end_src
* System
** File management
*** dos2unix

#+begin_src emacs-lisp

;; Transform all files in directory from DOS to Unix line breaks
(defun custom/dos2unix (&optional dir)
  (let ((dir (or dir (file-name-directory buffer-file-name)))
	      (default-directory dir))
    (shell-command "find . -maxdepth 1 -type f -exec dos2unix \\{\\} \\;")))

#+end_src

* Display
** Defaults

#+begin_src emacs-lisp

;; Frame name
(setq-default frame-title-format '("Emacs [%m] %b"))

;; Inhibit startup message
(setq inhibit-startup-message t)

;; Disable visible scroll bar
(scroll-bar-mode -1)

;; Disable toolbar
(tool-bar-mode -1)

;; Disable tooltips
(tooltip-mode -1)

;; Disable menu bar
(menu-bar-mode -1)

#+end_src
** Warnings
*** Visible bell

#+begin_src emacs-lisp

;; Enable visual bell
(setq visible-bell t)

#+end_src
*** Confirmations

#+begin_src emacs-lisp

(advice-add 'yes-or-no-p :override 'y-or-n-p)

#+end_src

** Mode line

#+begin_src emacs-lisp

(defun custom/hide-modeline ()
  (interactive)
  (if mode-line-format
      (setq mode-line-format nil)
    (doom-modeline-mode)))

(global-set-key (kbd "M-m") #'custom/hide-modeline)

#+end_src

** Centering

#+begin_src emacs-lisp

;; Center text
(use-package olivetti
  :delight olivetti-mode
  )

(add-hook 'olivetti-mode-on-hook (lambda () (olivetti-set-width 0.9)))

;; Normal modes
(dolist (mode '(org-mode-hook
		    magit-mode-hook))
  (add-hook mode 'olivetti-mode))

;; Programming modes
(add-hook 'prog-mode-hook 'olivetti-mode)

#+end_src

** Fringes

#+begin_src emacs-lisp

;; Set width of side fringes
(set-fringe-mode 0)

#+end_src

* Guidance
** Search
*** Swiper

#+begin_src emacs-lisp

;; Swiper
(use-package swiper)
(require 'swiper)

#+end_src

**** Smart search

#+begin_src emacs-lisp

;; Smart search
(defun custom/search-region (beg end)
  "Search selected region with swiper-isearch."
  (swiper-isearch (buffer-substring-no-properties beg end)))

(defun custom/smart-search (beg end)
  "Search for selected regions. If none are, call swiper-isearch."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (deactivate-mark)
  (if (and beg end)
      (custom/search-region beg end)
    (swiper-isearch)))

(define-key global-map (kbd "C-s") #'custom/smart-search)

#+end_src

**** Narrow search

#+begin_src emacs-lisp

(defun custom/narrow-and-search (beg end)
  "Narrow to region and trigger swiper search."
  (narrow-to-region beg end)
  (deactivate-mark)
  (swiper-isearch))

(defun custom/search-in-region (beg end)
  "Narrow and search active region. If the current
buffer is already narrowed, widen buffer."
  (interactive (if (use-region-p)
                   (list (region-beginning) (region-end))
                 (list nil nil)))
  (if (not (buffer-narrowed-p))
      (if (and beg end)
	  (progn (custom/narrow-and-search beg end)))
    (progn (widen)
	   (if (bound-and-true-p multiple-cursors-mode)
	       (mc/disable-multiple-cursors-mode)))))

(defun custom/swiper-exit-narrow-search ()
  (interactive)
  (minibuffer-keyboard-quit)
  (if (buffer-narrowed-p)
      (widen)))

;; Narrow search
(define-key global-map (kbd "C-r") #'custom/search-in-region)

;; Exit narrow search from swiper
(define-key swiper-map (kbd "C-e") #'custom/swiper-exit-narrow-search)

#+end_src

**** Multiple cursors

#+begin_src emacs-lisp

(defun custom/swiper-multiple-cursors ()
  (interactive)
  (swiper-mc)
  (minibuffer-keyboard-quit))

;; M-RET: multiple-cursors-mode
(define-key swiper-map (kbd "M-<return>") 'custom/swiper-multiple-cursors)

#+end_src

** Completion
*** Ivy

#+begin_src emacs-lisp

;; Ivy completion framework
(use-package counsel)
(use-package ivy
  :delight ivy-mode
  :bind (:map ivy-minibuffer-map
	       ("TAB" . ivy-alt-done)
	       ("C-l" . ivy-alt-done)
	       ("C-j" . ivy-next-line)
	       ("C-k" . ivy-previous-line)
	       :map ivy-switch-buffer-map
	       ("C-k" . ivy-previous-line)
	       ("C-l" . ivy-done)
	       ("C-d" . ivy-switch-buffer-kill)
	       :map ivy-reverse-i-search-map
	       ("C-k" . ivy-previous-line)
	       ("C-d" . ivy-reverse-i-search-kill))
  :init (ivy-mode 1))

;; Completion candidate descriptions
(use-package ivy-rich
  :bind
  (("<menu>" . counsel-M-x))
  :init (ivy-rich-mode 1))

#+end_src

*** Command suggestions

#+begin_src emacs-lisp

;; Command suggestions
(use-package which-key
  :delight which-key-mode
  :config
  (which-key-mode)
  (setq which-key-idle-delay 1.0))

#+end_src
** Documentation

#+begin_src emacs-lisp

;; Replace description key bindings by their helpful equivalents
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-command]  . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key]      . helpful-key))

#+end_src

** Live command display

#+begin_src emacs-lisp

(use-package command-log-mode
  :delight command-log-mode)
(global-command-log-mode)

#+end_src

* Navigation
** Text
*** home

#+begin_src emacs-lisp

(defun custom/home ()
  "Conditional homing. 

Default: `beginning-of-line-text'

If the current line is empty, home to `beginning-of-line'.

If the current line is a wrapped visual line, home to
`beginning-of-visual-line'."
  (interactive)
  (cond ((custom/relative-line-empty)                                                                (beginning-of-line))
	      ((custom/relative-line-indented)                                                             (back-to-indentation))
        ((< (custom/get-point 'beginning-of-visual-line) (custom/get-point 'beginning-of-line-text)) (beginning-of-visual-line))
        (t                                                                                           (beginning-of-line-text))))

(defvar custom/double-home-timeout 0.4)

(defun custom/double-home ()
  "Dynamic homing command with a timeout of `custom/double-home-timeout' seconds.
- Single press: `custom/home' 
- Double press: `beginning-of-visual-line'"
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)	     
             (<= (time-to-seconds (time-since last-called)) custom/double-home-timeout))
        (if (< (custom/get-point 'beginning-of-visual-line) (custom/get-point 'beginning-of-line))
            (beginning-of-visual-line)
          (beginning-of-line))
      (custom/home)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<home>") 'custom/double-home)

#+end_src
    
*** end

#+begin_src emacs-lisp

;; Double end to go to the beginning of line
(defvar custom/double-end-timeout 0.4)

(defun custom/double-end ()
  "Move to end of visual line. If the command is repeated 
within `custom/double-end-timeout' seconds, move to end
of line."
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
             (<= (time-to-seconds (time-since last-called)) custom/double-end-timeout))
        (progn (beginning-of-visual-line) (end-of-line))
      (end-of-visual-line)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<end>") 'custom/double-end)

#+end_src
** Screen
*** Buffer
**** Switching

#+begin_src emacs-lisp

;; Counsel buffer switching
(global-set-key (kbd "C-x b") 'counsel-switch-buffer)

#+end_src

**** Split and follow

#+begin_src emacs-lisp

;; Split and follow
(defun split-and-follow-horizontally ()
  (interactive)
  (split-window-below)
  (other-window 1))
(global-set-key (kbd "C-x 2") 'split-and-follow-horizontally)

(defun split-and-follow-vertically ()
  (interactive)
  (split-window-right)
  (other-window 1))
(global-set-key (kbd "C-x 3") 'split-and-follow-vertically)

#+end_src

*** Window
**** ace-window

#+begin_src emacs-lisp

;; ace-window
(global-set-key (kbd "C-o") 'ace-window)

#+end_src

**** winner-mode

#+begin_src emacs-lisp

;; winner mode
(winner-mode)

#+end_src

*** Frame

#+begin_src emacs-lisp

;; Create new frame
(global-set-key (kbd "C-S-n") 'make-frame-command)

#+end_src
** Escape
*** Bindings

#+begin_src emacs-lisp

;; Record last sent message
(defvar last-message nil)
(defadvice message (after my-message pre act) (setq last-message ad-return-value))

(defun custom/undefined-override (orig-fun &rest args)
  "Override `undefined' function to suppress
undefined key binding messages when interrupting
key binding input with C-g."
  (let ((inhibit-message t)
	      (message-log-max nil))
    (progn (apply orig-fun args)
	         (setq _message last-message)))
  (if (string-match-p (regexp-quote "C-g is undefined") _message)
      (keyboard-quit)
    (message _message)))

;; Override the undefined key binding notice with a keyboard-quit
(advice-add 'undefined :around #'custom/undefined-override)

#+end_src

*** Windows

#+begin_src emacs-lisp

(defun custom/escape-window-or-region ()
  "Set course of action based current window.

If the window is dedicated, `quit-window'.
If the dedicated window is not deleted by 
`quit-window' (such as for `command-log-mode'),
proceed to `delete-window'.

If the window is not dedicated, deactivate
mark if a region is active."
  (interactive)
  (setq escaped-window (custom/current-window-number))  
  (if (window-dedicated-p (get-buffer-window (current-buffer)))
      (progn (quit-window)
	           (if (string-equal escaped-window (custom/current-window-number))
		       (delete-window)))
    (if (region-active-p)
	      (deactivate-mark))))

#+end_src

*** Minibuffer

#+begin_src emacs-lisp

;; Minibuffer escape
(add-hook 'minibuffer-setup-hook (lambda () (local-set-key (kbd "<escape>") 'minibuffer-keyboard-quit)))

#+end_src

*** Double escape

#+begin_src emacs-lisp

;; Global double escape
(defvar custom/double-escape-timeout 1)

(defun custom/double-escape ()
  "Execute `custom/escape-window-or-region'. If the command 
is repeated within `custom/double-escape-timeout' seconds, 
kill the current buffer and delete its window."
  (interactive)
  (let ((last-called (get this-command 'custom/last-call-time)))
    (if (and (eq last-command this-command)
             (<= (time-to-seconds (time-since last-called)) custom/double-escape-timeout))
        (if (kill-buffer)
	          (delete-window))
      (custom/escape-window-or-region)))
  (put this-command 'custom/last-call-time (current-time)))

(global-set-key (kbd "<escape>") 'custom/double-escape)

#+end_src

* Editing
** Delete
*** Region

#+begin_src emacs-lisp

(defun custom/delete-region ()
  "Conditional region deletion.

Default: `delete-region'

If region starts at indented line, delete
region and indent plus one character."
  (interactive)
  (save-excursion
    (progn (setq beg (region-beginning) end (region-end))
	         (if (custom/at-indent beg)
		     (progn (beginning-of-visual-line)
			    (if (and (org-in-src-block-p) (not (custom/at-point 'beginning-of-buffer)))
				(left-char))
			    (delete-region (point) end))
		   (delete-region beg end)))))

#+end_src

*** Forward

#+begin_src emacs-lisp

(defun custom/nimble-delete-forward ()
  "Conditional forward deletion.

Default: `delete-forward-char' 1

If next line is empty, forward delete indent of 
next line plus one character."
  (interactive)
  (if (and (custom/at-eol) (custom/relative-line-indented 1))
      (progn (save-excursion
	             (next-line)
		     (back-to-indentation)
		     (delete-region (point) (line-beginning-position)))
	           (delete-forward-char 1))
    (delete-forward-char 1)))

(global-set-key (kbd "<deletechar>") 'custom/nimble-delete-forward)

#+end_src

*** Backward

#+begin_src emacs-lisp

(defun custom/nimble-delete-backward (orig-fun &rest args)
  "Conditional forward deletion.

Default: `delete-backward-char' 1

If `multiple-cursors-mode' is active, `delete-backward-char' 1.

Else, if region is active, delete region. If Org Mode is active and 
the previous line if not empty, `custom/nimble-delete-forward' from 
the `end-of-visual-line' of the previous line.

Else, if cursor lies either `custom/at-indent' level or is preceded only 
by whitespace, delete region from `point' to `line-beginning-position'.

Else, if cursor lies at the `end-of-visual-line' of a folded Org Mode
heading, unfold heading and `delete-backward-char' 1."
  (if (not multiple-cursors-mode)
      (if (region-active-p)
	        (custom/delete-region)
	      (if (and (or (custom/at-indent) (custom/relative-line-empty)) (not (custom/at-bol)))
		  (delete-region (point) (custom/get-point 'beginning-of-visual-line))
		(if (and (custom/relative-line-org-heading-folded) (custom/at-point 'end-of-visual-line))
		    (progn (beginning-of-visual-line) (end-of-line) (apply orig-fun args))
		  (apply orig-fun args))))
    (apply orig-fun args)))

(advice-add 'delete-backward-char :around #'custom/nimble-delete-backward)

#+end_src

** Undo, Redo
*** Kill ring

#+begin_src emacs-lisp

;; Increase kill ring size
(setq kill-ring-max 200)

#+end_src

** Cut, Copy, Paste

#+begin_src emacs-lisp

;; Copy region with S-left click
(global-set-key (kbd "S-<mouse-1>")      'mouse-save-then-kill)
(global-set-key (kbd "S-<down-mouse-1>")  nil)

;; Paste with mouse right click
(global-set-key (kbd "<mouse-3>")        'yank)
(global-set-key (kbd "<down-mouse-3>")    nil)

#+end_src

* Coding
** Execution
*** Emacs Lisp
**** IELM

#+begin_src emacs-lisp

;; IELM
(global-set-key (kbd "C-l") 'ielm)

;; Exit IELM
(with-eval-after-load 'ielm
  (define-key ielm-map (kbd "C-l") 'kill-this-buffer))

#+end_src

**** Buffer

#+begin_src emacs-lisp

;; Buffer evaluation
(global-set-key (kbd "C-x e") 'eval-buffer)

#+end_src

** Syntax highlighting
*** Rainbow delimiters

#+begin_src emacs-lisp

;; Enable rainbow delimiters on all programming modes
(use-package rainbow-delimiters)

(add-hook 'prog-mode-hook 'rainbow-delimiters-mode)

#+end_src

* Templates
** yasnippet

#+begin_src emacs-lisp

;; yasnippet
(use-package yasnippet)

(yas-global-mode 1)

#+end_src

*** <

#+begin_src emacs-lisp

(defun custom/<-snippet (orig-fun &rest args)
  "Require < before snippets."
  (interactive)
  (setq line (buffer-substring-no-properties (line-beginning-position) (line-end-position)))
	(if (not (string-equal line ""))
	    (if (string-equal (substring line 0 1) "<")
		(progn (save-excursion (move-beginning-of-line nil)
				       (right-char 1)
				       (delete-region (line-beginning-position) (point)))
		       (apply orig-fun args)))))

(advice-add 'yas-expand :around #'custom/<-snippet)

#+end_src

*** Snippets

#+begin_src emacs-lisp

;; yasnippet-snippets
(use-package yasnippet-snippets)

#+end_src

* Git

#+begin_src emacs-lisp

(use-package magit)

#+end_src

* LaTeX
* Org Mode

#+begin_src emacs-lisp

(require 'org (concat config-directory "org.el"))

#+end_src

* Theme

#+begin_src emacs-lisp

(require 'theme (concat config-directory "theme.el"))

#+end_src

** Theme-agnostic enabling hook


#+begin_src emacs-lisp

;; Theme-agnostic enabling hook
(defvar after-enable-theme-hook nil
   "Normal hook run after enabling a theme.")

(defun run-after-enable-theme-hook (&rest _args)
   "Run `after-enable-theme-hook'."
   (run-hooks 'after-enable-theme-hook))

;; enable-theme
(advice-add 'enable-theme :after #'run-after-enable-theme-hook)

#+end_src

*** Org Mode

#+begin_src emacs-lisp

;; Reload Org Mode
(defun custom/org-theme-reload ()
  (if (custom/in-mode "org-mode")
      (org-mode)))

(add-hook 'after-enable-theme-hook #'custom/org-theme-reload)

#+end_src

* Declare

#+begin_src emacs-lisp

;; Conclude initialization file
(provide 'init)

#+end_src
